                               Synthesis From Examples: Interaction Models and Algorithms
                                                                     (Invited Talk Paper)
                                                                       Sumit Gulwani
                                                                     Microsoft Research
                                                                     Redmond, WA, USA
                                                                   sumitg@microsoft.com
                 Abstract—Examples are often a natural way to specify               There are two key challenges in designing inductive
              various computational artifacts such as programs, queries,         synthesizers that take examples as speciﬁcations. The ﬁrst
              and sequences. Synthesizing such artifacts from example based      challenge is that of designing a good user interaction model
              speciﬁcations has various applications in the domains of end-      that can deal with the inherent ambiguities in examples,
              user programming and intelligent tutoring systems. Synthesis       which are often an under-speciﬁcation of the user’s intent.
              from examples involves addressing two key technical chal-
              lenges: (i) design of a user interaction model to deal with        §II discusses a variety of effective user interaction models.
              the inherent ambiguity in the example based speciﬁcation. (ii)        The second challenge is that of designing an efﬁcient
              design of an efﬁcient search algorithm - these algorithms have     algorithm that can search for desired artifacts (in the under-
              been based on paradigms from various communities including         lying DSL) that are consistent with the given examples. §III
              use of SAT/SMT solvers (formal methods community), version         discusses some general algorithmic methodologies. These
              space algebras (machine learning community), and A*-style
              goal-directed heuristics (AI community).                           involve use of techniques that have been developed in
                 This paper describes some effective user interaction models     various communities including use of SAT/SMT constraint
              and algorithmic methodologies for synthesis from examples          solvers (formal methods community), version space algebras
              while discussing synthesizers for a variety of artifacts rang-     (machine learning community), and A*-style goal-directed
              ing from tricky bitvector algorithms, spreadsheet macros for       heuristics (AI community).
              automating repetitive data manipulation tasks, ruler/compass
              based geometry constructions, algebraic identities, and pre-          We brieﬂy discuss applications of inductive synthesizers
              dictive intellisense for repetitive drawings and mathematical      to not only synthesis of a variety of traditional programs
              terms.                                                             such as bitvector algorithms (§IV-A) and spreadsheet macros
                 Keywords-Program Synthesis, Inductive Synthesis, End User       (§IV-B) but also to synthesis of more general structured con-
              Programming, Intelligent Tutoring Systems, Domain Speciﬁc          cepts or artifacts such as geometric constructions (§IV-C),
              Languages, Programming By Example                                  algebraic identities (§IV-D), sequences (§IV-E), and even
                                    I. INTRODUCTION                              drawings (§IV-F).
                 Program synthesis is the task of automatically synthe-                           II. INTERACTION MODELS
              sizing a program in some underlying domain-speciﬁc lan-               While examples constitute the most natural form of speci-
              guage (DSL) from a given speciﬁcation using some search            ﬁcation in several cases, they are often an under-speciﬁcation
              technique [1]. A traditional view of program synthesis is          of the intent. We discuss below some general methodologies
              that of synthesizing programs from complete speciﬁcations.         for resolving ambiguities in the example based speciﬁcation.
              One approach is to give a speciﬁcation as a formula in a           A. User Driven Interaction
              suitable logic [2]–[7]. Another is to write the speciﬁcation
              as a simpler, but possibly far less efﬁcient program [8]–[10].        This is the most intuitive and widely applicable interaction
              While these approaches have the advantage of completeness          model. The user may verify the artifact returned by the
              of speciﬁcation, such speciﬁcations are often unavailable,         synthesizer either by examining the artifact itself, or by
              difﬁcult to write, or expensive to check against using au-         examining its behavior on several other inputs. If the user
              tomated veriﬁcation techniques. In this paper, we focus on         ﬁnds any discrepancy in the behavior of the artifact and
              another style of speciﬁcation, namely examples [11]–[13].          the expected behavior on some new input, the user may
              Programming by example (PBE) can be seen as a dual                 repeat the synthesis process after adding the new input-
              to program testing, which has seen decades of successful           output example to the previous set of input-output examples.
              research. Instead of ﬁnding test cases that explore various        B. Synthesizer Driven Interaction
              paths in a given program (and potentially expose any bugs),
              the goal here is to synthesize programs in the ﬁrst place             This interaction model obviates the need for the user to
              starting from test cases, i.e., input-output examples.             verify the synthesized artifact and provide any counterexam-
                                             User                                                  Synthesizer
                                       Input → Output        Program 1                Program 2                              Distinguishing Input ?
                                       01011 → 01000         (x+1)&(x−1)              (x+1)&x                                00000 ?
                                       00000 → 00000         −(¬x)&x                  (((x&−x)| −(x−1))&x)⊕x                 00101 ?
                                       00101 → 00100         (x+1)&x                  · · ·                                  01111 ?
                                       01111 → 00000         · · ·                    · · ·                                  00110 ?
                                       00110 → 00000         · · ·                    · · ·                                  01100 ?
                                       01100 → 00000         · · ·                    · · ·                                  01010 ?
                                       01010 → 01000         (((x −1)|x)+1)&x         None                                   Program is
                                                                                                                             (((x −1)|x)+1)&x
                                                                                                                             ((((((xx −− 1)1)||xx)) ++ 1)&1)&xx
                 Figure 1.   An illustration of the synthesizer driven interaction model [14] for synthesis of a bitvector algorithm (§IV-A) from input-output examples (for
                 the task of turning off the righmost contiguous sequence of 1 bits). Program 1 and Program 2 are two semantically different programs generated by the
                 synthesizer that are consistent with the past set of input-output pairs (in previous rows) provided by the user. The synthesizer also produces a distinguishing
                 input on which the two programs yield different results, and asks the user for the output corresponding to the distinguishing input. The process is repeated
                 until the synthesizer can ﬁnd at most one program.
                 ple input. Instead the synthesizer generates a new input in                     Guided Inductive Synthesis (CEGIS) methodology, wherein
                 each round and prompts the user for output on that input.                       examples are iteratively generated from counterexamples
                    Given a set of input-output examples, the synthesizer                        that exhibit deviation between the candidate solution and
                 searches for programs in the underlying DSL that map each                       the formal speciﬁcation. The counterexamples are generated
                 input in the given set of examples to the corresponding                         automatically using SAT/SMT based constraint solvers. This
                 output. The number of such programs may either be 0,                            methodology has been used for synthesizing a large variety
                 1, or more than 1. If the synthesizer is unable to ﬁnd                          of programs including bitvector algorithms [4], graph algo-
                 any such program over the search space, the synthesizer                         rithms [5], and vectorized code fragments [20]. It also forms
                 declares failure. If the synthesizer ﬁnds exactly 1 program,                    the basis for program synthesis by sketching [21].
                 the synthesizer declares success and presents the program to                                             III. ALGORITHMS
                 the user. If the synthesizer ﬁnds at least two (semantically
                 distinct) programs P and P , both of which map each input                          The key technical challenge in synthesis from examples
                                          1         2
                 in the given set to the corresponding output, the synthesizer                   is to map the examples to artifact(s) in the underlying DSL.
                 declares the user speciﬁcation to be partial. It then generates                 This is essentially a search problem, and can beneﬁt from
                 a distinguishing input, an input on which the two programs                      techniques developed in various communities. We present
                 P and P yield different results, and asks the user to                           below certain classes of techniques that have been frequently
                   1          2
                 provide the output corresponding to the distinguishing input.                   used in recent work on synthesis.
                 The synthesis process is then repeated after adding this                        A. Version Space Algebras
                 new input-output pair to the previous set of input-output
                 examples. This interaction model is described in [14] and is                       One class of techniques is based on the concept of
                 illustrated in Fig. 1.                                                          version-space algebras, where the key idea is to design data-
                                                                                                 structures and algorithms to succinctly represent and manip-
                 C. Randomly Selected Examples                                                   ulate the set of all artifacts that are consistent with a given
                    In certain domains, if the examples are selected uniformly                   example(s) [22]. In particular, the following ingredients are
                 at random from among the space of all valid examples, and                       required:
                 if an artifact is consistent with those selected examples, then                    • Data structure for representing consistent artifacts: The
                 the artifact is the intended artifact with high probability (over                     number of artifacts in the underlying DSL that are
                 the choice of the examples). A well-known instance of such                            consistent with a given set of examples is often huge.
                 a domain is that of polynomials and the probabilistic result                          Weneed a data structure to succinctly represent a large
                 follows from the classical result on polynomial identity                              set of such artifacts.
                 testing [15]. We have extended the identity testing result                         • Algorithm for synthesizing consistent artifacts: It in-
                 to restricted forms of linear programs [16], [17], geometric                          volves two key procedures: (i) A procedure to learn
                 constructions [18], and algebraic identities [19]. The latter                         the set of all artifacts, represented using the above
                 results have led to inductive synthesizers for respective                             data structure, that are consistent with a given single
                 domains [18], [19].                                                                   example. (ii) A procedure to intersect these sets (each
                 D. Counterexample Guided Synthesis                                                    corresponding to a different example).
                                                                                                    • Ranking:Thenumberofexamplesrequiredtoidentifya
                    Even when a complete formal speciﬁcation is available, it                          unique artifact can often be large. Hence, it is desirable
                 is often best to reduce the synthesis problem to synthesizing                         to use some form of ranking to guess the desired artifact
                 from examples. This is done by using a Counterexample                                 from a small number of examples. The effectiveness of
                   such a ranking is inspired by Occam’s razor, which        based methodology (§II-B) [14], then the reduction of the
                   states that a smaller and simpler explanation is usu-     synthesis problem to solving of SAT/SMT constraints can
                   ally the correct one. The ranking scheme should be        be performed for a larger variety of programs.
                   consistent with the underlying version-space algebra in
                   order to retain efﬁciency, i.e., it should be based on                          IV. ARTIFACTS
                   features that are invariant of the underlying version-       There is a huge variety of artifacts that can be synthesized
                   space. The ranking can also be a function of the user-    from examples. We start out with an application in the
                   provided examples [23]; in addition, it can also take     traditional domain of algorithm synthesis (bitvector algo-
                   into account any test inputs provided by the user (i.e.,  rithms §IV-A). Then, we discuss some useful applications in
                   new additional inputs on which the user may execute a     the domain of end-user programming (spreadsheet macros
                   synthesized program).                                     §IV-B). We also discuss some surprising applications in
                Version-space algebras were pioneered by Mitchell for        the domain of intelligent tutoring systems ranging from
              reﬁnement-based learning of Boolean functions [24], while      solution generation (geometry constructions §IV-C) to prob-
              Lau et.al. [25] extended the concept to learning more          lem generation (algebraic proof problems §IV-D) to content
              complex functions in a Programming By Demonstration            entry (intellisense for drawings §IV-F and mathematical
              (PBD) setting [11], [12]. We have lifted the concepts of       expressions §IV-E).
              version-space algebra to the PBE setting for fairly expressive
              DSLs(involving conditionals and loops) for spreadsheet data    A. Bitvector Algorithms
              manipulation including syntactic string transformations [26],     Bitvector algorithms are typically straight-line sequence
              semantic string transformations [27], number transforma-       of instructions that use both arithmetic and logical bitwise
              tions [28], and table transformations [29].                    operators.1 Such programs can be quite unintuitive and
              B. Brute Force Search                                          extremely difﬁcult for average, or sometimes even expert,
                The general idea here is to systematically explore the en-   programmers to discover methodically.
              tire state space of artifacts and check the correctness of each   Consider the task of masking the right-most signiﬁcant 1-
              candidate against the given examples. This approach works      bit in an input bitvector, (e.g., converting 01100 into 01000).
              relatively well when the speciﬁcation consists of examples     A simple method to accomplish this would be to iterate
              (as opposed to a formal relational speciﬁcation) since check-  over the input bitvector starting from the rightmost end
              ing the correctness of a candidate solution against examples   until a 1 bit is found and then set it to 0. However, this
              can be done much faster than validating the correctness        algorithm is worst-case linear in the number of bits in the
              against a formal relational speciﬁcation. However, this is     input bitvector. Furthermore, it uses undesirable branching
              easier said than done and often requires innovative non-       code inside a loop. There is a non-intuitive, but quite elegant,
              trivial optimizations. Following are some instances of such    way to achieving the desired functionality in constant time
              optimizations have been inspired by paradigms from various     by using a tricky composition of the standard subtraction
              communities: goal-directed search [18] (AI community),         operator and the bitwise logical & operator, which are
              branch and bound [20], clues based on textual features of      supported by almost every architecture. In particular, the
              examples [23] (Machine Learning community), and common         desired functionality can be achieved using the following
              subexpression evaluation [19] (PL community).                  composition: x & (x − 1). Fig. 1 describes an algorithm
                                                                             for a more sophisticated problem of masking the right-
              C. Constraint Solving                                          most contiguous sequence of 1-bits. As yet another example,
                Thegeneral idea here is to reduce the synthesis problem to   consider the task of computing (the ﬂoor of) the average of
              that of solving a SAT/SMT formula and let an off-the-shelf     two 32-bit integers x and y. Note that computing average
              SAT/SMT solver efﬁciently explore the search space. This       using the expression (x+y)/2 is inherently ﬂawed and vul-
              exploits the recent advances made in the Satisﬁability (SAT)   nerable since it can overﬂow. However, using some bitwise
              and Satisﬁability Modulo Theory (SMT) solving technology       tricks, the average can be computed without overﬂowing and
              to efﬁciently explore the search space of programs.            without using conditionals; one such way to compute it is:
                This approach has been applied to synthesis from com-        (x&y)+((x⊕y)>>1)).
              plete formal speciﬁcations, but its applicability has been        [14] describes a constraint solving based (§III-C) induc-
              limited to synthesizing restricted forms of artifacts such     tive synthesizer for such bitvector programs. These programs
              as switching logics [6], program inverses [10], or pro-          1These algorithms “typically describe some plausible yet unusual op-
              grams whose correctness proof involves a given set of          eration on integers or bit strings that could easily be programmed using
              templates [3]. On the other hand, if the speciﬁcation is in    either a longish ﬁxed sequence of machine instructions or a loop, but the
              the form of examples, possibly generated using a CEGIS         same thing can be done much more cleverly using just four or three or two
                                                                             carefully chosen instructions whose interactions are not at all obvious until
              loop (§II-D) [4], [5], [20], [21] or distinguishing-input      explained or fathomed” [30].
                 (a) Syntactic String Transformation
                   Input v1         Output             (d) Semantic String Transformation
                   Adam Smith       Smith, A.            Input v    Input v       Output
                   Sumit Gulwani    Gulwani, S.                 1           2
                   George Necula    Necula, G.           Stroller   10/12/2010    $145.67+0.30*145.67
                   Peter Lee        Lee, P.              Bib        23/12/2010    $3.56+0.45*3.56
                   Madhur Malik     Malik, M.            Diapers    21/1/2011     $21.45+0.35*21.45
                                                         Wipes      2/4/2009      $5.12+0.40*5.12
                 (b) Number Transformation               Aspirator  23/2/2010     $2.56+0.30*2.56
                   Input v1      Output
                   0d 5h 26m     5:00                      Background Knowledge (user-deﬁned) Tables      (e) Table Transformation
                   0d 4h 57m     4:30                               MarkupRec                             Input Table:
                   0d 4h 27m     4:00                        Id     Name        Markup                                 Qual 1        Qual 2       Qual 3
                   0d 3h 57m     3:30                        S33    Stroller    30%                        Andrew     01.02.2003   27.06.2008   06.04.2007
                                                             B56    Bib         45%                          Ben      31.08.2001                05.07.2004
                 (c) Semantic String Transformation          D32    Diapers     35%                          Carl                  18.04.2003   09.12.2009
                   Input v1     Output                       W98    Wipes       40%
                   6-3-2008     Jun 3, 2008                  A46    Aspirator   30%
                   3-26-2010    Mar 26, 2010                 · · ·  · · ·       · · ·                     Output Table:
                   8-1-2009     Aug 1, 2009                          CostRec                               Andrew     Qual 1   01.02.2003
                   9-24-2007    Sep 24, 2007                 Id     Date       Price                       Andrew     Qual 2   27.06.2008
                   Background Knowledge Table                S33    12/2010    $145.67                     Andrew     Qual 3   06.04.2007
                          MonthRec                           S33    11/2010    $142.38                       Ben      Qual 1   31.08.2001
                     Number     Name                         B56    12/2010    $3.56                         Ben      Qual 3   05.07.2004
                     1          January                      D32    1/2011     $21.45                        Carl     Qual 2   18.04.2003
                     2          February                     W98    4/2009     $5.12                         Carl     Qual 3   09.12.2009
                     3          March                        A46    2/2010     $2.56
                     · · ·      · · ·                        · · ·  · · ·      · · ·
               Figure 2.  Variety of spreadsheet data manipulation tasks. The inductive synthesizers described in [26]–[29] can automate the tasks in (a), (b), (c)/(d), and
               (e) respectively. The bold entries in (a)-(d) in the Output columns are automatically produced by the respective inductive synthesizers from the ﬁrst few
               example rows.
               are synthesized from examples using the distinguishing-                 that can generate scripts for automating repetitive tasks from
               input based synthesizer-driven interaction model (§II-B).               input-output examples. The inductive synthesis technology
                                                                                       for syntactic string transformations ships as the Flash Fill
               B. Spreadsheet Macros                                                   feature in Excel 2013 [31].
                  Spreadsheet users often struggle with repetitive data trans-         C. Geometry Constructions
               formations tasks. Fig. 2 illustrates some such tasks that                  Geometry constructions are essentially straight-line pro-
               involve manipulation of strings, numbers, and tables. In each           grams that manipulate geometry objects (points, lines, and
               of these cases, the users can easily express their intent using         circles) using ruler and compass operators. Hence, the prob-
               examples, from which the desired scripts for task automation            lem of synthesizing geometry constructions can be phrased
               can be synthesized.                                                     as a synthesis problem [18] in a manner very similar to the
                  We have deﬁned various DSLs for transformations on                   problem of synthesizing bitvector algorithms (§IV-A), which
               strings [26], [27], numbers [28], and tables [29]. The DSL              are straight-line programs over bitvector operators. Fur-
               for Syntactic string transformations [26] includes substring            thermore, because of probabilistic testing property (§II-C),
               and concatenate operators along with limited forms of reg-              geometric constructions can be synthesized from random
               ular expressions, conditionals, and loops. Semantic string              examples or models. Fig. 3 illustrates the workﬂow, wherein
               transformations [27] combine syntactic transformations with             random models can be generated from logical description of
               lookup operations from other relational tables (contain-                the given problem using off-the-shelf numerical solvers. The
               ing required background knowledge). Number transforma-                  underlying synthesis algorithm performs brute-force search
               tions [28] allow for formatting and rounding transformations            (over an extended library of ruler/compass operators) using
               on numbers. Table transformations [29] allow for layout                 goal-directed heuristics (§III-B).
               transformations on tables.
                  Each of these languages is expressive enough to capture              D. Algebraic Identities
               several real-world tasks in the underlying domain, but also                Generating fresh problems that involve using a given set
               restricted enough to enable efﬁcient learning from exam-                of concepts and have a given difﬁculty level is often a tedious
               ples. For each of these languages, we have developed a                  task for the teacher. The ability to automatically generate
               version-space algebra based inductive synthesizer (§III-A)              such fresh problems has several applications: (a) It can
                                                                                                                                                               2                                        
                                                                                                                                                 (x+y)                    zx                 zy         
                                                                                                                                                                                  2                                                             3
                                                                sinA              1+cosA                                                                zx            (y +z)                 xy              = 2xyz(x+y+z)
                                Example                                       +                    =2cscA                                                                                           2 
                                Problem                      1+cosA                   sinA                                                              yz                xy            (z +x)          
                                ⇓                    (From [32])                                                                        (From [33])
                                                                                                                                                                                                                  
                                                                                                                                                 F (x,y,z)              F (x,y,z)             F (x,y,z) 
                                                                                                                                                     0                     1                     2                
                                                                                                                                                 F (x,y,z)              F (x,y,z)             F (x,y,z)                = cF (x,y,z)
                                                                                                                                                     3                     4                     5                                  9
                                                                                                                                                 F (x,y,z)              F (x,y,z)             F (x,y,z) 
                                                                  T A              1±T A                                                              6                     7                     8
                                                                    1         +             3     =2T A
                                Generalized                    1±T A                  T A                   5
                                Problem                                 2               4                                               where Fi(0 ≤ i ≤ 8) and F9 are homogeneous polynomials of degrees
                                Template             where T ∈ {cos,sin,tan,cot,sec,csc}                                                2 and 6 respectively, ∀(i,j)                       ∈ {(4,0),(8,4),(5,1),...} : Fi =
                                                                  i                                                                     F [x→y;y→z;z→x], and c ∈ {±1,±2,...,±10}.
                                ⇓                                                                                                         j
                                                                 cosA              1−sinA
                                                                 coscos AA     +11−−sinsinAA           = 2tanA
                                                                               ++                      ==      22tantanAA                                                                               
                                                                                                                                                         2                 2                       2 
                                                                                                                                                          22                22                      22  
                                                              1−sinA                  cosA                                                                                                             
                                                              11 −− sinsinAA          coscos AA                                                          y                 x             (y +x)
                                                                                                                                                        yy                xx            ((yy ++ xx))    
                                                                                                                                                                                                                                              3
                                                                                                                                                                2            2                  2                                                 33
                                                                                                                                                               22           22                 22       
                                                                 cosA              1+sinA                                                                                                              
                                                                 coscos AA         11 ++ sinsinAA                                                   (z +y)                 z                  y                = 2(xy+yz+zx)
                                                                                                                                                 ((zz ++ yy))             zz                 yy              ==      2(2(xyxy ++ yyzz ++ zzxx))
                                                                               +                       = 2secA                                                                                         
                                                                               ++                      ==      22secsecAA                                  2                      2             2
                                                                                                                                                          22                     22            22       
                                                                                                                                                       z            (x+z)                   x          
                                                              1+sinA                  cosA                                                               zz           ((xx ++ zz))            xx
                                                              11 ++ sinsinAA          coscos AA                                                                                                         
                                                                 cotA              1+cscA                                                                                        2                 2 
                                                                 cotcot AA         11 ++ csccscAA                                                                                 22                22  
                                                                                                                                                       −xy            yz +y             yz +y 
                                                                              +                        = 2secA                                          −−xyxy         yyzz ++ yy        yyzz ++ yy     
                                                                                                                                                                                                        
                                                                              ++                       ==      22secsecAA                                                                                                                     3
                                                                                                                                                                  2                                  2                                          33
                                                                                                                                                                  2                                  2
                                                                                                                                                                2                                   2 
                                                              1+cscA                  cotA                                                                                                             
                                                              11 ++ csccscAA          cotcot AA                                                        zx+z                −yz            zx+z                 = xyz(x+y+z)
                                                                                                                                                    zzxx ++ zz            −−yyzz         zzxx ++ zz          ==      xyxyzz((xx ++ yy ++ zz))
                                                                                                                                                                2                 2                    
                                                                                                                                                                 22               22                    
                                                                 tanA              1+secA                                                                                                              
                                                                 tantanAA          11 ++ secsecAA                                                     xy+x              xy+x                 −zx
                                                                                                                                                       xy+x             xy+x                 −zx
                                                                              +                        = 2cscA                                        xy+x              xy+x                 −zx
                                                                              ++                       ==      22csccscAA                                                                               
                                                                                                                                                                2                                      
                                                              1+secA                  tanA                                                                       22                                     
                                                              11 ++ secsecAA          tantanAA                                                       yz +y                 xy               xy         
                                                                                                                                                       yz +y                xy                xy
                                                                                                                                                    yz +y                   xy               xy         
                                                                                                                                                                                                                       2 2 2
                                                                                                                                                                                   2                                       22  22  22
                                                                 sinA              1−cosA                                                                                         22                    
                                                                 sinsin AA         11 −− coscosAA                                                                                                       
                                                                                                                                                          yz           zx+z                  yz              = 4x y z
                                                                                                                                                          yyzz         zzxx ++ zz            yyzz            ==      44xx yy zz
                                                                              +                        = 2cotA                                                                                         
                                New                                           ++                       ==      22cotcotAA                                                                            2
                                                                                                                                                                                                    22  
                                                             1−cosA                   sinA                                                               zx                zx           xy+x 
                                Problems                     11 −− coscosAA           sinsin AA                                                            zzxx              zzxx         xyxy ++ xx
                                                     Figure 4.        Synthesis of algebraic proof problems that are similar in structure to a given example proof problem [19].
                            English                  Construct a triangle given its base L (with end-points
                            Description              p , p ), a base angle a, and sum of the other two                                                                                    tan3A                       tan2A+tan3A
                                                       1     2                                                                                                     tanA·tan2A·tantan33AA = tanA+tantan22AA++tantan33AA
                            ⇓                        sides r.                                                                                                                                                                    
                                                                                                                                                                                                                                2
                                                                                                                                                                                             2                 2     xy−z22
                            PreCondition                               r > Length(p ,p )                                                                                          yz −x             zx−y             xyxy −− zz
                                                                                               1     2                                                                                                        2                 2
                                                                                                                                                                                            2                22                22
                                                                                                                                                                                                   xy−z              yz −x
                                                                                                                                                                                  zx−y             xyxy −− zz        yyzz −− xx
                                                                                                                                                                                                              2                 2
                                                                                                                                                                                             2                22                22
                                                                                                                                                                                                   yz −x             zx−y
                            PostCondition                                    Angle(p,p1,p2) = a ∧                                                                                 xy−z             yyzz −− xx        zzxx −− yy
                            ⇓                              Length(p,p1)+Length(p,p2) = r                                                                                                                                        3 
                                                                                                                                                                                         3                   3                  33
                                                                                                                                                                                                                      C sin γ
                                                                                                                                                                               A sin α             B sin β            CC sinsin    γγ
                                                                                                                                                                                                                         1
                                                                                                                                                                                  1                   1                  11
                                                                                                                                                                                                   B sinβ              C sinγ
                                                   L=Line(p =h81.62,99.62i,p =h99.62,83.62i)                                                                                    A sinα             BB sinsinββ         CC sinsinγγ
                                                                                                                                                                                                      2                   2
                            Random                                      1                                2                                                                        2                   22                  22
                            Model                    r     = 88.07                                    a = 0.81 radians
                            ⇓                        p     = h131.72,103.59i                                                                      Figure 5. Synthesis of low-entropy mathematical terms from their preﬁxes.
                                                     ConstructTriangle(p ,p ,L,r,a):                                                              Our tool [34] can predict the bold parts in each of the above three texts
                                                                                              1 2                                                 from the remaining preﬁxes.
                                                        L1 := ConstructLineGivenAngleLinePoint(L,a,p1);
                            Geometry                    C := ConstructCircleGivenPointLength(p ,r);
                                                          1                                                             1
                            Program                     (p ,p ) := LineCircleIntersection(L ,C );
                                                           3     4                                             1     1
                                                        L2 := PerpendicularBisector2Points(p2,p3);                                                is synthesized from the example problem(s). Second, the
                                                        p := LineLineIntersection(L ,L );
                                                          5                                         1     2                                       validity of a match for the generalized problem is performed
                                                        return p ;
                                                                    5                                                                             by testing on random inputs (§II-C). Note that this has
                          Figure 3.        Synthesis of ruler/compass based geometry constructions [18].                                          the effect that the new synthesized problems are similar
                                                                                                                                                  in structure to the given example problem and match the
                                                                                                                                                  generalized problem template. The user can control the sim-
                         help avoid copyright issues (since textbook problems cannot                                                              ilarity by providing more example problems for producing
                         simply be made available online), (b) It can help avoid                                                                  the generalized problem template or by manually editing the
                         plagiarism: Students can be provided with different problems                                                             generalized problem template.
                         that exercise the same set of concepts and have the same
                         difﬁculty level, and (c) It can help generate personalized                                                               E. Mathematical Terms
                         workﬂows: Students can be presented with the problem that                                                                     Inputting mathematical text into a computer remains a
                         is slightly more difﬁcult than the ones that they are able to                                                            painful task. Markup languages like LaTeX lead to un-
                         solve.                                                                                                                   readable text in encoded form, while WYSIWYG editors
                              Figure 4 shows some algebraic proof problems that have                                                              like Microsoft Word require users to change cursor position
                         automatically synthesized starting from a given example                                                                  several times, and switch back and forth between keyboard
                         problem [19]. There are two different by-example paradigms                                                               and mouse input.
                         that are in play here. First, a generalized problem template                                                                  Mathematical text, like several human created artifacts, is
                                       Sketch                   ⇒                 Beautiﬁcation                 ⇒                 Prediction
                            (a)
                            (b)
                Figure 6.   Synthesis of repetitive geometric drawings from partial sketches. The workﬂow involves beautiﬁcation of partial sketches into geometric
                objects [35] and prediction of other objects from the initial beautiﬁed objects by synthesizing object transformation logics [36].
                often structured and has low entropy—hence it is amenable                                            V. CONCLUSION
                to not only encryption but also prediction. Mathematical text                  General-purpose computational devices, such as smart-
                is often organized into sessions, each consisting of mutually               phones and computers, are becoming accessible to people at
                related expressions with an inherent progression. Examples                  large at an impressive rate. In the future, even robots will be-
                of such sessions include a lengthy equation, a symbolic                     come household commodities. Unfortunately, programming
                matrix, a solution to a problem, a list of problems in an                   such general-purpose platforms has never been easy, because
                exercise, and a set of related rules and axioms. Predicting                 we are still mostly stuck with the model of providing
                sub-terms that the user is likely to input next can be phrased              step-by-step, detailed, and syntactically correct instructions
                as a synthesis-from-example problem [34]. Fig. 5 illustrates                on how to accomplish a certain task, instead of simply
                some sessions containing terms with similar structure that                  describing what the task is. The synthesis technology has
                are amenable to prediction. This predictive capability can be               the potential to revolutionize this landscape, when targeted
                an important component of human-computer interfaces for                     for the right set of problems and using the right interaction
                inputting mathematical text into a computer, be it through                  model.
                speech, touch, keyboard, or multi-modal interfaces.                            We believe that the most interesting applications of the
                                                                                            synthesis technology can be in the areas of end-user pro-
                F. Repetitive Drawings                                                      gramming, and intelligent tutoring systems. In this paper,
                                                                                            we focused on example based interaction models. Another
                   Structured drawings involving line and circle objects                    effective form of interaction can be based on natural lan-
                arranged in some repetitive pattern (as shown in Fig. 6) are                guage. It remains an open research problem to design
                quite common in real-life (e.g., brick/tiling patterns, wheels,             intelligent multi-modal interfaces that can take examples,
                and architectural drawings). Making such drawings is time                   natural language, speech, touch, etc. as input. The solution
                consuming and cumbersome using existing drawing tools                       lies in bringing together various inter-disciplinary technolo-
                because they only offer the ability to copy-paste objects                   gies that can combine user intent understanding, (possibly
                in the drawing. Copy-paste functionality is not sufﬁcient to                unstructured) knowledge bases, and logical reasoning.
                enable efﬁcient construction of such diagrams since it does                                        ACKNOWLEDGMENT
                not position copied objects automatically, and is incapable
                of dealing with transformations involving scaling (as in                       I would like to thank Ben Zorn and Rico Malvar who
                Fig. 6(a)) or rotation (as in Fig. 6(b)) on copied objects.                 have been strong advocates of this inter-disciplinary line of
                Predicting the repetitive objects in a drawing from few                     research work at Microsoft Research. I would like to thank
                examples of initial objects can be phrased as a synthesis-                  all my co-authors on the various synthesis papers that are
                from-example problem [36].                                                  referenced here.
                                       REFERENCES                                  [19] R. Singh, S. Gulwani, and S. Rajamani, “Automatically
                [1] S. Gulwani, “Dimensions in program synthesis,” in PPDP,             generating algebra problems,” in AAAI, 2012.
                    2010.                                                          [20] G. Barthe, J. M. Crespo, S. Gulwani, C. Kunz, and M. Mar-
                [2] Z. Manna and R. J. Waldinger, “A deductive approach to              ron, “From relational veriﬁcation to simd loop synthesis,” in
                    program synthesis,” ACM Trans. Program. Lang. Syst., vol. 2,        PPoPP, 2013, To appear.
                    no. 1, pp. 90–121, 1980.                                       [21] A. Solar-Lezama, “Program synthesis by sketching,” 2008.
                [3] S. Srivastava, S. Gulwani, and J. Foster, “From program        [22] S. Gulwani, W. Harris, and R. Singh, “Spreadsheet data
                    veriﬁcation to program synthesis,” in POPL, 2010.                   manipulation using examples,” Communications of the ACM,
                [4] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan, “Synthesis        Aug 2012.
                    of loop-free programs,” in PLDI, 2011.                         [23] A. Menon, O. Tamuz, S. Gulwani, B. Lampson, and A. Kalai,
                [5] S. Itzhaky, S. Gulwani, N. Immerman, and M. Sagiv, “A               “A machine learning framework for programming by exam-
                    simple inductive synthesis methodology and its applications,”       ple,” in ICML, 2013, To appear.
                    in OOPSLA, 2010.                                               [24] T. M. Mitchell, “Generalization as search,” Artif. Intell.,
                [6] A. Taly, S. Gulwani, and A. Tiwari, “Synthesizing switching         vol. 18, no. 2, 1982.
                    logic using constraint solving,” in VMCAI, 2009.               [25] T. Lau, S. Wolfman, P. Domingos, and D. Weld, “Program-
                [7] S. Jha, S. Gulwani, S. Seshia, and A. Tiwari, “Synthesizing         mingbydemonstration using version space algebra,” Machine
                    switching logic for safety and dwell-time requirement,” in          Learning, vol. 53, no. 1-2, 2003.
                    ICCPS, 2010.                                                   [26] S. Gulwani, “Automating string processing in spreadsheets
                                                      ´                                 using input-output examples,” in POPL, 2011.
                [8] A. Solar-Lezama, L. Tancau, R. Bodık, S. A. Seshia, and V. A.
                    Saraswat, “Combinatorial sketching for ﬁnite programs,” in
                    ASPLOS, 2006, pp. 404–415.                                     [27] R. Singh and S. Gulwani, “Learning semantic string transfor-
                                                                                        mations from examples,” PVLDB, vol. 5, 2012.
                [9] R. Joshi, G. Nelson, and K. H. Randall, “Denali: A goal-
                    directed superoptimizer,” in PLDI, 2002, pp. 304–314.          [28] ——, “Synthesizing number transformations from input-
                                                                                        output examples,” in CAV, 2012.
               [10] S. Srivastava, S. Gulwani, S. Chaudhuri, and J. S. Foster,
                    “Path-based inductive synthesis for program inversion,” in     [29] W. R. Harris and S. Gulwani, “Spreadsheet table transforma-
                    PLDI, 2011.                                                         tions from examples,” in PLDI, 2011.
               [11] H. Lieberman, Your Wish Is My Command: Programming by          [30] H. S. Warren, Hacker’s Delight.  Addison-Wesley, ’02.
                    Example.   Morgan Kaufmann, 2001.
               [12] A. Cypher, Ed., Watch What I Do: Programming by Demon-         [31] “Flash Fill (Microsoft Excel 2013 feature),”
                    stration. MIT Press, 1993.                                          http://research.microsoft.com/users/sumitg/ﬂashﬁll.html.
               [13] S. Gulwani, “Synthesis from examples,” WAMBSE (Workshop        [32] S. L. Loney, Plane Trigonometry.     Cambridge University
                    on Advances in Model-Based Software Engineering) Special            Press.
                    Issue, Infosys Labs Brieﬁngs, vol. 10, no. 2, 2012.            [33] M. L. Khanna, IIT Mathematics.
               [14] S. Jha, S. Gulwani, S. Seshia, and A. Tiwari, “Oracle-guided   [34] O. Polozov, S. Gulwani, and S. Rajamani, “Structure and term
                    component-based program synthesis,” in ICSE, 2010.                  prediction for mathematical text,” Tech. Rep. MSR-TR-2012-
               [15] J. T. Schwartz, “Fast probabilistic algorithms for veriﬁcation      7, 2012.
                    of polynomial identities,” J. ACM, vol. 27, no. 4, 1980.       [35] S. Cheema, S. Gulwani, and J. LaViola, “Quickdraw: im-
               [16] S. Gulwani and G. C. Necula, “Discovering afﬁne equalities          proving drawing experience for geometric diagrams,” in CHI,
                    using random interpretation,” in POPL, 2003.                        2012.
               [17] S. Gulwani, “Program analysis using random interpretation,”    [36] ——,“Patternsketch: A new way to make structured drawings
                    Ph.D. dissertation, UC-Berkeley, 2005.                              with patterns,” Tech. Rep., 2012.
               [18] S. Gulwani, V. A. Korthikanti, and A. Tiwari, “Synthesizing
                    geometry constructions,” in PLDI, 2011, pp. 50–61.
