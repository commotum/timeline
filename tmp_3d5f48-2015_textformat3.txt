    © ACM 2015. This is the author's version of the work. It is posted here for your personal use. Not for redistribution. The definitive Version of Record 
    was published in GECCO 2015, http://dx.doi.org/10.1145/2739480.2754769. 
    Citation: T. Helmuth and L. Spector. General Program Synthesis Benchmark Suite. In GECCO '15: Proceedings of the 17th annual conference on 
    Genetic and evolutionary computation, pp. 1039-1046. July 2015. ACM.
                                        General Program Synthesis Benchmark Suite
                                                     ThomasHelmuth                                                                        Lee Spector
                                                      Computer Science                                                                 Cognitive Science
                                               University of Massachusetts                                                            Hampshire College
                                                     Amherst, MA 01003                                                                Amherst, MA 01002
                                             thelmuth@cs.umass.edu                                                            lspector@hampshire.edu
                    ABSTRACT                                                                                     programming techniques including the use of control ﬂow,
                    Recent interest in the development and use of non-trivial                                    modularity, and large, diverse instruction sets covering mul-
                    benchmark problems for genetic programming research has                                      tiple data types and data structures. Also, minimal sizes for
                    highlighted the scarcity of general program synthesis (also                                  solution programs should cover a range beyond what could
                    called“traditional programming”) benchmark problems. We                                      be found using brute-force search. This contrasts with most
                    present a suite of 29 general program synthesis benchmark                                    existing benchmark problems used in GP and other program
                    problems systematically selected from sources of introduc-                                   synthesis ﬁelds [6], which prescribe small, domain-speciﬁc in-
                    tory computer science programming problems. This suite is                                    struction sets and assess a system’s abilities only on a narrow
                    suitable for experiments with any program synthesis system                                   range of programming techniques.
                    driven by input/output examples. We present results from                                         In this paper we present a suite of 29 general program
                    illustrative experiments using our reference implementation                                  synthesis benchmark problems, systematically selected from
                    of the problems in the PushGP genetic programming sys-                                       sourcesofintroductorycomputerscienceprogrammingprob-
                    tem. The results show that the problems in the suite vary                                    lems. We present each problem’s speciﬁcations in the form
                    in diﬃculty and can be useful for assessing the capabilities                                 of input/output examples, making them suitable to a wide
                    of a program synthesis system.                                                               range of program synthesis techniques, including GP. While
                                                                                                                 the problems are not particularly challenging for skilled hu-
                    Categories and Subject Descriptors                                                           man programmers, they are reasonably challenging for be-
                                                                                                                 ginners and many are arguably too diﬃcult for existing pro-
                    I.2.2 [Artiﬁcial Intelligence]: Automatic Programming—                                       gram synthesis systems, including GP. As textbook prob-
                    Program synthesis                                                                            lems, they are not likely representative of real general pro-
                                                                                                                 gramsynthesis applications, yet they should prove useful for
                    Keywords                                                                                     assessing progress toward this goal.
                    program synthesis; genetic programming; benchmarks                                           2.      BENCHMARK-BASEDCOMPARISONS
                    1.     INTRODUCTION                                                                              We designate the solution of a general program synthe-
                                                                                                                 sis problem as a program that perfectly maps inputs to the
                       Several genetic programming (GP) researchers have high-                                   correct outputs. While one might argue that human-written
                    lighted the need for better benchmark problems to guide re-                                  software is often useful even if it has known bugs, the goal
                    search in the ﬁeld [9, 17, 18]. While benchmarks have been                                   here is to pass all input/output tests. Therefore, we are not
                    proposed, few are for general programming problems (also                                     interested in programs that are only approximately correct,
                    called“traditional”or“algorithmic”programming problems)                                      as might be appropriate in the context of other problems
                    even though this category received the second highest level                                  for which GP is used, such as symbolic regression. We rec-
                    of interest in a recent community survey about the need for                                  ommendmeasuring performance on the problems presented
                    benchmarks [17].                                                                             here primarily in terms of success rates, quantifying how of-
                       Automating human programming has long been a goal of                                      ten a stochastic algorithm ﬁnds a successful program across
                    GP, as articulated for example in Koza’s ﬁrst book [7]. The                                                     1
                                                                                                                 a set of runs . A more thorough argument for assessment
                    purpose of a general program synthesis benchmark is to help                                  in terms of success rates can be found in [3]. Furthermore,
                    researchers assess the ability of a system to automate hu-                                   in order to be considered successful, a program must not
                    manprogramming. Such problems should require a range of                                      only achieve zero error on all of the example data used to
                                                                                                                 train the program (the “training set”), but also on a set of
                    Permission to make digital or hard copies of all or part of this work for personal or        withheld generalization data (the“test set”).
                    classroom use is granted without fee provided that copies are not made or distributed            When using this benchmark suite to compare diﬀerent
                    for proﬁt or commercial advantage and that copies bear this notice and the full cita-
                    tion on the ﬁrst page. Copyrights for components of this work owned by others than           settings within one system, we recommend limiting com-
                    ACMmustbehonored. Abstractingwithcreditispermitted. Tocopyotherwise,orre-                    putation with a budget based on the maximum number of
                    publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission   program evaluations allowed in a run. This ensures that the
                    and/or a fee. Request permissions from permissions@acm.org.
                    GECCO’15,July11-15,2015,Madrid,Spain                                                          1Fordeterministic synthesis algorithms other measures must
                     c                                                                                           be used, such as whether a correct program is found within
                    2015ACM.ISBN978-1-4503-3472-3/15/07...$15.00                                                a set period of time.
                    DOI:http://dx.doi.org/10.1145/2739480.2754769
             methods perform similar computational work. That said, it      these sources in further detail and present our natural lan-
             maynonetheless be diﬃcult to justify ﬁne-grained numerical     guage description of each problem, summarized from the
             comparisons amongdiverse techniques on these problems, as      original source. All problems use functional arguments as
             they may involve qualitatively diﬀerent kinds of costs and     inputs besides one that requires reading input from a ﬁle.
             each may be parameterized in radically diﬀerent ways. In       Some problems require programs to return functional out-
             many cases, the most interesting question to ask vis-a-vis     puts, where others require the program to print results.
             a particular system on a particular problem may just be        4.1   iJava
             whether the system can solve the problem at all, and if so,
             whether it can solve it reasonably reliably. Nevertheless,       iJava is an interactive introductory computer science text-
             we aim here to describe speciﬁcations that will allow for as   book that contains a number of automatically graded pro-
             much cross-system comparability as possible.                   gramming problems [11]. Many of its problems are graded
                                                                            by testing programs against a range of inputs, making them
             3.   PROBLEMSELECTIONCRITERIA                                  easy to convert into benchmark problems.
               In this section we describe the criteria we used when se-      Some sets of problems in iJava meet our criteria but test
             lecting problems for the benchmark suite. Several of our       similar programming techniques; for these sets, we chose one
             criteria overlap with those described in the GP benchmarks     representative problem from the group, ensuring a reason-
             papers [9, 17], such as being varied, relevant, realistically  able distribution of problem requirements. Along with each
             diﬃcult, representation-independent, and precisely deﬁned.     problem name and description, we provide the question or
               This benchmark suite is designed for systems that use ex-    project number associated with the problem in iJava 3.1.
             ample inputs and their corresponding outputs as the speci-        1. Number IO (Q 3.5.1) Given an integer and a ﬂoat,
             ﬁcations for desired programs. In the context of GP, we call        print their sum.
             the input/output pairs test cases for the problem. Thus,
             a problem must be deﬁned on a range of inputs that have           2. Small or Large (Q 4.6.3) Given an integer n, print
             known correct outputs; it cannot simply specify the calcula-        “small”if n < 1000 and“large”if n ≥ 2000 (and noth-
             tion of a single value. For example, a problem that requires        ing if 1000 ≤ n < 2000).
             the program to calculate the number of prime numbers less
             than 1000 would not qualify, since it only has one answer;        3. For Loop Index (Q 4.11.7) Given 3 integer inputs
             but, a similar problem that requires the program to calcu-          start,end, and step, print the integers in the sequence
             late the number of prime numbers less than an input integer
             n would meet this requirement, since we could then provide                            n0 = start
             example inputs for n and their corresponding outputs. This                            n =n      +step
             requirement also ensures that test cases can be generated to                            i    i−1
                                                                                 for each n < end, each on their own line.
             ﬁll the training and test set, as required to test generaliza-                i
             tion of successful programs.                                      4. Compare String Lengths (Q 4.11.13) Given three
               Problems in the suite should present challenges typical of        strings n1, n2, and n3, return true if length(n1) <
             real programming tasks. This criterion leads us to choose           length(n2) < length(n3), and false otherwise.
             problems that call for a range of programming constructs
             and data types. The problems should require a variety of          5. Double Letters (P 4.1) Given a string, print the
             sizes and shapes for solution programs, not just artiﬁcially        string, doubling every letter character, and tripling ev-
             small programs.                                                     ery exclamation point. All other non-alphabetic and
               The benchmarks should not be biased toward a particu-             non-exclamation characters should be printed a single
             lar method of synthesis; it should be possible to attempt to        time each.
             solve them using various GP systems as well as analytic and
             search-based program synthesis systems. Since systems gen-        6. Collatz Numbers (P 4.2) Given an integer, ﬁnd the
             erate programs in a variety of languages, we avoid problems         number of terms in the Collatz (hailstone) sequence
             that require a speciﬁc language feature or non-standard data        starting from that integer.
             type (such as Java objects).
               We take our problems from pre-existing sources of intro-        7. Replace Space with Newline (P 4.3) Given a
             ductory programming problems. From each source, we in-              string input, print the string, replacing spaces with
             clude all problems that meet the criteria described above,          newlines. Also, return the integer count of the non-
             aiming to avoid biasing the selection of problems. We re-           whitespace characters. The input string will not have
             jected problems from other sources that did not meet our cri-       tabs or newlines.
             teria, such as the inductive programming benchmark repos-
                  2                                                            8. String Diﬀerences (P 4.4) Given 2 strings (with-
             itory , other program synthesis and inductive programming
             papers, and programming competitions.                               out whitespace) as input, ﬁnd the indices at which the
                                                                                 strings have diﬀerent characters, stopping at the end
             4.   PROBLEMDESCRIPTIONS                                            of the shorter one. For each such index, print a line
               Weused two sources for problems: iJava [11], an interac-          containing the index as well as the character in each
             tive textbook for introductory computer science, and Intro-         string. For example, if the strings are “dealer” and
             Class [2, 1], a set of problems originally used as benchmarks       “dollars”, the program should print:
             for automatic program repair. Below we describe each of                    1 e o
                                                                                        2 a l
             2http://www.inductive-programming.org/repository.html                      4 e a
                 9. Even Squares (Q 5.4.1) Given an integer n, print             23. Word Stats (P 10.5) Given a ﬁle, print the number
                    all of the positive even perfect squares less than n on          of words containing n characters for n from 1 to the
                    separate lines.                                                  length of the longest word, in the format:
                                                                                            words of length 1: 12
               10. Wallis Pi (P 6.4)) John Wallis gave the following                        words of length 2: 3
                    inﬁnite product that converges to π/4:                                  words of length 3: 0
                           2 × 4 × 4 × 6 × 6 × 8 × 8 × 10 ×...                              words of length 4: 5
                           3    3   5    5   7    7    9    9                               ...
                    Given an integer input n, compute an approximation               At the end of the output, print a line that gives the
                    of this product out to n terms. Results are rounded to           number of sentences and line that gives the average
                    5 decimal places.                                                sentence length using the form:
                                                                                            number of sentences: 4
               11. String Lengths Backwards (Q 7.2.5) Given a vec-                          average sentence length: 7.452423455
                    tor of strings, print the length of each string in the           A word is any string of consecutive non-whitespace
                    vector starting with the last and ending with the ﬁrst.          characters (including sentence terminators). Every ﬁle
                                                                                     will contain at least one sentence terminator (period,
               12. Last Index of Zero (Q 7.7.8) Given a vector of                    exclamation point, or question mark). The average
                    integers, at least one of which is 0, return the index of        sentence length is the number of words in the ﬁle di-
                    the last occurrence of 0 in the vector.                          videdbythenumberofsentenceterminatorcharacters.
               13. Vector Average (Q 7.7.11) Given a vector of ﬂoats,           4.2   IntroClass
                    return the average of those ﬂoats. Results are rounded        The set of 6 problems in the IntroClass dataset [2, 1] was
                    to 4 decimal places.                                        designed for the purpose of benchmarking automatic soft-
               14. Count Odds (Q 7.7.12) Given a vector of integers,            ware defect repair systems. As such, the authors of this
                    return the number of integers that are odd, without         dataset provide a number of buggy programs written by stu-
                    use of a speciﬁc even or odd instruction (but allowing      dents trying to solve each problem, taken from students in
                    instructions such as mod and quotient).                     an introductory computer science class. For the purposes
                                                                                of general program synthesis from scratch, we will use the
               15. Mirror Image (Q 7.7.15) Given two vectors of in-             problems themselves but not the accompanying buggy pro-
                    tegers, return true if one vector is the reverse of the     grams.
                    other, and false otherwise.
                                                                                 24. Checksum Given a string, convert each character in
               16. Super Anagrams (P 7.3) Given strings x and y of                   the string into its integer ASCII value, sum them,
                    lowercase letters, return true if y is a super anagram of        take the sum modulo 64, add the integer value of the
                    x, which is the case if every character in x is in y. To         space character, and then convert that integer back
                    betrue, y may contain extra characters, but must have            into its corresponding character (the checksum charac-
                    at least as many copies of each character as x does.             ter). The program must print Check sum is X, where
               17. Sum of Squares (Q 8.5.4) Given integer n, return                  Xis replaced by the correct checksum character.
                    the sum of squaring each integer in the range [1,n].         25. Digits Given an integer, print that integer’s digits
               18. Vectors Summed (Q 8.7.6) Given two equal-sized                    each on their own line starting with the least signiﬁ-
                    vectors of integers, return a vector of integers that con-       cant digit. A negative integer should have the negative
                    tains the sum of the input vectors at each index.                sign printed before the most signiﬁcant digit.
               19. X-Word Lines (P 8.1) Given an integer X and a                 26. Grade Given 5 integers, the ﬁrst four represent the
                    string that can contain spaces and newlines, print the           lower numeric thresholds for achieving an A, B, C, and
                    string with exactly X words per line. The last line              D, and will be distinct and in descending order. The
                    may have fewer than X words.                                     ﬁfth represents the student’s numeric grade. The pro-
                                                                                     gram must print Student has a X grade., where X
               20. Pig Latin (P 8.2)Givenastringcontaininglowercase                  is A, B, C, D, or F depending on the thresholds and
                    words separated by single spaces, print the string with          the numeric grade.
                    each word translated to pig Latin. Speciﬁcally, if a         27. Median Given 3 integers, print their median.
                    word starts with a vowel, it should have“ay”added to
                    its end; otherwise, the ﬁrst letter is moved to the end      28. Smallest Given 4 integers, print the smallest of them.
                    of the word, followed by“ay”.
                                                                                 29. Syllables Given a string containing symbols, spaces,
               21. Negative To Zero (Q 9.6.8) Given a vector of inte-                digits, and lowercase letters, count the number of oc-
                    gers, return the vector where all negative integers have         currences of vowels (a, e, i, o, u, y) in the string and
                    been replaced by 0.                                              print that number as X in The number of syllables
               22. Scrabble Score (P 10.1) Given a string of visible                 is X.
                    ASCII characters, return the Scrabble score for that        5.   SYNTHESISSPECIFICATIONS
                    string. Each letter has a corresponding value according
                    to normal Scrabble rules, and non-letter characters are       The natural language descriptions of the problems in Sec-
                    worth zero.                                                 tion 4 do not provide all of the information needed to apply
              Table 1: For each problem, the types of the inputs and outputs, and the limits imposed on the inputs. Any
              printed outputs should be printed by the program to standard output. The columns Train and Test indicate
              the recommended sizes of the training set and test set respectively.
                   Name                       Inputs                                                  Outputs            Train    Test
                   Number IO                  integer in [−100,100], ﬂoat in [−100.0,100.0]           printed ﬂoat           25   1000
                   Small Or Large             integer in [−10000,10000]                               printed string       100    1000
                   For Loop Index             integers start and end in [−500,500], step in [1,10]    printed integers     100    1000
                   Compare String Lengths     3 strings of length [0,49]                              boolean              100    1000
                   Double Letters             string of length [0,20]                                 printed string       100    1000
                   Collatz Numbers            integer in [1,10000]                                    integer              200    2000
                   Replace Space with         string of length [0,20]                                 printed string,      100    1000
                   Newline                                                                            integer
                   String Diﬀerences          2 strings of length [0,10]                              printed string       200    2000
                   Even Squares               integer in [1,9999]                                     printed string       100    1000
                   Wallis Pi                  integer in [1,200]                                      ﬂoat                 150      50
                   String Lengths             vector of length [0,50] of strings of length [0,50]     printed string       100    1000
                   Backwards
                   Last Index of Zero         vector of integers of length [1,50] with each integer   integer              150    1000
                                              in [−50,50]
                   Vector Average             vector of ﬂoats of length [1,50] with each ﬂoat in      ﬂoat                 100    1000
                                              [−1000.0,1000.0]
                   Count Odds                 vector of integers of length [0,50] with each integer   integer              200    2000
                                              in [−1000,1000]
                   Mirror Image               2 vectors of integers of length [0,50] with each        boolean              100    1000
                                              integer in [−1000,1000]
                   Super Anagrams             2 strings of length [0,20]                              boolean              200    2000
                   Sum of Squares             integer in [1,100]                                      integer                50     50
                   Vectors Summed             2 vectors of integers of length [0,50] with each        vector of            150    1500
                                              integer in [−1000,1000]                                 integers
                   X-Word Lines               integer in [1,10], string of length [0,100]             printed string       150    2000
                   Pig Latin                  string of length [0,50]                                 printed string       200    1000
                   Negative To Zero           vector of integers of length [0,50] with each integer   vector of            200    2000
                                              in [−1000,1000]                                         integers
                   Scrabble Score             string of length [0,20]                                 integer              200    1000
                   Word Stats                 ﬁle containing [1,100] chars                            printed string       100    1000
                   Checksum                   string of length [0,50]                                 printed string       100    1000
                   Digits                     integer in [−9999999999,9999999999]                     printed integers     100    1000
                   Grade                      5 integers in [0,100]                                   printed string       200    2000
                   Median                     3 integers in [−100,100]                                printed integer      100    1000
                   Smallest                   4 integers in [−100,100]                                printed integer      100    1000
                   Syllables                  string of length [0,20]                                 printed string       100    1000
              program synthesis systems to the problems. Here we pro-           set; again, there are exceptions for problems with limited
              vide the needed additional information, aiming to do so in        input spaces. The method of producing the training and
              a technique-independent and system-independent way.               test cases is system-speciﬁc; we recommend a combination
                Table 1 presents recommendations regarding training and         of hand-chosen edge cases with randomly generated cases,
              test data for each problem. While these are merely guide-         and will describe our method in more detail in Section 6.
              lines, and there may be good reasons to diverge from them           Thequestion of which instructions to make available for a
              whenusingdiﬀerenttechniquesorsystems,adheringtothese              synthesis system to use for each problem is a complex one.
              guidelines will clarify comparisons among techniques and          It is important to not cherry pick a small set of instructions
              systems. The table describes the data types of the inputs         that are known to be suﬃcient to solve a problem; such a
              andoutputsandgivesreasonable ranges for program inputs.           selection may be diﬃcult for a real-world problem, where it
                Wealso provide recommendations for numbers of cases to          might not be clear which instructions will be useful. On the
              use in the training and test sets in Table 1. For most prob-      other hand, using all available instructions for every prob-
              lems, we recommend between 100 and 200 training cases,            lem expands the search space and may make problems more
              depending on the diﬃculty of the problem as well as the di-       diﬃcult than necessary. We recommend a compromise be-
              mensionality of the input space. A few problems use fewer,        tween these approaches in which one ﬁrst determines which
              either because they have limited input spaces or are sim-         data types are likely to be useful for solving the problem and
              ple enough to solve with fewer cases. We usually recom-           then uses all instructions that operate on those data types.
              mend using a test set ten times as large as the training          For example, an instruction that compares the equality of
              two integers and returns a boolean would be included if the      X-Word Lines problem when using Levenshtein distance as
              problemcouldpotentiallymakeuseofintegersandbooleans.             the only ﬁtness function, but found solutions when adding
              By specifying only the data type requirements for a prob-        additional ﬁtness functions for the number of newline char-
              lem, we can limit the number of instructions without cherry      acters and summed errors of diﬀerences in number of words
              picking.                                                         compared. When using multiple ﬁtness values for a single
                                                                               training case, we treat each ﬁtness value separately when the
              6.   SYSTEM-SPECIFCPARAMETERS                                    parent selection method requires it; in tournament selection,
                                                                               we simply sum all ﬁtness values.
                WhereasSection5gavetechnique-independentrecommen-                As discussed in Section 5, we have chosen to specify the
              dations for specifying the benchmark problems for a syn-         data types relevant to each problem, and then include all
              thesis system, this section will give more detail about the      instructions that use those data types in each problem’s in-
              system-speciﬁc parameters and decisions that must be made        struction set. Table 2 presents the Push data types we chose
              in order to implement these problems in a given program          for each problem. The “exec” column signiﬁes instructions
              synthesis system. Here we will focus on our implementation       that use Push’s exec stack, which typically perform control
              in the PushGP genetic programming system, but we empha-          ﬂow manipulations such as conditionals, iteration, and sub-
              size that this is just one possible approach and one possible    functions deﬁned through tagging [15]. The “print” column
              implementation, and that the problems here could be used         includes instructions that print data to standard output, and
              in any system that meets the requirements in Section 3.          “ﬁle input”includes a small set of ﬁle reading instructions.
                PushGP evolves programs in Push, a stack-based pro-              Table 2 also gives the terminals used for each problem,
              gramming language designed speciﬁcally for GP [16]. The          whichencompassconstantsandephemeralrandomconstants
              reference implementation of our problems in PushGP can           (ERCs). ERCs allow for the creation of random constants
                                   3
              be found on GitHub . In the rest of this section, we will        in randomly generated code during initialization and muta-
              describe some of the major decisions necessary for imple-        tion. We used problem-speciﬁc ERC ranges, which can be
              menting these benchmark problems in this environment. As         found in the technical report [4].
              we do not have space to discuss every parameter and imple-         WekeepmostofourPushGPsystemparametersconstant
              mentation choice, the technical report accompanying this         across all problems, with speciﬁc details in [4]. The only sig-
              paper supplements the information presented here [4].            niﬁcant parameters that we vary per problem are the max-
                Whengenerating training and testing data, we use a com-        imum program size, the maximum number of instruction
              bination of hand-picked edge cases that remain constant          evaluations that a program may use per execution, and the
              across runs and randomly generated inputs that vary across       maximum number of generations per run. We used a maxi-
              runs. For each problem, we specify one or more “data do-         mumof 300 generations for every problem besides Number
              mains” [3], which consist of either a set of hard-coded in-      IO, Median, and Smallest, for which we used 200 genera-
              puts or a random input generator, as well as the number of       tions. Maximum program sizes varied from 200 to 1000 in-
              training and test cases that should come from each domain.       structions depending on anticipated problem diﬃculty. We
              Details on using data domains can be found in [3], and our       limited instruction executions to approximately 2 to 5 times
              technical report gives our choices for data domains for each     the maximum program size, though for some problems that
              problem [4].                                                     require many loops we increased this limit. By specifying
                When using this benchmark suite with GP, we not only           the maximum generations, the population size (1000 for all
              need the input/output cases, but also a method of measur-        of our runs), and the size of the training set (see Table 1),
              ing how well a particular program performs on each case—         we also specify the program evaluation budget, which is the
              the ﬁtness function. Many of the problems in this suite print    product of those values. In our implementation, this budget
              results to standard output, and we generally treat these out-    falls between 5 and 60 million program evaluations per run
              puts as strings and use Levenshtein distance (a measure of       for every problem.
              string edit distance) as the ﬁtness function. Other prob-
              lems produce numeric outputs, either returned or printed;        7.   EXPERIMENTALRESULTS
              for these problems we use absolute error for ﬁtness, pars-
              ing printed numbers when necessary and possible. Some              Whereastherelevance of a benchmark suite is determined
              problems produce boolean values, or are best measured by         by how well its problems reﬂect potential applications of the
              a simple binary right or wrong; here, we use a ﬁtness of 0       test systems, its utility is based on how well it diﬀerentiates
              for right and 1 for wrong. Finally, some problems require        between diﬀerent approaches. We aim to include problems
              problem-tailored ﬁtness functions, such as vector edit dis-      with a large range of diﬃculties, from those that can be
              tance or string formatting requirements. We give the details     solved reliably to those that extend beyond the abilities of
              of each ﬁtness function in [4].                                  current program synthesis systems. More importantly, we
                For some problems we found it appropriate to use multi-        hope to include problems that are solved more often with
              ple ﬁtness functions per test case. For example, the Replace     some systems or settings than others, allowing us to com-
              Space With Newline problem requires both a printed string        pare their performances on these problems. In this section
              and a returned integer. For problems like this, we produce       we present a simple experiment showing the utility of the
              multiple ﬁtness values for a single case. Additionally, we       benchmark suite presented here. This experiment compares
              ﬁnd that PushGP performs better on some problems when            three parent selection algorithms: tournament selection, im-
              we use more than one ﬁtness value per case, even where not       plicit ﬁtness sharing, and lexicase selection.
              strictly necessary. For example, we found no solutions to the      Implicit ﬁtness sharing (IFS) is a modiﬁcation of tourna-
                                                                               ment selection designed to encourage diversity preservation
              3http://thelmuth.github.io/GECCO 2015 Benchmarks                 in the population [10]. IFS selection greatly rewards indi-
              Materials/                                                       viduals for solving training cases that are solved by a small
             Table 2: Instructions and data types used in our PushGP implementation of each problem. The column“#
             Instructions” reports the number of instructions, terminals, and ERCs used for each problem. The middle
             columns show which data types were used for each problem. For example, the Number IO problem used all
             instructions relevant to integers, ﬂoats, and printing. The last column lists the constants and ERCs used for
             the problem. Here, char constants are represented in the Clojure style, starting with a backslash, and strings
             are surrounded by double quotation marks. The“Problems”row simply counts how many problems use each
             data type. The“Instructions”row shows the number of Push instructions that primarily use each data type;
             some use multiple types but are only counted once.
                                                                        rs       s
                                                                        e
                                       ns                               g    ats ng
                                       io                               te       tri
                                       t                                in   ﬂo  s
                                                                        f    f   f
                                       truc     r         an            o    o   o         ut
                                       s        e         e             or   or  or   t    np
                                       In  c    g         l   r    ng   t        t         i
                                           e    te   at   o             c    ct  c    in   e
                                           x    n         o   ha   tri  e    e   e
                Problem                #   e    i    ﬂo   b   c    s    v    v   v    pr   ﬁl Terminals (besides inputs)
                Number IO            50        x    x                                x        integer ERC, ﬂoat ERC
                Small Or Large      103   x    x        x         x                  x       “small”,“large”, integer ERC
                For Loop Index       74   x    x        x                            x
                Compare String       98   x    x        x         x                           boolean ERC
                Lengths
                Double Letters      132   x    x        x    x    x                  x        \!
                Collatz Numbers     102   x    x    x   x                                     0, 1, integer ERC
                Replace Space       135   x    x        x    x    x                  x        \space, \newline, string ERC, char
                with Newline                                                                  ERC
                String Diﬀerences   135   x    x        x    x    x                  x        \space, \newline, integer ERC
                Even Squares         72   x    x        x                            x
                Wallis Pi           103   x    x    x   x                                     2 integer ERCs, 2 ﬂoat ERCs
                String Lengths      134   x    x        x         x             x    x        integer ERC
                Backwards
                Last Index of Zero  101   x    x        x              x                      0
                Vector Average       88   x    x    x                      x
                Count Odds          104   x    x        x              x                      0, 1, 2, integer ERC
                Mirror Image        102   x    x        x              x                      boolean ERC
                Super Anagrams      129   x    x        x    x    x                           boolean ERC, char ERC, integer ERC
                Sum of Squares       71   x    x        x                                     0, 1, integer ERC
                Vectors Summed       68   x    x                       x                      [], integer ERC
                X-Word Lines        134   x    x        x    x    x                  x        \newline, \space
                Pig Latin           141   x    x        x    x    x                  x       “ay”, \space, \a, \e, \i, \o, \u, “aeiou”,
                                                                                              string ERC, char ERC
                Negative To Zero    102   x    x        x              x                      0, []
                Scrabble Score      158   x    x        x    x    x    x                      vector containing Scrabble values
                                                                                              (indexed by ASCII values)
                Word Stats          281   x    x    x   x    x    x    x   x    x    x    x   \., \?, \!, \space, \tab, \newline, [],
                                                                                             “words of length ”,“: ”,“number of
                                                                                              sentences: ”, “average sentence
                                                                                              length: ”, integer ERC
                Checksum            136   x    x        x    x    x                  x       “Check sum is ”, \space, 64, integer
                                                                                              ERC, char ERC
                Digits              133   x    x        x    x    x                  x        \newline, integer ERC [-10, 10]
                Grade               112   x    x        x         x                  x       “Student has a ”,“ grade.”,“A”,“B”,
                                                                                             “C”,“D”,“F”, integer ERC
                Median               75   x    x        x                            x        integer ERC
                Smallest             76   x    x        x                            x        integer ERC
                Syllables           141   x    x        x    x    x                  x       “The number of syllables is ”,“aeiouy”,
                                                                                              \a, \e, \i, \o, \u, \y, char ERC, string
                                                                                              ERC
                Problems                  28  29    5   26   11  15    7   2    2   17    1
                Instructions              28  28   31   19   17  39   31   31   31  10    4
              Table 3: Number of successful runs out of 100 for                   than either tournament selection or IFS. Additionally, there
              each setting, where“Tourn”is size 7 tournament se-                  were 8 problems where lexicase selection achieved a signiﬁ-
              lection, “IFS” is implicit ﬁtness sharing with size 7               cantly higher number of successful runs than the other two,
              tournaments, and “Lex” is lexicase selection. For                   where IFS showed signiﬁcant improvement on just one prob-
              each problem, underline indicates signiﬁcant im-                    lem and tournament selection none. These results strongly
              provement over the other two selection methods at                   indicate the utility of lexicase selection for general program
              p < 0.05 based on a pairwise chi-square test with                   synthesis problems.
              Holm correction [13], or a pairwise Fisher’s exact                    The data in Table 3 only reﬂect solutions that generalize
              test with Holm correction if any number of successes                by achieving zero error on the unseen test set. Some prob-
              is below 5 [12].      The “Size” column indicates the               lems seem to lend themselves to generalization more than
              smallest size of any simpliﬁed solution program.                    others; for example, PushGP using lexicase selection found
                                                                                  14 programs with zero error on the training set for the Su-
                Problem                         Tourn    IFS   Lex    Size        per Anagrams problem, none of which generalized to the
                Number IO                           68    72     98      5        test set. For lexicase selection, ﬁve problems resulted in 20
                Small Or Large                       3     3      5     27        or more runs that passed the training set that did not gener-
                For Loop Index                       0     0      1     21        alize (Small Or Large, Compare String Lengths, Last Index
                Compare String Lengths               3     6      7     11        of Zero, Negative To Zero, and Median), and ﬁve problems
                Double Letters                       0     0      6     20        had between 10 and 20 runs that did not generalize (String
                Collatz Numbers                      0     0      0               Lengths Backwards, Mirror Image, Digits, Smallest, and Su-
                Replace Space with Newline           8    16     51      9        per Anagrams). These 10 problems show an important area
                String Diﬀerences                    0     0      0               for future study: how to evolve programs that generalize to
                Even Squares                         0     0      2     37        unseendataforgeneralprogramsynthesisproblems. Among
                Wallis Pi                            0     0      0               these problems are the only ﬁve in the suite that give a cor-
                String Lengths Backwards             7    10     66      9        rect/incorrect binary error as ﬁtness in our implementation:
                Last Index of Zero                   8     4     21      5        Compare String Lengths, Mirror Image, Super Anagrams,
                Vector Average                      14    13     16      7        Median, and Smallest. This shows the diﬃculty of evolving
                Count Odds                           0     0      8      7        general programs based entirely on correctness of output,
                Mirror Image                        46    64     78      4        and suggests that these problems might be better tackled if
                Super Anagrams                       0     0      0               they can be transformed into problems with more informa-
                Sum of Squares                       2     0      6      7        tive error functions.
                Vectors Summed                       0     0      1     11          Withregards to the problems themselves, this experiment
                X-Word Lines                         0     0      8     15        illustrates the ability of this benchmark suite to provide use-
                Pig Latin                            0     0      0               ful comparisons between multiple systems or parameter set-
                Negative To Zero                    10     8     45      8        tings. By looking at the number of problems solved by each
                Scrabble Score                       0     0      2     14        technique, and how often each technique showed signiﬁcant
                Word Stats                           0     0      0               improvements over the others, we can clearly see that lex-
                Checksum                             0     0      0               icase selection increases PushGP’s ability to solve general
                Digits                               0     1      7     20        program synthesis problems compared to tournament selec-
                Grade                                0     0      4     52        tion and IFS. The main goal of a benchmark suite is to sup-
                Median                               7    43     45     10        port this type of experiment. Additionally, some problems
                Smallest                            75    98     81      8        in the suite were solved frequently by each system, whereas
                Syllables                            1     7     18     14        others were solved infrequently or not at all. This range
                                                                                  of diﬃculties permits the suite to be useful for a variety of
                Problems Solved                     13    13     22               experiments, and allows it to remain relevant as program
                                                                                  synthesis systems improve.
                                                                                    Of the seven problems on which PushGP found no gener-
              fraction of the population, and gives less reward for solving       alizing solution, most are not surprising in that they involve
              cases that are solved by more of the population. Most of the        extensive use of multiple programming constructs, the link-
              problems here produce non-binary error values, for which we         ing of many distinct steps, or a deceptive ﬁtness space where
              use the non-binary adaptation of IFS found in [8]. As re-           ﬁtness improvements do not lead toward perfect programs.
              quired by this method, we normalize error values to [0,1]           Wehave written solutions to each of the unsolved problems
              by dividing each error by a maximum allowed error value,            by hand to ensure that each problem is solvable within the
              which diﬀers per problem based on the ﬁtness function.              constraints we put on the system and instruction set.
                 Lexicase selection [5], unlike tournament selection and            The last column in Table 3 gives the size (in instructions)
              IFS, does not base selection on a single ﬁtness value. In-          of the smallest simpliﬁed solution program. Here, we’ve used
              stead, it uses a random ordering of the training set to select      post-run simpliﬁcation to automatically reduce the sizes of
              individuals that perform as well as possible on a subset of         solution programs without changing their semantics on the
              the cases even if they exhibit poor performance on other            training data [14]. While this hill-climbing simpliﬁcation is
              cases.  Lexicase selection has been shown to improve the            not guaranteed to ﬁnd the smallest semantically equivalent
              performance of a GP system on a variety of problems [5, 3].         program, it reliably removes excess code, leaving the core
                 Table 3 gives the results of our parent selection experi-        functionality of the program [14]. The simpliﬁed program
              ment. Overthe29problems, PushGPwithlexicaseselection                sizes present a reasonable proxy for the smallest solution pro-
              produced at least one successful run on nine more problems          gram for each problem (using our instruction sets). While
              someproblemscanbesolvedwithprogramscontainingfewer                    IEEE Transactions on Evolutionary Computation,
              than10instructions, none would likely be found using brute-           2014.
              force search over our instruction sets within the number of       [6] M. Hofmann, E. Kitzelmann, and U. Schmid. A
              programevaluations allowed here. Searching over size 5 pro-           unifying framework for analysis and evaluation of
              grams using the Number IO instruction set would require               inductive programming systems. In Proceedings of the
              evaluating over 7 billion programs, much more than the 5              Second Conference on Artiﬁcial General Intelligence,
              million we used in our GP runs. Other problems have small-            pages 55–60. Citeseer, 2009.
              est known solutions of over 20 instructions using instruction     [7] J. R. Koza. Genetic Programming: On the
              sets with more than 100 instructions, to our knowledge be-            Programming of Computers by Means of Natural
              yond the reach of all other program synthesis systems.                Selection. MIT Press, Cambridge, MA, USA, 1992.
                                                                                [8] K. Krawiec and M. Nawrocki. Implicit ﬁtness sharing
              8.   CONCLUSIONS                                                      for evolutionary synthesis of license plate detectors. In
                Wehavepresented a suite of 29 general program synthesis             Applications of Evolutionary Computing,
              benchmark problems, systematically selected from sources              EvoApplications 2012, volume 7835 of Lecture Notes
              of introductory computer science programming problems.                in Computer Science, pages 376–386, Vienna, Austria,
              Through exposition and experimentation, we have demon-                3-5 Apr. 2013. Springer.
              strated the potential utility of this suite to assess the ca-     [9] J. McDermott, D. R. White, S. Luke, L. Manzoni,
              pabilities of program synthesis systems.   We expect that             M. Castelli, L. Vanneschi, W. Jaskowski, K. Krawiec,
              the application of this suite can help advance multiple ﬁelds         R. Harper, K. De Jong, and U.-M. O’Reilly. Genetic
              of automatic program synthesis, including genetic program-            programming needs better benchmarks. In GECCO
              ming, that have long employed simple benchmark problems               ’12: Proceedings of the Genetic and evolutionary
              not attuned to potential real-world applications.                     computation conference, pages 791–798, Philadelphia,
                                                                                    Pennsylvania, USA, 7-11 July 2012. ACM.
              9.   ACKNOWLEDGMENTS                                             [10] R. I. McKay. Fitness sharing in genetic programming.
                                                                                    In Proceedings of the Genetic and Evolutionary
                Thanks to the members of the Hampshire College Com-                 Computation Conference (GECCO-2000), pages
              putational Intelligence Lab, Nicholas Freitag McPhee, Yuriy           435–442, Las Vegas, Nevada, USA, 10-12 July 2000.
              Brun, and David Jensen for discussions that helped to im-             Morgan Kaufmann.
              prove the work described in this paper, to Josiah Erikson        [11] R. Moll. iJava. http://ijava.cs.umass.edu/index.html,
              for systems support, and to Hampshire College for support             2014. Edition 3.1. Online; accessed September 2015.
              for the Hampshire College Institute for Computational In-        [12] M. Nakazawa. fmsb: Functions for medical statistics
              telligence. This material is based upon work supported by             book with some demographic data, 2014. R package.
              the National Science Foundation under Grants No. 1017817,        [13] R Core Team. R: A Language and Environment for
              1129139, and 1331283. Any opinions, ﬁndings, and conclu-              Statistical Computing. R Foundation for Statistical
              sions or recommendations expressed in this publication are            Computing, Vienna, Austria, 2012. ISBN
              those of the authors and do not necessarily reﬂect the views          3-900051-07-0.
              of the National Science Foundation.                              [14] L. Spector and T. Helmuth. Eﬀective simpliﬁcation of
              10.    REFERENCES                                                     evolved Push programs using a simple, stochastic
                                                                                    hill-climber. In GECCO Companion ’14, pages
               [1] Y. Brun, E. Barr, M. Xiao, C. Le Goues, and                      147–148, Vancouver, BC, Canada, 12-16 July 2014.
                   P. Devanbu. Evolution vs. intelligent design in                  ACM.
                   program patching. Technical Report                          [15] L. Spector, B. Martin, K. Harrington, and
                   https://escholarship.org/uc/item/3z8926ks, UC Davis:             T. Helmuth. Tag-based modules in genetic
                   College of Engineering, 2013.                                    programming. In GECCO ’11: Proceedings of the 13th
               [2] C. L. Goues, N. Holtschulte, E. K. Smith, Y. Brun,               annual conference on Genetic and evolutionary
                   P. Devanbu, S. Forrest, and W. Weimer. The                       computation, pages 1419–1426, Dublin, Ireland, 12-16
                   ManyBugs and IntroClass benchmarks for automated                 July 2011. ACM.
                   program repair. IEEE Transactions on Software               [16] L. Spector and A. Robinson. Genetic programming
                   Engineering. Under Review.                                       and autoconstructive evolution with the push
               [3] T. Helmuth and L. Spector. Word count as a                       programming language. Genetic Programming and
                   traditional programming benchmark problem for                    Evolvable Machines, 3(1):7–40, Mar. 2002.
                   genetic programming. In GECCO ’14: Proceedings of           [17] D. R. White, J. Mcdermott, M. Castelli, L. Manzoni,
                   the 2014 conference on Genetic and evolutionary                  B. W. Goldman, G. Kronberger, W. Ja´skowski, U.-M.
                   computation, pages 919–926, Vancouver, BC, Canada,               O’Reilly, and S. Luke. Better GP benchmarks:
                   12-16 July 2014. ACM.                                            community survey results and proposals. Genetic
               [4] T. Helmuth and L. Spector. Detailed problem                      Programming and Evolvable Machines, 14(1):3–29,
                   descriptions for general program synthesis benchmark             Mar. 2013.
                   suite. Technical Report UM-CS-2015-006, School of           [18] J. Woodward, S. Martin, and J. Swan. Benchmarks
                   Computer Science, University of Massachusetts                    that matter for genetic programming. In GECCO
                   Amherst, 2015.                                                   2014 4th workshop on evolutionary computation for
               [5] T. Helmuth, L. Spector, and J. Matheson. Solving                 the automated design of algorithms, pages 1397–1404,
                   uncompromising problems with lexicase selection.                 Vancouver, BC, Canada, 12-16 July 2014. ACM.
