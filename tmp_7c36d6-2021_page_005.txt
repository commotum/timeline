                          Table 1: The comparison between our restricted C domain and existing programming by example tasks.
                                                  Control ﬂow  Variables  Arithmetics  Nohelper functions
                              Restricted C (Ours)     3            3          3                3
                                   Karel [9]          3            −          −                −
                                DeepCoder[6]          −            3          3                −
                                 FlashFill [19]       −            −          −                −
                        4   Restricted C Program Synthesis Domain
                        In this section, we discuss our restricted C program synthesis domain, and our operation predictor
                        design for improving the numerical reasoning ability of program synthesis models.
                        4.1  DataGeneration
                        Collecting large-scale high-quality datasets for program synthesis requires a lot of human efforts, and
                        weaimtoreducethemanualworkfordatasetconstruction.
                        Ourdatagenerator is built upon Csmith [54], a random C code generation tool originally designed for
                        ﬁnding bugs in compilers. Following the common practice of generating input-output pairs, for each
                        program, we randomly sample 5 numerical lists as the program inputs, and execute the program to
                        obtain the corresponding output lists. This is similar to existing works on PBE problems that sample
                        programs based on a probabilistic context-free grammar, randomly generate valid inputs for the
                        programs and obtain the outputs [40, 15, 6]. This creates inﬁnite samples for synthesizing programs
                        in domain-speciﬁc languages. While the programs sampled in this way differ from human-written
                        code, Sec. 3.4 shows that they can be converted to be more concise and human-like.
                        The subset of language features used. Our generated program has variable declaration, variable
                        assignment, and expressions with addition or subtraction operations. The programs also have non-
                        sequential statements, including If statements, For loops, Continue and Break statements. Except
                        for the input argument which is a list, all variables declared are integers, and all program statements
                        are integer manipulation. Each expression has at most 2 mathematical operations, and chaining the
                        full C program could perform multi-step numerical calculation (e.g., p0 = p0 - p1 + p2; p0 =
                        p0 - 1;). Looping statements other than For (i.e., While or Do-While loops) are not supported.
                        Note that we only constrain the ﬁnal program length (≤ 256 tokens) and the program can have nested
                        for-loops and complicated if-conditions.
                        Post-processing. Weperformafewpost-processingstepstoobtainourﬁnalprogramsfromprograms
                        generated by Csmith (see Fig. 1 for an example). We resample different components of the program,
                        so that (1) each constant numerical value lies in [−4,4], (2) mathematical operators only contain
                        addition and subtraction, and (3) upper/lower limits of For loops are positive and within the length
                        of the list. Programs are discarded if they are trivial (e.g., constant or identity mappings), or the
                        input-output examples include values out of the range [−4,4].
                        Final dataset. We reweight the program distribution so that at least half of them include For loops.
                        Ourfull dataset includes 500K samples in the training set, 1K samples in the validation set, and 1K
                        samples in the test set. As shown in Fig. 1, the randomly sampled program may contain redundant
                        statements, which can be easily avoided by human programmers. We compare our restricted C
                        domain to prior datasets of programming by example in Table 1.
                        4.2  ProgramDecodingwiththeOperationPredictor
                        For program decoder, predicting the next program token pt is non-trivial, especially when mathe-
                        matical reasoning is required [43, 29]. To improve the program synthesis performance for domains
                        involving numerical calculation, such as our restricted C domain, we design an associative memory
                        structure named operation predictor (Fig. 2(d)), based on the following intuition: given the input
                        I = 2 and output O = 4, human would infer that “O = I + 2” might be the desired operation and
                        write down the code accordingly. To materialize such an intuition, we create a pre-computed table that
                        covers all possible integer addition and subtraction operations for valid input and output list values.
                        Wedefer the details of the model architecture to Appendix B.2. The program decoding process
                        remains similar to the one described in Sec. 3, and we highlight the key differences as follows.
                                                                   5
