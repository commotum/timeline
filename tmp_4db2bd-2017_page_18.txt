                    Published as a conference paper at ICLR 2017
                        • TAKE :: int -> [int] -> int
                          lambda n, xs: xs[:n]
                          Given an integer n and array xs, returns the array truncated after the n-th element. (If the
                          length of xs was no larger than n in the ﬁrst place, it is returned without modiﬁcation.)
                        • DROP :: int -> [int] -> int
                          lambda n, xs: xs[n:]
                          Given an integer n and array xs, returns the array with the ﬁrst n elements dropped. (If the
                          length of xs was no larger than n in the ﬁrst place, an empty array is returned.)
                        • ACCESS :: int -> [int] -> int
                          lambda n, xs: xs[n] if n>=0 and len(xs)>n else Null
                          Given an integer n and array xs, returns the (n+1)-st element of xs. (If the length of xs
                          wasless than or equal to n, the value NULL is returned instead.)
                        • MINIMUM :: [int] -> int
                          lambda xs: min(xs) if len(xs)>0 else Null
                          Given an array, returns its minimum (or NULL if the array is empty).
                        • MAXIMUM :: [int] -> int
                          lambda xs: max(xs) if len(xs)>0 else Null
                          Given an array, returns its maximum (or NULL if the array is empty).
                        • REVERSE :: [int] -> [int]
                          lambda xs: list(reversed(xs))
                          Given an array, returns its elements in reversed order.
                        • SORT :: [int] -> [int]
                          lambda xs: sorted(xs)
                          Given an array, return its elements in non-decreasing order.
                        • SUM :: [int] -> int
                          lambda xs: sum(xs)
                          Given an array, returns the sum of its elements. (The sum of an empty array is 0.)
                    Higher-order functions:
                        • MAP :: (int -> int) -> [int] -> [int]
                          lambda f, xs: [f(x) for x in xs]
                          Given a lambda function f mapping from integers to integers, and an array xs, returns the
                          array resulting from applying f to each element of xs.
                        • FILTER :: (int -> bool) -> [int] -> [int]
                          lambda f, xs: [x for x in xs if f(x)]
                          Given a predicate f mapping from integers to truth values, and an array xs, returns the
                          elements of xs satisfying the predicate in their original order.
                        • COUNT :: (int -> bool) -> [int] -> int
                          lambda f, xs: len([x for x in xs if f(x)])
                          Given a predicate f mapping from integers to truth values, and an array xs, returns the
                          numberofelements in xs satisfying the predicate.
                        • ZIPWITH :: (int -> int -> int) -> [int] -> [int] -> [int]
                          lambda f, xs, ys: [f(x, y) for (x, y) in zip(xs, ys)]
                          Given a lambda function f mapping integer pairs to integers, and two arrays xs and ys,
                          returns the array resulting from applying f to corresponding elements of xs and ys. The
                          length of the returned array is the minimum of the lengths of xs and ys.
                        • SCANL1 :: (int -> int -> int) -> [int] -> [int]
                          Given a lambda function f mapping integer pairs to integers, and an array xs, returns an
                          array ys of the same length as xs and with its content deﬁned by the recurrence ys[0] =
                          xs[0],ys[n] = f(ys[n-1], xs[n])forn≥1.
                    TheINT→INTlambdas(+1),(-1),( 2),(/2),( (-1)),(  2),( 3),(/3),( 4),(/4)
                                                *         *       **    *         *
                    providedbyourDSLmapintegerstointegersinaself-explanatorymanner.TheINT→BOOLlambdas
                    (>0),(<0),(%2==0),(%2==1)respectivelytestpositivity, negativity, evenness and oddness of
                                                      18
