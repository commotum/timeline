             Expression to Veriﬁer                        Learned Test Input          Production              Component
                                                                                      E→ITE(B,E,E) Inputs:                    (i : B)(i ,i : E)
                        x                                   hx = 0,y = 1i                                                       1       2  3
                        y                                   hx = 1,y = 0i                                     Output:         (o : E)
                                                                                                              Spec:           o = ITE(i ,i ,i )
                        1                                   hx = 0,y = 0i                                                               1  2   3
                                                                                      B→E≤E                   Inputs:         (i ,i : E)
                      x+y                                   hx = 1,y = 1i                                                       1  2
                ITE(x ≤ y,y,x)                                     –                                          Output:         (o : B)
                                                                                                              Spec:           o = i ≤ i
                                                                                                                                   1     2
                                          TABLE I                                                              TABLE II
                           ARUNOFTHEENUMERATIVEALGORITHM                                            COMPONENTSFROMPRODUCTIONS
             D. Enumerative Learning                                               E. Constraint-based Learning
                The enumerative learning algorithm [8] adopts a dynamic              The symbolic CEGIS approach uses a constraint solver
             programming based search strategy that systematically enu-            both for searching for a candidate expression that works
             merates concepts (expressions) in increasing order of complex-        for a set of concrete input examples (concept learning) and
             ity. Various complexity metrics can be assigned to concepts,          veriﬁcation of validity of an expression for all possible inputs.
             the simplest being the expression size. The algorithm needs           We use component based synthesis of loop-free programs
             to store all enumerated expressions, because expressions of           as described by Jha et al. [5], [7]. Each production in the
             a given size are composed to form larger expressions in the           grammar corresponds to a component in a library. A loop-
             spirit of dynamic programming. The algorithm maintains a              free program comprising these components corresponds to an
             set of concrete test cases, obtained from the counterexamples         expression from the grammar. Some sample components for
             returned by the veriﬁcation oracle. These concrete test cases         the illustrative example are shown in Table II along with their
             are used to reduce the number of expressions stored at each           corresponding productions.
             step by the dynamic programming algorithm.                              The input/output ports of these components are typed and
                We demonstrate the working of the algorithm on the illus-          only well-typed programs correspond to well-formed expres-
             trative example. Table I shows the expressions submitted to           sions from the grammar. To ensure this, Jha et al.’s encod-
             the veriﬁcation oracle (an SMT solver) during the execution of        ing [5] is extended with typing constraints. We illustrate the
             the algorithm and the values for which the expression produces        working of this algorithm on the maximum of two integers
             incorrect results. Initially, the algorithm submits the expression    example. The library of allowed components is instantiated
             x to the veriﬁer. The veriﬁer returns a counterexample hx =           to contain one instance each of ITE and all comparison
             0,y = 1i, corresponding to the case where the expression              operators(≤,≥,=) and the concrete example set is initialized
             x violates the speciﬁcation. The expression enumeration is            with hx = 0,y = 0i. The ﬁrst candidate loop-free program
             started from scratch every time a counterexample is added. All        synthesized corresponds to the expression x. This candidate
             enumerated expressions are checked for conformance with the           is submitted to the veriﬁcation oracle which returns with
             accumulated (counter)examples before making a potentially-            hx = −1,y = 0i as a counterexample. This counterexample is
             expensive query to the veriﬁer. In addition, suppose the              added to the concrete example set and the learning algorithm
             algorithm enumerates two expressions e and e0 which evaluate          is queried again. The SMT formula for learning a candidate
             to the same value on the examples obtained so far, then only          expression is solved in an incremental fashion; i.e., the con-
             one of e or e0 needs to be considered for the purpose of              straint for every new example is added to the list of constraints
             constructing larger expressions.                                      from the previous examples. The steps of the algorithm on the
                Proceeding with the illustrative example, the algorithm then       illustrative example are shown in Table III.
             submits the expression y and the constant 1 to the veriﬁer. The         If synthesis fails for a component library, we add one in-
             veriﬁer returns the values hx = 1,y = 0i and hx = 0,y =               stance of every operator to the library and restart the algorithm
             0i, respectively, as counterexamples to these expressions. The        with the new library. We also tried a modiﬁcation to the
             algorithm then submits the expression x+y to the veriﬁer. The         original algorithm [5], in which, instead of searching for a
             veriﬁer returns the values hx = 1,y = 1i as a counterexample.         loop-free program that utilizes all components from the given
             The algorithm then submits the expression shown in the last           library at once, we search for programs of increasing length
             row of Table I to the veriﬁer. The veriﬁer certiﬁes it to be          such that every line can still select any component from the
             correct and the algorithm terminates.                                 library. The program length is increased in an exponential
                The optimization of pruning based on concrete counterex-
             amples helps in two ways. First, it reduces the number of             Iteration   Loop-free program        Learned counter-example
             invocations of the veriﬁcation oracle. In the example we have            1        o :=x                         hx = −1,y = 0i
             described, the correct expression was examined after only                          1
             four calls to the SMT solver, although about 200 expressions             2        o1 := x ≤ x
                                                                                               o :=ITE(o , y, x)             hx = 0,y = −1i
             were enumerated by the algorithm. Second, it reduces the                           2           1
             search space for candidate expressions signiﬁcantly (see [8]             3        o1 := y ≥ x
                                                                                               o :=ITE(o , y, x)                     –
             for details). For instance, in the run of the algorithm on                         2           1
             the example, although the algorithm enumerated about 200                                          TABLE III
             expressions, only about 80 expressions were stored.                            ARUNOFTHECONSTRAINTLEARNINGALGORITHM
