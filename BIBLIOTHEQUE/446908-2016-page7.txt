                                                                     JConcat(f ,Â·Â·Â· ,f )K      = Concat(Jf K ,Â·Â·Â· ,Jf K )
                     String expr e    := Concat(f ,Â·Â·Â· ,f )                     1       n Ïƒ                    1 Ïƒ        n Ïƒ
                                                     1       n          JConstantStr(s)K       = s
                 Substring expr f     := ConstantStr(s)                                     Ïƒ
                                                                       JSubStr(v ,p ,p )K      = s[Jp K ..Jp K ],where s = Ïƒ(v )
                                       |   SubStr(v ,p ,p )                       i  l  r   Ïƒ           l s   r s                  i
                                                     i  l  r            JConstantPos(k)K       = k>0?k:len(s)+k
                                                                                            s
                        Position p    :=    (Ï„,k,Dir)                       J(Ï„,k,Start)K      = k>0?(Ï„ s)[k],â†’:(Ï„ s)[len(s)+k],â†’
                                                                                           s
                                       |   ConstantPos(k)                     J(Ï„,k,End)K      = k>0?(Ï„ s)[k]â†-:(Ï„ s)[len(s)+k]â†-
                    Direction Dir     :=    Start | End                                    s
                                       (a)                                                                    (b)
                    Figure 10:      The (a) syntax and (b) semantics of the string transformation language L of BlinkFill.
                                                                                                                                 s
                                                                        s  f Ëœ
                                                               JDag(Î·Ëœ,Î· ,Î· ,Î¾,W)K    = {Concat(f ,Â·Â·Â· ,fn)|f âˆˆ JW(Î¾ )K
                                                                                                     1          i        i
                                    s  f                                                    Î¾  Î¾ corresponds to path between Î·s and Î·f}
                                          Ëœ                                                  1    n
                  eËœ  := Dag(Î·Ëœ,Î· ,Î· ,Î¾,W)
                                                                               0                                              0
                                                          JSubStr(v ,{pËœ } ,{pËœ } )K  = {SubStr(v ,p ,p )|p âˆˆ JpËœ K,p âˆˆ JpËœ K}
                   Ëœ                             0                  i   j j    k k                   i  l  r  l     j   r     k
                  f   :=    SubStr(v ,{pËœ } ,{pËœ } )
                                      i   j j    k k               JConstantStr(s)K   = {ConstantStr(s)}
                       |   ConstantStr(s)                         JConstantPos(k)K    = {ConstantPos(k)}
                  pËœ  := ConstantPos(k)                                          e                           e
                                                                                JVK   = {(Ï„,k,Start)|v âˆˆ V,âˆƒv âˆˆ V : (v,v ) âˆˆ E,(Ï„,k) âˆˆ L((v,v ))}
                                                                                                                  i          i                    i
                            e                                                                                e
                       |    V                                                              âˆª{(Ï„,k,End)|v âˆˆ V,âˆƒv âˆˆ V : (v ,v) âˆˆ E,(Ï„,k) âˆˆ L((v ,v))}
                                                                                                                  i       i                    i
                                  (a)                                                                   (b)
               Figure 11: The (a) syntax and (b) semantics of the Dag data structure used to succinctly represent a large
               number of L expressions.
                               s
                                                                                            LearnProgram({(v1,Â·Â·Â· ,v1),Â·Â·Â· ,(vn,Â·Â·Â· ,vn)},
               outgoing edge (v,vi) âˆˆ E, the resulting set consists of a to-                                    1       k         1        k
               ken match expression (Ï„,k,Start), where (Ï„,k) âˆˆ L((v,v )).                             {((v1,Â·Â·Â· ,v1),o1),Â·Â·Â· ,((vm,Â·Â·Â· ,vm),om)})
                                                                            i                             1       k    s          1        k     s
               Similarly, it also consists of token matches (Ï„,k,End) for                1 G:=GenInpDataGraph({(v1,..,v1),Â·Â·Â· ,(vn,..,vn)})
                                                                                                                          1     k          1     k
                         e                                                               2 Dag d := GenerateDag((v1,Â·Â·Â· ,v1s),o1,G)
               each v âˆˆ V, (vi,v) âˆˆ E, (Ï„,k) âˆˆ L((vi,v)).                                                                 1       k     s
                  The Dag data structure that succinctly represents the set              3 for i = 2 to m:
                                                                                         4      Dag dâ€™ := GenerateDag((vi,Â·Â·Â· ,vis),oi,G)
               of all L   expressions consistent with the input-output ex-                                                     1       k     s
                        s
               ample "Mumbai, India" â†’ "India" is shown in Figure 12,                    5      d := Intersect(d,dâ€™)
               where the set of nodes Î·Ëœ = {0,1,2,3,4,5}, the start node                 6 return TopRankExpr(d)
                s                       f           Ëœ
               Î· =0,theï¬nalnodeÎ· =5,andÎ¾ ={(i,j)|0â‰¤i<j â‰¤5}.                           Figure 13: The LearnProgram procedure for learning
               Intuitively, the Dag nodes correspond to the indices of the
               output string "India" and an edge from node i to node j                an expression that conforms to a set of m examples.
               represents the set of substring expressions that can generate
               the substring between indices i and j. The edge mapping
                                                                                      put rows {(v1,Â·Â·Â· ,v1),Â·Â·Â· ,(vn,Â·Â·Â· ,vn)} is shown in Fig-
               function W is shown for one of the edges (0,5) (correspond-                           1       k          1       k
               ing to the sub-string "India"), where W((0,5)) consists of             ure 13. The algorithm ï¬rst constructs the InputDataGraph
               a set of substring expressions and a constant string expres-           G corresponding to the set of n input rows. It then con-
               sion. The set of position expressions for the left index pËœ            structs the Dag d denoting the set of all consistent Ls ex-
                                                                               l
               consists of a constant position expression and 4 nodes from            pressions that conform to the ï¬rst input-output example.
               the InputDataGraph in Figure 14 :{v2,v7,v15,v25}.            The       Next, it iterates over other input-output examples and in-
               node labeling function for these nodes contains the tuple              tersects the corresponding dags to compute the resulting dag
               (id,9), where id is the unique identiï¬er for the input string          d that consists of Ls expressions that are consistent with all
               "Mumbai, India"and9istheleftindexofsub-string"India"                   mexamples. Finally, the algorithm uses a ranking function
               in the input string. Similarly, the set of position expressions        to ï¬nd the best expression path in the dag and returns it as
               for the right index also consists of 4 input graph nodes and           the learnt program. We now describe each of the individual
               a constant position expression.                                        algorithms GenSubStrExpr, GenerateDag, and TopRankExpr.
               7.    SYNTHESISALGORITHM                                               7.1     Learning Substring Expressions
                                                                                         The GenSubStrExpr algorithm, shown in Figure 15, takes
                  The LearnProgram algorithm for learning an L expres-                as input an input string s, two integer positions l and r
                                                                      s
               sion that conforms to a given set of m input-output exam-              corresponding to the left and right indices of the desired
               ples {((v1,Â·Â·Â· ,v1),o1),Â·Â·Â· ,((vm,Â·Â·Â· ,vm),om)} and n in-              substring, and the InputDataGraph G, and returns the set of
                         1       k    s          1        k     s
                                                                                 822
