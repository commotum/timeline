Memory, Learning, and Skill =» 331

the chunker creating conditions (for the to-be-built chunk) for
everything Soar became aware of in resolving the impasse and in
particular for the response datum (GID), input from the outside. if
Soar could avoid attending, so to speak, while it moved the datum
over to be the result, then it could build chunks that would perform
perfectly well. This does lead to a rather bizarre view—that the
memory is built up of items that Soar is guaranteed not to know
about! Of course, Soar will find out about them eventually, when
they arrive in working memory at some latter time, but still the
whole setup seems to fly in the face of a system remembering what
it focuses attention upon.

Despite the seeming oddity, we actually explored this path, in
part because such schemes have actually been tried, though not to
solve this difficulty. PSG, an early production system (Newell,
1973b), had a primitive action Notice(<pattern>) that searched
working memory for an item satisfying <pattern> and brought it
within the attentional scope of other productions. This mechanism,
which seems quite reasonable, has exactly the Property of being
blind to the item (since it occurs on the right-hand side of a produc-
tion); and an addition of Notice to the action tepertoire of Soar
productions would solve the data-chunking problem. It would have
other effects as well, such as destroying the uniform principle that
all actions simply put elements in the working memory and making
it problematical how chunking would create productions containing
Natice.§

The other main path is to stay with the architecture. If Soar is the
right architecture, then there must be a solution for the data-
chunking problem somewhere in the current behavioral repertoire
of Soar. We should listen to the architecture to hear what it says.
This is the path we followed. Not only is there a way to chunk data
in the current version of Soar; data chunking has some interesting
properties.

Figure 6-10 gives the essential elements of the solution. The key
idea is to separate generating an object to be recalled from testing it.
The desired object here is GID, We want the process that generates
GID not to know that it is the response that is to be made—not to
be the process that tests for the item. Thus, to achieve the required

6. Another possibility is partiat matching to evoke the chunk for G/D, even though
the GiD-condition in the chunk faits to match.

