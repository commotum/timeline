182 = Unified Theories of Cognition

entirely. That could lead it just to try out the operators at the top
(which means it has the search-control knowledge of what to do if
no task-specific knowledge is available).

Operators with no-change impasses are analogous to procedure
calls, with selecting the Operator being analogous to calling the
procedure, searching in the problem space being analogous to ex-
ecuting the code body, and the context stack being analogous to the
Procedure stack. This analogy immediately highlights two opera-
tions that are missing in Soar: communicating down to the operat-
ing context of the procedure body the input parameters; and com-
municating back to the initial (cailing) context the results of the
computation. For standard Programming languages these communi-
cations are highly formalized operations with corresponding disci-
plines (such as call by value or call by name). By contrast, in Soar
there are no communication operations of this sort. All processing
occurs in one large open context, as demonstrated by the fact that
decisions can be made at any level in the context. Often additional
knowledge must be added to a state to instantiate an operator, and
this is functionally equivalent to specifying parameters. Equally,
knowledge is simply retrieved from the higher levels when it is
needed. Likewise, there is no packaging of results in some standard
form. Anything that is linked to a higher level in the goal context
Stack is a result at that level, because it can be accessed at that level
and will not disappear along with the lower level when the impasse
is resolved,

4.1.7. Example Trace of Performance

To make all this concrete, Figure 4-10 gives a trace of Soar as it
works on the simple block-stacking task of Figure 4-2. The initial
situation is that block B and block C are on the table and block A is
on top of block &. The task is to get to the desired state where A
is on top of B is on top of Câ€”it is desired to stack up all the blocks
in a specific order. Soar is provided initially with some knowledge.
It must know about the blocks-world problem space, what its Oper-
ators are and how to perform them. It must also know how to react
to various impasses, that, for example, upon a tie impasse the selec-
tion problem space should be used to attempt its resolution. It also
has the knowledge about the selection space itself. [t knows some
simple heuristics: not to Propose an operator that immediately un-
does what has just been done; and not to Propose moving some part

