Memory, Learning, and Skill # 355

Functionally, working memory must be a short-term memory. It
is used to hold the coded knowledge that is to be processed for the
current task. It is necessary to replace that knowledge when the
current task changes. That replacement can be achieved in many
ways, by moving the data, by moving the processes, or by changing
the access path. If new data must come to play the role that was
played by the old data, this necessarily defines a change of memory.
Time bounds can be put on such memory changes by the functional
requirements. First, the shift must occur at the rate of simple-
operator times, because it is operators that demand new operands.
This would put the lower times at | sec, except that we know
from Chapter 5 that speeded simple operators can take less than
100 ms. Second, the memory must last long enough for problems
to be solved, to wit, problem-space residence times. That must be
at least 10 sec, because that is the order of the first level at
which goal solution occurs. There is no apparent upper limit to how
long it might take to work in a problem space to resolve an impasse,
given the ability to generate impasses within impasses, but we do
know that a system can work satisfactorily through just having
memory enough for the minimal-time processing. We know the
lower limit from our experience with bottom-up chunking in Soar,
in comparison with all-goals chunking. Given many learning occa-
sions, bottom-up chunking leads to the same total set of chunks.

To meet the functional requirements, working memory changes
with each new production cycle, which is very rapid. Â° Residence
times of working-memory elements are tied directly to the duration
of problem-space activity. As long as a problem space remains
active (by occurring somewhere in the goal context), then the work-
ing-memory elements associated with it remain available. Thus, the
requirement for problem-space residency is satisfied for all problem
spaces, however many subspaces intervene, Working memory for
cognition has no continued functional existence outside these lim-
its, however, since elements that are no longer linked to the goal
stack become unavailable. Furthermore, problem spaces them-
selves have no existence independent of the impasses they are

9. Actually, behind this rapid change is another memory, instantiation memory,
which holds the bindings of variables in the productions just long enough to discover a
match and communicate the binding information to the actions of the production that
deposit new working-memory elements in working memory. This memory must be cre-
ated and destroyed within each production cycle.

