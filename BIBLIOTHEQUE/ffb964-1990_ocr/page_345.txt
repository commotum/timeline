Memory, Learning, and Skill » 333

can go on fora long time, with many backtrackings, or the path can
zip directly to the solution. All that is required is that a desired state
is attained. Efficiency is a question of search control, not of
whether the solution is acceptable.

This separation has an important consequence for chunking.
Working-memory elements that enter into search control (by evok-
ing search-control productions) do not enter into the chunks. To
use them would be to tie the solution to the exact path that was
chosen, whereas what is known when a chunk is built is that a
solution has been found legitimately, and the particular path is not
important. This means that any search control whatever can be
used to guide the operators to the solution.

There are several ways to exploit the possibility of search control
to create an efficient generation of GID. For instance, the answer
might be guessed. Starting from the stimulus BAJ, one might guess
RAJ, then RAG, GAG, GIG, and finally GID. That may seem no
better than chance, but some principles are involved—the
Operators transform the stimulus word (the nonsense syllable) to
similar words by changing one letter. The first time through might
be an unintelligent search, but then search-contral chunks would be
built that draw on BAJ as the search-control context to select the
way. Other sorts of search might be possible, such as generating a
sequence from the nonsense syllable to a word to its referent or
embedding the syllable in a self-generated semantic image. The
details are not important here, only that a variety of schemes might
be possible for shaping the generation. Which one would actually
be useful would depend on the task context and the person.

A second possibility for exploiting search control is to construct
the response object (G/D) using the input response object itself as
search control (Figure 6-11). For instance, since GID is composed
of the three letters G, Z, and D, then GID can be constructed by an
Operator that produces G for the first letter, then an operator that
produces / for the second, and then an operator that produces D for
the third. The problem of producing G for the first letter can be
solved by proposing operators for all the letters and using the letter
in the first place of the input response (to wit, G) to select the right
Operator (to wit, the one that produces G). It takes only three
independent selections to construct GID, as opposed to the sequen-
tial generation of all triples. If this seems to be a basic lesson in how
to beat the combinatorics in Al by the application of heuristics, that

