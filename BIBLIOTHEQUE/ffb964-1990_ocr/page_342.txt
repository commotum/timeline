330 © Unified Theories of Cognition

term memory by ongoing experience and created new chunks con-
tinuously. Making such a system really work, however, drove us to
link chunks with goals. Rosenbloom constructed a successor sys-
tem, Xaps3 (Rosenbloom, 1983), to have the goal-caching charac-
ter, from which we went to the scheme in Soar (Laird, Rosen-
bloom, & Newell, 1984). The major evolution was the step from the
fairly complicated three-production scheme to the one production
scheme described in Chapter 4. The second achievement, whose
essential details are harder to articulate, was to integrate chunking
into the existing Soar system (which had not been designed with
learning in mind) so that chunking could work anywhere.

Through ail the history of Xaps2 and Xaps3 to Soar, we never
asked whether the chunking would apply to data, such as learning
to recall verbal items. There never has been any question that
chunking provides effective learning—we’ ve seen lots of examples
with Soar. It seemed obvious that the procedural chunking schemes
would work in the situations that gave birth to the idea. Only when
we finally got around to getting Soar to perform the classical tasks
of paired associates and serial recall did the problem of data chunk-
ing emerge. Thus, we have another example of the architecture
having its say—in this case, telling us of difficulties of which we had
been quite unaware,

What is to be done about the data-chunking problem? Two radi-
cally different paths could have been taken—switch or stay. One
path (switch) would be to change the architecture, by, for example,
adding a separate declarative memory. This step would abandon
the uniform-memory principle—all memory is stored by produc-
tions—and replace it with a dual-memory system. This arrange-
ment appears in Anderson's Act* (though not in reaction to the
data-chunking problem, of course, but as a fundamental principle).
Ina dual-memory system the two kinds of memory, declarative and
procedural, are kept completely distinct and have different pro-
cesses. Permanent storage into the declarative memory (which is
what is at issue here} occurs autonomously. That is (to continue
with Act*), there is a small constant probability that any entry of an
item into working memory will also become a permanent part of
declarative memory.

A second way of changing the architecture is to add a mechanism
to manipulate the data in working memory without Soar becoming
aware of the data. The data-chunking difficulty can be localized to

