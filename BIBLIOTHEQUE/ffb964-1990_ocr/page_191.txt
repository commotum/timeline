178 « Unified Theories of Cognition

subgoal stack, thus rendering the ongoing subgoal processing below
it irrelevant.

The removal of goal contexts causes the disappearance of
working-memory elements associated exclusively with the dis-
carded contexts. Only working-memory elements connected to ele-
ments of the goal context stack can be accessed. To be accessible
an element must be part of the context (an established goal, prob-
fem space, state, or operator) or occur as the value of some attri-
bute of an object that is accessible. (An element may be connected
to the goal context stack in several different ways.) Productions
conform to this connectivity constraint by matching only along
chains of working-memory elements that start with objects in the
context stack. The production in Figure 4-4 satisfies this constraint.
Its first condition matches a goal element; the next two elements for
a problem space and a state are linked to the first condition (the
identifiers <p> and <s> occur in both conditions); the last two
elements for a block and an input are linked to the state (the
identifiers <b> and <i> occur in both conditions). Thus, the re-
moval of objects from the goal context stack cuts other objects out
of ever being accessed, and so they disappear from working-
memory. This is the other side of the coin of the fact that all the
production system ever does is add knowledge to working memory;
removal takes place automatically.*

It is a key feature of Soar that the goal context stack is generated
entirely internally and that impasses are the sole source of sub-
goals. Such a scheme can generate all the sorts of subgoals that we
have become familiar with in Al systems. Tie impasses produce
subgoals to choose between operators or between states. They also
produce subgoals to choose between problem spaces, to choose, in
other words, how to formulate or represent a task. These latter
tarely show up in AI systems, and indeed so far they arise onty in
quite limited ways in Soar. No-change impasses on operators can
produce subgoals that implement the operator. They can also pro-
duce what are called precondition subgoals or operator subgoaling,
namely, the goal to find a state where the operator does apply. They
can also produce subgoals to specialize or instantiate an operator. A
moment's reflection will show that alt three of these common situa-
tions—not immediately knowing the result of applying an operator,

5. In the Soar soflware system, these inaccessible elements are garbage collected.

