                                                                                             algebraic manipulations are not covered. DD (ref. 17) handles algebraic 
             Methods
                                                                                             deductions by expressing them under a few limited deduction rules, 
             Geometry representation                                                         therefore, it is unable to express more complex manipulations, leaving 
             General-purpose formal languages such as Lean31 still require a large           arithmetic inferences not covered. The most general treatment so far 
             amount of groundwork to describe most IMO geometry problems                     is a process similar that in ref. 34 for angle-only theorem discovery and 
                                                                                                                          19
             at present. We do not directly address this challenge as it requires            implemented in GeoLogic  for both angle and ratios. We expanded this 
             deep expertise and substantial research outside the scope of                    formulation to cover all reasoning about angles, ratios and distances 
             theorem-proving methodologies. To sidestep this barrier, we instead             between points and also arithmetic reasoning with geometric constants 
                                                                       10       17
             adopted a more specialized language used in GEX , JGEX , MMP/                   such as ‘pi’ or ‘1:2’. Concrete examples of algebraic reasoning are given 
                        13                19
             Geometer  and GeoLogic , a line of work that aims to provide a logi-            in Extended Data Table 2.
             cal and graphical environment for synthetic geometry theorems with                 On a high level, we first convert the input linear equations to a matrix 
                                                                                                                                                                       M×N
             human-like non-degeneracy and topological assumptions. Examples                 of their coefficients. In particular, we create a coefficient matrix A ∈ R    
             of this language are shown in Fig. 1d,f. Owing to its narrow formulation,       in which N is the number of variables and M is the number of input equa-
             75% of all IMO geometry problems can be adapted to this representa-             tions. In geometry, any equality is of the form a − b = c − d ⇔ a − b − c 
             tion. In this type of geometry environment, each proof step is logically        + d = 0. For example, the angle equality ∠ABC = ∠XYZ is represented 
             and numerically verified and can also be evaluated by a human reader            as s(AB) − s(BC) = s(XY) − s(YZ), in which s(AB) is the angle between 
             as if it is written by IMO contestants, thanks to the highly natural gram-      AB and the x-direction, modulo pi. Similarly, ratios AB:CD = EF:GH are 
             mar of the language. To cover more expressive algebraic and arithmetic          represented as log(AB) − log(CD) = log(EF) − log(GH), in which log(AB) 
             reasoning, we also add integers, fractions and geometric constants to           is the log of the length of segment AB. For distances, each variable is a 
             the vocabulary of this language. We do not push further for a complete          (point, line) pair, representing a specific point on a specific line.
             solution to geometry representation as it is a separate and extremely              Because all equalities are of the form ‘a − b − c + d = 0’, we populate 
             challenging research topic that demands substantial investment from             the row for each equality with values +1, −1, −1, +1 at columns corre-
             the mathematical formalization community.                                       sponding to variables a, b, c and d. Running Gaussian elimination on 
                                                                                             A returns a new matrix with leading 1s at each of the columns, essen-
             Sampling consistent theorem premises                                            tially representing each variable as a unique linear combination of all 
             We developed a constructive diagram builder language similar to that            remaining variables. As an example, suppose we have ‘a − b = b − c’, 
             used by JGEX17 to construct one object in the premise at a time, instead        ‘d − c = a − d’ and ‘b − c = c − e’ as input equalities, running the Gaussian 
             of freely sampling many premises that involve several objects, there-           elimination process (denoted GE in the following equation) returns 
             fore avoiding the generation of a self-contradicting set of premises.           the following result:
             An exhaustive list of construction actions is shown in Extended Data 
                                                                                                                                               
             Table 1. These actions include constructions to create new points that            abcdeabcde
                                                                                                                    GE                            ad=1.5 −0.5e
             are related to others in a certain way, that is, collinear, incentre/excentre     1−2100 100−1.50.5 
                                                                                                                    →                          ⇒        bd=
             etc., as well as constructions that take a number as its parameter, for         −1    0−120 010−10
                                                                                                                                                   cd=0.5 +0.5e
                                                                                              01−2 01 001−0.5−0.5
             example, “construct point X such that given a number α, ∠ABX = α”. One                                                             
             can extend this list with more sophisticated actions to describe a more 
             expressive set of geometric scenarios, improving both the synthetic                From this result, we can deterministically and exhaustively deduce 
             data diversity and the test-set coverage. A more general and expressive         all new equalities by checking if x  = x  or x  − x  = x  − x  or x  − x  = x  − x , 
                                                                                                                                 1   2    1   2   2    3    1   2   3    4
             diagram builder language can be found in ref. 32. We make use of a              in which {x , x , x , x } is any 4-permutation of all variables. In the above 
                                                                                                         1  2  3  4
             simpler language that is sufficient to describe problems in IMO-AG-30           Gaussian Elimination, for example, AR deduced that b = d from the 
             and can work well with the symbolic engine DD.                                  three input equalities. To handle geometric constants such as ‘0.5 pi’ 
                                                                                             or ‘5:12’, we included ‘pi’ and ‘1’ as default variables to all coefficient  
             The symbolic deduction engine                                                   matrices.
             The core functionality of the engine is deducing new true statements 
             given the theorem premises. Deduction can be performed by means                 Deductive database implementation
             of geometric rules such as ‘If X then Y’, in which X and Y are sets of geo-     Unlike the original implementation of DD, we use a graph data structure 
             metric statements such as ‘A, B, C are collinear’. We use the method of         to capture the symmetries of geometry, rather than using strings of 
             structured DD10,17 for this purpose as it can find the deduction closure        canonical forms. With a graph data structure, we captured not only 
             in just seconds on standard non-accelerator hardware. To further                the symmetrical permutations of function arguments but also the 
             enhance deduction, we also built into AlphaGeometry the ability to              transitivity of equality, collinearity and concyclicity. This graph data 
             perform deduction through AR. AR enable proof steps that perform                structure bakes into itself some deduction rules explicitly stated in the 
             angle/ratio/distance chasing. Detailed examples of AR are shown in              geometric rule list used in DD. These deduction rules from the original 
             Extended Data Table 2. Such proof steps are ubiquitous in geometry              list are therefore not used anywhere in exploration but implicitly used 
             proofs, yet not covered by geometric rules. We expand the Gaussian              and explicitly spelled out on-demand when the final proof is serialized  
                                                                19
             elimination process implemented in GeoLogic  to find the deduction              into text.
             closure for all possible linear operators in just seconds. Our symbolic 
             deduction engine is an intricate integration of DD and AR, which we             Traceback to find minimal proofs. Each deduction step needs to 
             apply alternately to expand the joint closure of known true state-              be coupled with a traceback algorithm, which returns the minimal 
             ments until expansion halts. This process typically finishes within a           set of immediate ancestor statements that is necessary to deduce 
             few seconds to at most a few minutes on standard non-accelerator                the conclusion statement of the step. This is the core building block 
             hardware.                                                                       for extracting proof graphs and minimal premises described in the 
                                                                                             main text. A minimal-premise-extraction algorithm is necessary to 
             Algebraic reasoning                                                             avoid superfluous auxiliary constructions that contribute to the 
             There has not been a complete treatment for algebraic deduction                 proof through unnecessary transitivity. For example, ‘a = b’ and ‘b = c’ 
             in the literature of geometry theorem proving. For example, in                  might not be necessary if ‘a = c’ can be obtained directly through other  
                         12
             iGeoTutor , Z3 (ref. 33) is used to handle arithmetic inferences but            reasoning chains.
