Memory, Learning, and Skill = 335
(es

Task: recognize a compound item {ab c{d ej]
Study trial: given item, become familiar
Test trial: given item, say if familiar
Recognize by internal name (“name *n6*)
Study trial: try to recognize (self-posed task)
Recognition problem space
* Operator: recognize-next-element
Fails if subiter is not recognized; get an impasse
Subgoal—Learn to recognize subitem
+ Assign a name (now recognize item)
+ Chunk is created to assign name. ig item is recognized
Test trial: given an item [ab ¢ [d ej]
if chunk fires, name is assigned and item is recognized
If chunk fails to fire, item is not recognized

Figure 6-12. Soar solution to recognition of data.

Third, we must build a way to use cues (from BAJ) to modulate that
generator to obtain only the learned item associated with the cues.

Figure 6-12 shows building the recognition test. This is a simple
recognition task in which some item, such as (a b ¢ (d e)), is pre-
sented. We use an example that has some hierarchical structure, in
contrast to (BAY, GID). On a study trial Soar is presented an item
and is to learn it. On a test trial Soar is presented an item and is
supposed to indicate whether the item has been presented earlier,
There are many study and test trials with a population of data items,
so that appropriate distractors can be presented as well as items
actually presented on earlier trials. Recognition means that Soar
has developed an internal name and is able to Present the name as
an indicator of the item’s prior presentation. This name (*n6*, for
example) was generated internally, not given to Soar as an exter-
nally presented associate to be recalled—that would change the
task from recognition to recall,

On the study trial, Soar must evoke a self-imposed task. If there
is no task, there is no learning, because there is no chunking. The
self-imposed task is to try to recognize the item—that is, to go
through the task that will be formed on the test trial. Soar goes into
a recognition problem space, which has a single operator, recog-
nize-next-element. It first asks whether the item already has an
internal name, in which case it knows it has seen it before. If the
item does not have a name, then the operator starts attending to
each component of the data item, asking if it recognizes the item

co
