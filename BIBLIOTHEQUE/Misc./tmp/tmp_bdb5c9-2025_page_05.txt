                       Preprint.
                       Figure 3: Open-Ended (OE) vs. Program Synthesis (PS) Concept Examples. An example of
                       concepts from puzzle 9af7a82c abstracted into each concept format. OE defers to the model, while
                       PSimposesstructure to encourage abstraction/modularity. Higher order behavior is demonstrated
                       with the “sort objects” concept taking a Callable parameter that specifies specific variations.
                       format of “under situation X, do action Y”, the only formatting constraint we impose is having
                       distinct situation (X) and suggestion (Y) fields. This separation is designed for abstraction
                       (disentangles the core idea from the original context) and modular reuse (situation explicitly
                       describes the conditions where this idea can be reused).
                       ProgramSynthesis (PS) Formulation.  In early iterations of automatic concept summarization
                       from solution traces, we observed outputs to occasionally be overly specific. Consider Figure 3’s
                       OEexamplethatbundlesideas of counting, drawing columns, and sorting into a single entry. This
                       overspecification inherits the same limitations as instance-level concepts: friction when matching a
                       composite idea to new scenarios and redundancy from composite ideas sharing components.
                       Wedesignedamorestructured alternative to the OE format to address these issues and more strongly
                       enforce the ideals of abstraction and modularity. In particular, we took inspiration from software
                       engineering and functional programming, which respectively have existing solutions in modular
                       design for code reuse and higher-level functions for composition. From this analogy, our Program
                       Synthesis (PS) format frames concepts as types, structures, and routines. The primary feature
                       is that each of these concepts is parameterized. Parameterization allows similar concepts to be
                       represented compactly with variations abstracted into parameters. Moreover, type annotations for
                       inputs (parameters) and outputs (return types) encourage modularity and composition: the typed
                       interfaces suggest what ideas fit together and how. Finally, by allowing parameters to be routines
                       themselves (introducing higher-order functions), we encourage further generalization by enabling
                       abstraction over specialized logic and routines rather than just values. Higher-level patterns can be
                       recognized across instances and stored with routine arguments defining the different lower-level logic.
                       Asubtle benefit of this more structured formulation is that memory representation can be easily
                       compressed by omitting certain fields (see subsection A.1 for a complete list of PS concept fields).
                       3.3  MEMORYWRITE: CONCEPT ABSTRACTION
                       Memory’sprimarypurposeistopersistdiscoveriesandreflectionsfrompriorexperiences. Converting
                       experiences to memory updates is then the most crucial operation for achieving persistence.
                       OEAbstraction. Abstracting suggestions from a solution trace is straightforward–simply query
                       a model to reflect on the solution trace and summarize specific general ideas that may be reused
                       for future puzzles. To synthesize specific conditions or situational cues to pair with suggestions,
                       ideally, we can directly refer to the original problem-solving process as a series of deductions that
                                                                5
