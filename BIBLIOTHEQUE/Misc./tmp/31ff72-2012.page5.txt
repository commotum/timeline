                                                                                             eÀú      :=        (Œ∑Àú, Œ∑t, Progs)                                             t                                               Àú Àú                       t
                                                                                               t                                                                  [[(Œ∑Àú, Œ∑ , Progs)]]           = {e |e ‚àà[[f]],f ‚àà Progs[Œ∑ ]}
                                                                                                                                                                                                           t      t
                                                                                                                                                    Àú
                          Expression et                :=       vi                                             where Progs : Œ∑Àú ‚Üí 2f                                                 [[v ]]     = {v }
                                                                                                                                                                                         i                 i
                                                         |      Select(C,T,b) Àú                                                                                                   Àú                                                             Àú
                                                                                              f      :=        v | Select(C,T,B)                       [[Select(C,T,{b } )]]                    = {Select(C,T,b) | b ‚àà [[b ]]}
                                                                                                                 i                                                                  i i                                                           i
                                                                                                                 Àú                                                 [[pÀú  ‚àß...‚àßpÀú ]]             = {p ‚àß...‚àßp |p ‚àà[[pÀú ]]}
                                                                                             B := {b}                                                                 1                 n                  1                 n       j         j
                          Boolean Cond b                   :=        p ‚àß...‚àßp                                      i i
                                                                       1                 n
                                                                                              Àú                                                                               [[C = s]]         = {C=s}
                                                                                               b     :=        pÀú   ‚àß...‚àßpÀú
                                  Predicate p              :=        C=s                                         1                 n
                                                                                                                                                                              [[C = Œ∑]]         = {C=e |e ‚àà[[Progs[Œ∑]]]}
                                                             |       C=e                      pÀú     :=        C=s|C=Œ∑                                                                                              t      t
                                                                               t
                                                                                                       |       C={s,Œ∑}                                                [[C = {s,Œ∑}]]             = [[C =s]]‚à™[[C = Œ∑]]
                                                        (a)                                                           (b)                                                                            (c)
                        Figure 3: (a) The syntax of lookup transformation language L , (b) and (c) describe the syntax and semantics
                                                                                                                                                       t
                        of data structure D for succinctly representing a set of expressions from language L .
                                                                t                                                                                                                                      t
                                                                                                                                              (of depth at most steps), each of which evaluates to string
                                Ì†µÌºÇ                 Ì†µÌºÇ                 Ì†µÌºÇ                 Ì†µÌºÇ            ‚Ä¶.              Ì†µÌºÇ                     val(Œ∑) on the input state œÉ. The key idea of the loop at
                                                      2                  3
                                                                                            4
                                   1                                                                                      Ì†µÌ±ö                  Line 7 is to perform an iterative forward reachability anal-
                                                                                                                                              ysis of the string values that can be generated in a single
                                                                                                                                              step (i.e., using a single Select expression) from the string
                         Figure 4: The reachability graph of nodes in Ex. 3.                                                                  values computed in previous step, with the base case being
                                                                                                                                              the values of the input string variables.
                                                                                                                                                  Each iteration of the loop at Line 7 results in considera-
                        makes use of the set of nodes {Œ∑1,...,Œ∑m} to succinctly rep-                                                          tion of expressions whose depth is one larger than the set of
                                           m
                        resent Œò(2 ) transformations in O(m) space.                                                                           expressions considered in the previous step. The depth of
                            Exploiting CNF form of boolean conditions: The                                                                    the expressions in language L can be as much as the total
                                                                                                                                                                                                   t
                        second key aspect of our representation is exploiting the                                                             number of entries in all of the relational tables combined.
                        CNF form of boolean conditions to succinctly represent a                                                              Since we have not observed any intended transformation
                                         Àú
                        huge set b of conditionals. Consider a table T with n + 1                                                             that requires self-joins, we limit the depth consideration to
                        columns C1,...,Cn+1, where the Ô¨Årst n columns consti-                                                                 a parameter k whose value we set to be equal to the number
                        tute a primary key of the table and the table contains an                                                             of relational tables present in the spreadsheet. One might
                        entry (s ,s ,...,s ,t).                       Consider the input-output exam-                                         be tempted to use the predicate (s ‚àà Œ∑Àú ‚à® Œ∑Àú                                            = Œ∑Àú) as a
                                       1     2            n                                                                                                                                                                     Old
                        ple (s ,s ,...,s ) ‚Üí t with s                                 = s = ¬∑¬∑¬∑ = s                               .           termination condition for the loop. However, this has two
                                   1     2            m                           1          2                       max(m,n)
                        The number of transformations that are consistent with the                                                            issues. The Ô¨Årst issue is that it may happen co-incidentally
                        given input-output example are (m + 1)n because for in-                                                               that the output string s is computable by a transformation
                        dexing into each column Ci of the table, we have m + 1                                                                of depth smaller than the depth of the intended transforma-
                        choices namely constant s and the input string variables                                                              tion on a given example, and in that case we would fail to
                                                                        1
                        v1,...,vm. This huge set of transformations can be repre-                                                             discover the correct transformation. The other major issue
                        sented succinctly in O(n+m) space using our data structure                                                            is that it might also happen that the intended transforma-
                        as ({Œ∑1,Œ∑2},Œ∑2,Progs), where Progs[Œ∑1] = {v1,...,vm}, and                                                             tion does not belong to the language L , in which case the
                                                                                                                                                                                                                     t
                                                                                               n
                                                                              Àú       Àú        V                                              search would fail, but only after consideration of all expres-
                        Progs[Œ∑ ] = {Select(C                           , T,b)}, b =               (C ={s ,Œ∑ }).
                                      2                           n+1                                   i          1    1                     sions whose depth is as large as the total number of entries
                                                                                              i=1
                                                                                                                                              in all relational tables combined together.
                             Theorem 1                  (Properties of data structure Dt).                                                        The generalized boolean condition B is computed to be
                        (a) The number of transformations in L that are consistent                                                            the set of all boolean conditions that uniquely identify row r
                                                                                                t
                        with a given example may be exponential in the number of                                                              in table T (Line 10). It considers the set of candidate keys of
                        reachable entries and number of columns in a candidate key.                                                           table T and for each column C0 in a candidate key it learns
                        (b) However, the data structure D can represent these po-                                                                                                                0               0             ‚àí1           0
                                                                                       t                                                      the generalized predicate: C = {T[C ,r],val                                           [T[C ,r]]}.
                        tentially exponential number of transformations in polyno-                                                                During the reachability computation, a node Œ∑ can be
                        mial size in number of reachable entries, number of candi-                                                            reached through multiple paths and therefore the set of ex-
                        date keys and number of columns in a candidate key.                                                                   pressions associated with the node (Progs[Œ∑]) needs to be
                                                                                                                                              updated accordingly. When a node is revisited, the algo-
                        Proof of (a) follows from the two examples discussed above,                                                           rithm computes the Select expression with updated set of
                        while proof of (b) follows from Theorem 2(a).                                                                         boolean conditions B and adds it to the set (Line 15).
                                                                                                                                                  WenowbrieÔ¨Çy describe how the GenerateStr procedure
                        4.3         Synthesis Algorithm for L                                                                                                                                                                       t
                                                                                               t                                              computes the set of expressions for each node in Exam-
                        Procedure GenerateStr                                                                                                 ple 3. It Ô¨Årst creates a node Œ∑1 such that Progs[Œ∑1] = {v1},
                                                                     t                                                                        val(Œ∑ ) = s and the frontier of reachable nodes is set as
                        The GenerateStr procedure, shown in Figure 5(a), oper-                                                                          1           1
                                                        t                                                                                     Œ∑Àú        = {Œ∑ }. We use node Œ∑ to denote the node cor-
                        ates by iteratively computing a set of nodes Œ∑Àú and updating                                                            diff              1                                     i
                                                                                                                                              responding to string s such that val(Œ∑ ) = s . The al-
                        two maps Progs and val in the loop at Line 7. Each node                                                                                                        i                                i            i
                                                                                                                                              gorithm then Ô¨Ånds that the table entry T [C ,1] is reach-
                        Œ∑ ‚àà Œ∑Àú represents a string val(Œ∑) that is present in some                                                                                                                                          1     1
                        table entry.             The inverse map val‚àí1(a) returns the node                                                    able from node Œ∑1 with the generalized boolean condition
                                                                                                                                              B={C ={s ,v }}. The algorithm then makes the other
                        corresponding to string a or ‚àÖ if no such node exist. The                                                                           1           1    1
                                                                                                                                              column entries in the row, namely T [C ,1] and T [C ,1]
                        map Progs associates every node Œ∑ to a set of expressions                                                                                                                                 1     2                   1     3
                                                                                                                                      744
