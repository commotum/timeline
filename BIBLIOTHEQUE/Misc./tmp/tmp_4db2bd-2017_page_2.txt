                       Published as a conference paper at ICLR 2017
                       showorders-of-magnitude improvements over optimized standard search techniques and a Recurrent
                       Neural Network-based approach to the problem.
                       In summary, we deﬁne and instantiate a framework for using deep learning for program synthesis
                       problems like ones appearing on programming competition websites. Our concrete contributions are:
                            1. deﬁning a programming language that is expressive enough to include real-world program-
                               mingproblemswhilebeinghigh-levelenoughtobepredictablefrominput-outputexamples;
                            2. models for mapping sets of input-output examples to program properties; and
                            3. experiments that show an order of magnitude speedup over standard program synthesis
                               techniques, which makes this approach feasible for solving problems of similar difﬁculty as
                               the simplest problems that appear on programming competition websites.
                       2   BACKGROUNDONINDUCTIVEPROGRAMSYNTHESIS
                       Webeginbyproviding background on Inductive Program Synthesis, including a brief overview of
                       howitis typically formulated and solved in the programming languages community.
                       The Inductive Program Synthesis (IPS) problem is the following: given input-output examples,
                       produce a program that has behavior consistent with the examples.
                       Building an IPS system requires solving two problems. First, the search problem: to ﬁnd consistent
                       programs we need to search over a suitable set of possible programs. We need to deﬁne the set
                       (i.e., the program space) and search procedure. Second, the ranking problem: if there are multiple
                       programsconsistentwiththeinput-outputexamples,whichonedowereturn?Bothoftheseproblems
                       are dependent on the speciﬁcs of the problem formulation. Thus, the ﬁrst important decision in
                       formulating an approach to program synthesis is the choice of a Domain Speciﬁc Language.
                       Domain Speciﬁc Languages (DSLs).   DSLs are programming languages that are suitable for a
                       specialized domain but are more restrictive than full-featured programming languages. For example,
                       onemightdisallowloopsorothercontrolﬂow,andonlyallowstringdatatypesandasmallnumberof
                       primitive operations like concatenation. Most of program synthesis research focuses on synthesizing
                       programsinDSLs,becausefull-featuredlanguageslikeC++enlargethesearchspaceandcomplicate
                       synthesis. Restricted DSLs can also enable more efﬁcient special-purpose search algorithms. For
                       example, if a DSL only allows concatenations of substrings of an input string, a dynamic program-
                       ming algorithm can efﬁciently search over all possible programs (Polozov & Gulwani, 2015). The
                       choice of DSL also affects the difﬁculty of the ranking problem. For example, in a DSL without if
                       statements, the same algorithm is applied to all inputs, reducing the number of programs consistent
                       with any set of input-output examples, and thus the ranking problem becomes easier. Of course, the
                       restrictiveness of the chosen DSL also determines which problems the system can solve at all.
                       Search Techniques.  There are many techniques for searching for programs consistent with input-
                       output examples. Perhaps the simplest approach is to deﬁne a grammar and then enumerate all
                       derivations of the grammar, checking each one for consistency with the examples. This approach
                       can be combined with pruning based on types and other logical reasoning (Feser et al., 2015). While
                       simple, these approaches can be implemented efﬁciently, and they can be surprisingly effective.
                       In restricted domains such as the concatenation example discussed above, special-purpose algorithms
                       can be used. FlashMeta (Polozov & Gulwani, 2015) describes a framework for DSLs which allow
                       decomposition of the search problem, e.g., where the production of an output string from an input
                       string can be reduced to ﬁnding a program for producing the ﬁrst part of the output and concatenating
                       it with a program for producing the latter part of the output string.
                       Another class of systems is based on Satisﬁability Modulo Theories (SMT) solving. SMT combines
                       SAT-style search with theories like arithmetic and inequalities, with the beneﬁt that theory-dependent
                       subproblems can be handled by special-purpose solvers. For example, a special-purpose solver can
                       easily ﬁnd integers x, y such that x < y and y < −100 hold, whereas an enumeration strategy may
                       need to consider many values before satisfying the constraints. Many program synthesis engines
                       based on SMT solvers exist, e.g., Sketch (Solar-Lezama, 2008) and Brahma (Gulwani et al., 2011).
                       They convert the semantics of a DSL into a set of constraints between variables representing the
                                                                2
