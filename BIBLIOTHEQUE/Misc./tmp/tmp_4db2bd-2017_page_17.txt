                               Published as a conference paper at ICLR 2017
                               Dembczynskietal. (2010) proved that Bayes optimal decisions under the Hamming and Rank loss
                               functions, i.e., decisions minimizing the expected loss under these loss functions, can be computed
                               from marginal probabilities p (y |x). This suggests that:
                                                                c  c
                                      • Multilabel classiﬁcation under these two loss functions may not beneﬁt from considering
                                         dependencies between the labels.
                                      • ”Instead of minimizing the Rank loss directly, one can simply use any approach for single
                                                                                                                                   ´
                                         label prediction that properly estimates the marginal probabilities.” (Dembczynski et al.,
                                         2012)
                               Training the neural network with the negative cross entropy loss function as the training objective is
                               precisely a method for properly estimating the marginal probabilities of labels (functions appearing
                               in source code). It is thus a sensible step in preparation for making predictions under a Rank loss.
                               It remains to discuss the relationship between the Rank loss and the actual quantity we care about,
                               whichisthetotal runtime of a Sort and add search procedure. Recall the simplifying assumption that
                               the runtime of searching for a program of length T with C functions made available to the search is
                               proportional to CT, and consider a Sort and add search for a program of length T, where the size
                               of the active set is increased by 1 whenever the search fails. Starting with an active set of size 1, the
                               total time until a solution is found can be upper bounded by
                                                                  T     T             T       T+1          T
                                                                1 +2 +···+C ≤C                      ≤CC
                                                                                      A       A            A
                               whereCAisthesizeoftheactivesetwhenthesearchﬁnallysucceeds(i.e.,whentheactivesetﬁnally
                               contains all necessary functions for a solution to exist). Hence the total runtime of a Sort and add
                               search can be upper bounded by a quantity that is proportional to CT.
                                                                                                          A
                                                                                                                           C
                               NowﬁxavalidprogramsolutionP thatrequiresCP functions,andletyP ∈ {0,1} betheindicator
                               vector of functions used by P. Let D := CA − CP be the number of redundant operations added
                               into the active set until all operations from P have been added.
                               Example1. Suppose the labels, as sorted by decreasing predicted marginal probabilities f(x), are
                               as follows:
                                                  1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                               Then the solution P contains C         =6functions, but the active set needs to grow to size C            =11
                                                                   P                                                                  A
                               to include all of them, adding D = 5 redundant functions along the way. Note that the rank loss of
                               the predictions f(x) is L (y ,f(x)) = 2 + 5 = 7, as it double counts the two redundant functions
                                                           r   P
                               which are scored higher than two relevant labels.
                               Noting that in general Lr(yP,f(x)) ≥ D, the previous upper bound on the runtime of Sort and add
                               can be further upper bounded as follows:
                                             T                T                          T                                      T
                                           C =(C +D) ≤const+const×D ≤const+const×L (y ,f(x))
                                             A        P                                                            r   P
                               Hence we see that for a constant value of T, this upper bound can be minimized by optimizing the
                               Rank loss of the predictions f(x). Note also that L (y ,f(x)) = 0 would imply D = 0, in which
                                                                                        r   P
                               case C    =C .
                                      A       P
                               F DOMAINSPECIFIC LANGUAGE OF DEEPCODER
                               Here we provide a description of the semantics of our DSL from Sect. 4.1, both in English and as a
                               Pythonimplementation. Throughout, NULL isaspecialvaluethatcanbesete.g. toanintegeroutside
                               the working integer range.
                               First-order functions:
                                      • HEAD :: [int] -> int
                                         lambda xs: xs[0] if len(xs)>0 else Null
                                         Given an array, returns its ﬁrst element (or NULL if the array is empty).
                                      • LAST :: [int] -> int
                                         lambda xs: xs[-1] if len(xs)>0 else Null
                                         Given an array, returns its last element (or NULL if the array is empty).
                                                                                     17
