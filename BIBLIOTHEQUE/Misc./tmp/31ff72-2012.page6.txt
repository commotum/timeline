                GenerateStr (σ:      Input state, s:     Output string)
                              t                                               Intersect ((η˜ ,ηt,Progs ),     = (η˜ ×η˜ ,(ηt,ηt),Progs )
                1 η˜ := ∅; η˜   := ∅; steps := 0;                                        t   1  1        1          1    2   1   2        12
                            Old
                2 foreach input variable vi:                                               (η˜ , ηt,Progs ))
                                    −1                                                       2  2       2
                3     if ((η := val    (σ(vi))) = ⊥)                             where Progs [(η ,η )] = Intersect (Progs [η ],Progs [η ])
                4     then { η := NewNode();η˜ := η˜∪{η};                                     12   1  2                t       1 1        2  2
                                                                                         Intersect (v ,v )    = v
                5              val(η) := σ(vi);Progs[η] := ∅; }                                     t  i  i        i
                6     Progs[η] := Progs[η]∪{vi};                             Intersect (Select(C,T,B), = Select(C,T,B00)
                                                                                        t
                7 while (steps++ ≤ k ∧ η˜       6=η˜)                                                    0
                                             Old                                         Select(C,T,B ))
                8     η˜   := η˜−η˜    ; η˜  := η˜;
                       diff         Old   Old                                    where B00 = Intersect (B,B0)
                9     foreach table T, col C, row r s.t.                                                 t
                                                                                                        0                           0
                                                                                                ˜     ˜                         ˜ ˜
                              T[C,r] = val(η) for some η ∈ η˜                      Intersect ({b } ,{b } )    = {Intersect (b ,b )}
                                   V                            diff                         t   i i    i i                   t  i  i  i
                                          0         0       −1      0                                   0                           0
               10         B:={          (C ={T[C ,r],val      (T[C ,r])}) |       Intersect ({p˜ } ,{p˜ } )   = {Intersect (p˜ ,p˜ )}
                                 C0∈cKey                                                     t   i i    i i                   t  i  i  i
                                                                                Intersect (C = s,C = s) = C = s
                                     cKey ∈ CandidateKeys(T)};                             t
               11         foreach column C0 of table T s.t. C0 6= C: Intersectt(C = η1,C = η2) = C = (η1,η2)
                                            −1     0
               12             if ((η := val   (T[C ,r])) = ⊥)                     Intersect (C = {s,η },      = C={s,(η ,η )}
               13             then { η := NewNode();η˜ := η˜∪{η};                            t          1                   1   2
               14                     val(η) := T[C0,r];Progs[η] := ∅; }                       C={s,η2})
               15             Progs[η] := Progs[η]∪{Select(C0,T,B)};             Intersect (C = {s ,η },      = C={(η ,η )}, if s 6= s
                                                                                            t        1  1                 1  2        1    2
                                  −1
               16 return (η˜,val     (s),Progs);                                             C={s ,η })
                                                                                                     2  2
                                                (a)                                                            (b)
              Figure 5: (a) The GenerateStr procedure for generating the set of all expressions (of depth at most k)
                                                    t
              in language L that are consistent with a given input-output example. (b) The Intersect procedure for
                               t                                                                                             t
              intersecting sets of expressions from language L . The Intersect procedure returns ∅ in all other cases.
                                                                        t                  t
              also reachable and creates nodes η2 and η3 corresponding            any table and m is the maximum number of columns in any
              to them, and then sets Progs[η ] = {Select(C ,T ,B)}                candidate key. (b) The procedure Intersect is sound and
                                                 2                2   1                                                          t
              and Progs[η ] = {Select(C ,T ,B)}.          In the next iter-       complete. The computational complexity of Intersect pro-
                           3                 3   1                                                                                        t
              ation of loop, the frontier of reachable set is updated to          cedure (and hence the size of the data structure returned by
                                                                                            2
              η˜    ={η ,η } and the nodes that are reachable from this           it) is O(d ), where d is the size of the input data structures.
                diff     2  3
              set are next computed. The algorithm ﬁnds that table entry          The proof of Theorem 2 is given in [16].
              T2[C1,1] is reachable from node η2 and thereby makes nodes
              η3 and η4 reachable as well with corresponding Select ex-           4.4    Ranking
              pressions. Similarly, the nodes η4 and η5 become reachable             In this section, we deﬁne a partial order between expres-
              from η3. In this manner, the algorithm keeps computing the          sions in L that we use for ranking of these expressions. We
              set of reachable table entries iteratively until k iterations,                t
              where k is set to the number of relational tables n.                prefer expressions of smaller depth (fewer nested chains of
                                                                                  Select expressions). We prefer lookup expressions that use
              Procedure Intersect                                                 distinct tables for join queries (the most common scenario
                                      t                                           for end-users) as opposed to expressions involving self-joins.
              The Intersect procedure takes two sets of expressions in            We prefer conditionals that consist of fewer predicates and
                              t
              Lt as input and computes the set of expressions that are            prefer predicates that involve comparing columns with other
              common to both the sets. (Both input and output sets are            table entries or input variables (as opposed to comparing
              represented using the data structure D .) Figure 5(b) de-           columns with constant strings).
                                                        t
              scribes the Intersect procedure for intersecting the sets of
                                     t
              Lt expressions using a set of rules that are pattern matched        5.    SEMANTICTRANSFORMATIONS
              for execution. For intersecting two expressions (η˜ ,ηt,Progs )
                                                                1   1       1        Wenowpresentanextensionofthelookuptransformation
              and (η˜ ,ηt,Progs ), we take the cross product of the set of
                     2  2        2                                                language L (described in §4) with a syntactic transforma-
              nodes to get the new set of nodes η˜     =(η˜ ×η˜ ) with the                    t
                                                    12     1    2                 tion language L (from [8]). This extended language L ,
              target node (ηt,ηt), and compute the new Progs        map for                        s                                          u
                             1   2                               12               also referred to as semantic transformation language, adds
              each node (η ,η ) ∈ η˜    by intersecting their corresponding
                            1  2     12                                           two key capabilities to Lt: (i) It allows for lookup trans-
              maps Progs [η1] and Progs [η2] respectively. The intersect
                           1               2                                      formations that involve performing syntactic manipulations
              rule for two select expressions requires the column name            (such as substring, concatenation, etc.) on strings before
              and table id to be the same and intersects the conditionals         using them to perform lookups, and (ii) It allows for per-
                                                 ˜
              recursively. The candidate keys bi as well as each column           forming syntactic manipulations on lookup outputs (which
              conditional p˜ in a candidate key are intersected individually      can then be used for performing further lookups or for gen-
              maintaining their corresponding orderings.                          erating the output string). This extension, as we show in
                 Theorem 2       (Synthesis Algorithm Properties).                §6, also enables us to model transformations on strings rep-
              (a) The procedure GenerateStr is sound and k-complete.              resenting standard data types such as date, time, etc. We
                                                t                                 ﬁrst describe a syntactic transformation language.
              The computational complexity of GenerateStr procedure
                                                              t
              (and hence the size of the data structure constructed by it)        Syntactic Transformation Language Ls (Background).
              is O(t2 p m) where t is the number of reachable strings in          Gulwani [8] introduced an expression language for perform-
              k iterations, p is the maximum number of candidate keys in          ing syntactic string transformations. We reproduce here a
                                                                              745
