                         Published as a conference paper at ICLR 2017
                         4   DEEPCODER
                         Here we describe DeepCoder, our instantiation of LIPS including a choice of DSL, a data generation
                         strategy, models for encoding input-output sets, and algorithms for searching over program space.
                         4.1  DOMAINSPECIFIC LANGUAGE AND ATTRIBUTES
                         Weconsider binary attributes indicating the presence or absence of high-level functions in the target
                         program. To make this effective, the chosen DSL needs to contain constructs that are not so low-level
                         that they all appear in the vast majority of programs, but at the same time should be common enough
                         so that predicting their occurrence from input-output examples can be learned successfully.
                         Following this observation, our DSL is loosely inspired by query languages such as SQL or LINQ,
                         where high-level functions are used in sequence to manipulate data. A program in our DSL is a
                         sequence of function calls, where the result of each call initializes a fresh variable that is either a
                         singleton integer or an integer array. Functions can be applied to any of the inputs or previously
                         computed (intermediate) variables. The output of the program is the return value of the last function
                         call, i.e., the last variable. See Fig. 1 for an example program of length T = 4 in our DSL.
                          a←[int]                   Aninput-output example:
                          b←FILTER(<0)a              Input:
                          c←MAP( 4)b                 [-17, -3, 4, 11, 0, -5, -9, 13, 6, 6, -8, 11]
                                     *              Output:
                          d←SORTc                    [-12, -20, -32, -36, -68]
                          e←REVERSEd
                              Figure 1: An example program in our DSL that takes a single integer array as its input.
                         Overall, our DSL contains the ﬁrst-order functions HEAD, LAST, TAKE, DROP, ACCESS, MINIMUM,
                         MAXIMUM, REVERSE, SORT, SUM, and the higher-order functions MAP, FILTER, COUNT, ZIP-
                         WITH, SCANL1. Higher-order functions require suitable lambda functions for their behavior to be
                         fully speciﬁed: for MAP our DSL provides lambdas (+1),(-1),( 2),(/2),( (-1)),(       2),
                                                                                     *           *          **
                         ( 3),(/3),( 4),(/4);for FILTER and COUNT there are predicates (>0), (<0), (%2==0),
                          *            *
                         (%2==1)andforZIPWITHandSCANL1theDSLprovideslambdas(+),(-),( ),MIN,MAX.
                                                                                                   *
                         Adescription of the semantics of all functions is provided in Appendix F.
                         Note that while the language only allows linear control ﬂow, many of its functions do perform
                         branching and looping internally (e.g., SORT, COUNT, ...). Examples of more sophisticated programs
                         expressible in our DSL, which were inspired by the simplest problems appearing on programming
                         competition websites, are shown in Appendix A.
                         4.2  DATA GENERATION
                         To generate a dataset, we enumerate programs in the DSL, heuristically pruning away those with
                         easily detectable issues such as a redundant variable whose value does not affect the program output,
                         or, more generally, existence of a shorter equivalent program (equivalence can be overapproximated
                         byidentical behavior on randomly or carefully chosen inputs). To generate valid inputs for a program,
                         weenforceaconstraintontheoutputvalueboundingintegerstosomepredeterminedrange,andthen
                         propagate these constraints backward through the program to obtain a range of valid values for each
                         input. If one of these ranges is empty, we discard the program. Otherwise, input-output pairs can be
                         generated by picking inputs from the pre-computed valid ranges and executing the program to obtain
                         the output values. The binary attribute vectors are easily computed from the program source codes.
                         4.3  MACHINE LEARNING MODEL
                         Observe how the input-output data in Fig. 1 is informative of the functions appearing in the program:
                         the values in the output are all negative, divisible by 4, they are sorted in decreasing order, and they
                         happen to be multiples of numbers appearing in the input. Our aim is to learn to recognize such
                         patterns in the input-output examples, and to leverage them to predict the presence or absence of
                                                                    4
