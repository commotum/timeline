                                                            Published as a conference paper at ICLR 2017
                                                                Program6:                                                  IOexample:                             Description:
                                                                t←[int]                                                    Input:                                 Umberto has a large collection of ties and match-
                                                                p←[int]                                                    [4 8 11 2], ingpocketsquares—toolarge,hiswifesays—andhe
                                                                c←MAP(-1)t                                                 [2 3 4 1]                              needs to sell one pair. Given their values as arrays t
                                                                d←MAP(-1)p                                                 Output:                                and p, assuming that he sells the cheapest pair, and
                                                                e←ZIPWITH(+)cd 1                                                                                  selling costs 2, how much will he lose from the sale?
                                                                f←MINIMUMe
                                                                                                                                                                  Description:
                                                                                                                                                                  Zack always promised his n friends to buy them
                                                                Program7:                                                  IOexample:                             candy, but never did. Now he won the lottery
                                                                s←[int]                                                    Input:                                 and counts how often and how much candy he
                                                                p←[int]                                                    [4 7 2 3],                             promised to his friends, obtaining arrays p (num-
                                                                c←SCANL1(+)p                                               [2 1 3 1]                              ber of promises) and s (number of promised sweets).
                                                                d←ZIPWITH( )sc Output:                                                                            He announces that to repay them, he will buy
                                                                                                      *                                                           s[1]+s[2]+...+s[n] pieces of candy for the
                                                                e←SUMd                                                     62                                     ﬁrst p[1] days, then s[2]+s[3]+...+s[n] for
                                                                                                                                                                  p[2] days, and so on, until he has fulﬁlled all
                                                                                                                                                                  promises. How much candy will he buy in total?
                                                                                                                                                                  Description:
                                                                                                                                                                  Vivian loves rearranging things. Most of all, when
                                                                                                                                                                  she sees a row of heaps, she wants to make sure that
                                                                                                                                                                  each heap has more items than the one to its left. She
                                                                Program8:                                                  IOexample:                             is also obsessed with efﬁciency, so always moves the
                                                                s←[int]                                                    Input:                                 least possible numberofitems. Herdadreallydislikes
                                                                b←REVERSEs                                                 [1 2 4 5 7] if she changes the size of heaps, so she only moves
                                                                c←ZIPWITH(-)bs Output:                                                                            single items between them,makingsurethatthesetof
                                                                d←FILTER(>0)c                                              9                                      sizes of the heaps is the same as at the start; they are
                                                                e←SUMd                                                                                            only in a different order. When you come in, you see
                                                                                                                                                                  heaps of sizes (of course, sizes strictly monotonically
                                                                                                                                                                  increasing) s[0], s[1], ... s[n]. What is
                                                                                                                                                                  the maximal number of items that Vivian could have
                                                                                                                                                                  moved?
                                                            Fig. 4 shows the predictions made by a neural network trained on programs of length T = 4 that
                                                            wereensuredtobesemanticallydisjointfromall9exampleprogramsshowninthissection.Foreach
                                                            task, the neural network was provided with 5 input-output examples.
                                                                                                                         (+1)(-1) (*2) (/2) (*-1)(**2)(*3)(/3)(*4) (/4) (>0)(<0) (%2==1)(%2==0)HEADLASTMAPFILTERSORTREVERSETAKEDROPACCESSZIPWITHSCANL1+-*   MIN  MAX  COUNTMINIMUMMAXIMUMSUM
                                                                                         0: SORT b | TAKE a c | SUM d  .0   .2   .0  .1   .4   .0   .0  .2   .0   .1  .0   .2   .1  .0   .1   .0   .3  .4   .2   .1  .5   .2   .2  .6   .5   .2   .4  .0   .9   .1  .0   .1   .0  1.0
                                                                           1: MAP (*3) a | ZIPWITH + b c | MAXIMUM d   .1   .1   .1  .1   .0   .0  1.0 .0    .1   .0  .2   .1   .1  .1   .0   .3  1.0 .2    .1   .1  .0   .0   .1  1.0 .0    .6   .6  .0   .1   .1  .2   .0   .9  .0
                                                                                      2: ZIPWITH - b a | COUNT (>0) c  .1   .2   .0  .1   .0   .0   .0  .1   .0   .1  .2   .2   .3  .3   .0   .0   .6  .0   .1   .1  .0   .0   .0  1.0 .3    .4  .5   .0   .5   .5  1.0 .0    .0  .0
                                                              3: SCANL1 MIN a | ZIPWITH - a b | FILTER (>0) c | SUM d  .3   .1   .1  .1   .1   .0   .0  .0   .0   .0  .1   .0   .0  .0   .0   .0   .6  .2   .1   .1  .0   .0   .0  1.0 .3    .3  .3   .1   .2   .7  .0   .0   .1  1.0
                                                               4: SORT a | SORT b | REVERSE d | ZIPWITH * d e | SUM f  .0   .0   .1  .4   .1   .4   .0  .0   .2   .0  .0   .2   .0  .2   .1   .2   .9  .2   .1  .0   .0   .0   .4  .6   .2   .2   .3  .3   .4   .1  .2   .4   .0  .4
                                                                                     5: REVERSE a | ZIPWITH MIN a b    .2   .2   .0  .2   .0   .0   .0  .0   .0   .0  .0   .0   .0  .0   .0   .0   .9  .0   .0  1.0 .0    .0   .0  1.0 .0    .2   .0  .0  1.0 .1    .0   .0   .0  .0
                                                                6: MAP (-1) a | MAP (-1) b | ZIPWITH + c d | MINIMUM e .1   .1   .0  .0   .0   .0   .0  .0   .0   .0  .0   .2   .2  .2   .7   .0  .3   .3   .1   .0  .0   .0   .0  1.0 .1    .9   .1  .0   .7   .2  .1   .8   .0  .0
                                                                               7: SCANL1 + b | ZIPWITH * a c | SUM d   .0   .0   .0  .0   .0   .1   .0  .0   .1   .0  .1   .1   .1  .1   .0   .1   .4  .1   .0   .0  .0   .0   .0  1.0 .8    .5   .4 1.0 .1     .0  .2   .0   .1  .7
                                                                 8: REVERSE a | ZIPWITH - b a | FILTER (>0) c | SUM d  .2   .1   .0  .1   .1   .0   .0  .1   .0   .1  .1   .1   .1  .0   .0   .0   .5  .5   .1  .0   .0   .0   .0  1.0 .4    .4  .5   .0   .3   .6  .0   .0   .1  1.0
                                                            Figure 4: Predictions of a neural network on the 9 example programs described in this section.
                                                            Numbersinsquares would ideally be close to 1 (function is present in the ground truth source code),
                                                            whereas all other numbers should ideally be close to 0 (function is not needed).
                                                            B EXPERIMENTALRESULTS
                                                            Results presented in Sect. 5.1 showcased the computational speedups obtained from the LIPS frame-
                                                            work (using DeepCoder), as opposed to solving each program synthesis problem with only the
                                                                                                                                                                       13
