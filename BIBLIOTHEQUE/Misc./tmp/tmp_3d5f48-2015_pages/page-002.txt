             methods perform similar computational work. That said, it      these sources in further detail and present our natural lan-
             maynonetheless be diﬃcult to justify ﬁne-grained numerical     guage description of each problem, summarized from the
             comparisons amongdiverse techniques on these problems, as      original source. All problems use functional arguments as
             they may involve qualitatively diﬀerent kinds of costs and     inputs besides one that requires reading input from a ﬁle.
             each may be parameterized in radically diﬀerent ways. In       Some problems require programs to return functional out-
             many cases, the most interesting question to ask vis-a-vis     puts, where others require the program to print results.
             a particular system on a particular problem may just be        4.1   iJava
             whether the system can solve the problem at all, and if so,
             whether it can solve it reasonably reliably. Nevertheless,       iJava is an interactive introductory computer science text-
             we aim here to describe speciﬁcations that will allow for as   book that contains a number of automatically graded pro-
             much cross-system comparability as possible.                   gramming problems [11]. Many of its problems are graded
                                                                            by testing programs against a range of inputs, making them
             3.   PROBLEMSELECTIONCRITERIA                                  easy to convert into benchmark problems.
               In this section we describe the criteria we used when se-      Some sets of problems in iJava meet our criteria but test
             lecting problems for the benchmark suite. Several of our       similar programming techniques; for these sets, we chose one
             criteria overlap with those described in the GP benchmarks     representative problem from the group, ensuring a reason-
             papers [9, 17], such as being varied, relevant, realistically  able distribution of problem requirements. Along with each
             diﬃcult, representation-independent, and precisely deﬁned.     problem name and description, we provide the question or
               This benchmark suite is designed for systems that use ex-    project number associated with the problem in iJava 3.1.
             ample inputs and their corresponding outputs as the speci-        1. Number IO (Q 3.5.1) Given an integer and a ﬂoat,
             ﬁcations for desired programs. In the context of GP, we call        print their sum.
             the input/output pairs test cases for the problem. Thus,
             a problem must be deﬁned on a range of inputs that have           2. Small or Large (Q 4.6.3) Given an integer n, print
             known correct outputs; it cannot simply specify the calcula-        “small”if n < 1000 and“large”if n ≥ 2000 (and noth-
             tion of a single value. For example, a problem that requires        ing if 1000 ≤ n < 2000).
             the program to calculate the number of prime numbers less
             than 1000 would not qualify, since it only has one answer;        3. For Loop Index (Q 4.11.7) Given 3 integer inputs
             but, a similar problem that requires the program to calcu-          start,end, and step, print the integers in the sequence
             late the number of prime numbers less than an input integer
             n would meet this requirement, since we could then provide                            n0 = start
             example inputs for n and their corresponding outputs. This                            n =n      +step
             requirement also ensures that test cases can be generated to                            i    i−1
                                                                                 for each n < end, each on their own line.
             ﬁll the training and test set, as required to test generaliza-                i
             tion of successful programs.                                      4. Compare String Lengths (Q 4.11.13) Given three
               Problems in the suite should present challenges typical of        strings n1, n2, and n3, return true if length(n1) <
             real programming tasks. This criterion leads us to choose           length(n2) < length(n3), and false otherwise.
             problems that call for a range of programming constructs
             and data types. The problems should require a variety of          5. Double Letters (P 4.1) Given a string, print the
             sizes and shapes for solution programs, not just artiﬁcially        string, doubling every letter character, and tripling ev-
             small programs.                                                     ery exclamation point. All other non-alphabetic and
               The benchmarks should not be biased toward a particu-             non-exclamation characters should be printed a single
             lar method of synthesis; it should be possible to attempt to        time each.
             solve them using various GP systems as well as analytic and
             search-based program synthesis systems. Since systems gen-        6. Collatz Numbers (P 4.2) Given an integer, ﬁnd the
             erate programs in a variety of languages, we avoid problems         number of terms in the Collatz (hailstone) sequence
             that require a speciﬁc language feature or non-standard data        starting from that integer.
             type (such as Java objects).
               We take our problems from pre-existing sources of intro-        7. Replace Space with Newline (P 4.3) Given a
             ductory programming problems. From each source, we in-              string input, print the string, replacing spaces with
             clude all problems that meet the criteria described above,          newlines. Also, return the integer count of the non-
             aiming to avoid biasing the selection of problems. We re-           whitespace characters. The input string will not have
             jected problems from other sources that did not meet our cri-       tabs or newlines.
             teria, such as the inductive programming benchmark repos-
                  2                                                            8. String Diﬀerences (P 4.4) Given 2 strings (with-
             itory , other program synthesis and inductive programming
             papers, and programming competitions.                               out whitespace) as input, ﬁnd the indices at which the
                                                                                 strings have diﬀerent characters, stopping at the end
             4.   PROBLEMDESCRIPTIONS                                            of the shorter one. For each such index, print a line
               Weused two sources for problems: iJava [11], an interac-          containing the index as well as the character in each
             tive textbook for introductory computer science, and Intro-         string. For example, if the strings are “dealer” and
             Class [2, 1], a set of problems originally used as benchmarks       “dollars”, the program should print:
             for automatic program repair. Below we describe each of                    1 e o
                                                                                        2 a l
             2http://www.inductive-programming.org/repository.html                      4 e a
