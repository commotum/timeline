                                      Task:   [1 2 3]→[2 4 6]                        Task:   [1 2 3)→[0 1 2]
                                              [4 3 4]→[8 6 8]                                [4 3 4]→[3 2 3]
                                        Wake: program search                            Wake: program search
                                   (Y (λ (r l) (if (nil? l) nil                   (Y (λ (r l) (if (nil? l) nil
                                    (cons (+ (car l) (car l))                      (cons (- (car l) 1)
                                          (r (cdr l))))))                                 (r (cdr l))))))
                                                               Sleep: Abstraction              refactor
                                               refactor
                                             14                                              14
                                          (10   refactorings)                            (10   refactorings)
                                ((λ (f) (Y (λ (r l) (if (nil? l)                ((λ (f) (Y (λ (r l) (if (nil? l)
                                                 nil                                            nil
                                                 (cons (f (car l))                              (cons (f (car l))
                                                  (r (cdr l)))))))                                (r (cdr l)))))))
                                 (λ (z) (+ z z)))                                (λ (z) (- z 1)))
                                                          Compress (MDL/Bayes objective)
                                               ( map (λ (z) (+ z z)))       ( map (λ (z) (- z 1)))
                                                map = (λ (f) (Y (λ (r l) (if (nil? l) nil
                                                                                (cons (f (car l))
                                                                                (r (cdr l))))))
                Figure 3: Programs found as solutions during waking are refactored – or rewritten in semantically
                equivalent but syntactically distinct forms – during the sleep abstraction phase, to expose candidate
                newprimitives for growing DreamCoder’s learned library. Here, solutions for two simple list tasks (top
                left, ‘double each list element’; top right, ‘subtract one from each list element’) are ﬁrst found using
                a very basic primitive set, which yields correct but inelegant programs. During sleep, DreamCoder
                efﬁciently searches an exponentially large space of refactorings for each program; a single refactoring
                of each is shown, with a common subexpression highlighted in orange. This expression corresponds to
                map, a core higher-order function in modern functional programming that applies another function to
                each element of a list. Adding map to the library makes existing problem solutions shorter and more
                interpretable, and crucially bootstraps solutions to many harder problems in later wake cycles.
                expectation is taken over tasks. Taking this expectation over the empirical distribution of tasks trains
                Qonreplays; taking it over samples from the generative model trains Q on fantasies. We train on a
                50/50 mix of replays and fantasies; for fantasies mapping inputs to outputs, we sample inputs from
                the training tasks. Although one could train Q to perform full posterior inference, our MAP objective
                has the advantage of teaching the recognition network to ﬁnd a simplest canonical solution for each
                problem. More technically, our MAP objective acts to break syntactic symmetries in the space of
                programs by forcing the network to place all its probability mass onto a single member of a set of
                syntactically distinct but semantically equivalent expressions. Hand-coded symmetry breaking has
                proved vital for many program synthesizers (22,23); see S4.6 for theoretical and empirical analyses of
                DreamCoder’s learned symmetry breaking.
                                                                          8
