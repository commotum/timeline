                      A large-scale benchmark for few-shot program induction and synthesis 
                                    *1                             *1                  1                 1                             1 
                      Ferran Alet       Javier Lopez-Contreras         James Koppel  Maxwell Nye  Armando Solar-Lezama 
                                                               1                          1                           1 
                                       Tomás Lozano-Pérez  Leslie Pack Kaelbling  Joshua B. Tenenbaum 
                                        Abstract 
                    A landmark challenge for AI is to learn fexible, 
                    powerful representations from small numbers of 
                    examples.  On an important class of tasks, hy-
                    potheses in the form of programs provide ex-
                    treme generalization capabilities from surpris-
                    ingly few examples. However, whereas large real 
                    image benchmarks have spurred progress in meta-
                    learning for deep networks, there is no compa-
                    rably big, real program-synthesis dataset.  This 
                    is because, while images are relatively easy to 
                    label from internet meta-data or annotated by non-
                    experts, generating meaningful input-output tests 
                    for program induction has proven hard to scale. 
                    In this work, we propose a new way of leverag-
                    ing a collection of programs with associated unit 
                    tests to create a much larger collection of test-
                    program pairs.  We do so by extracting subpro-
                    grams of each program and using the inputs of the 
                    overall program to get tests for each subprogram.            Figure 1. Extracting interesting subprograms from the Sieve of 
                    This allows us to create PROGRES, a large-scale              Erathostenes.  Some subprograms, like j  =  max (p, dn/pe) p, 
                    few-shot program-induction benchmark of real                 are byproducts that are not directly used by the overall program, 
                    programs and propose new challenges in this do-              but still implement purposeful functions. Line sub-sequences that 
                    main.  We analyze the effect of multiple design              break the nesting structure result in invalid subprograms. 
                    choices on transformer-based program induction 
                    and synthesis algorithms, pointing to shortcom-
                    ings of current methods and suggesting multiple 
                    avenues for future work. 
               1. Introduction 
               Note:  since the camera-ready, we have made a fnal ver-
               sion  of  the  dataset  with  more  programs  and  increased 
               diversity.  The dataset description is the same, but met-
               rics  and statistics change,  and get more detailed.  You 
               can fnd it the updated PDF and materials at:  https: 
               //lis.csail.mit.edu/progres.                                      Figure 2. Example of a task corresponding to the fltering subpro-
                  *                   1                                          gram in fgure 1. The text context describes the overall program in 
                   Equal contribution  Massachusetts Institute of Technology,    which the subprogram is embedded. The C++ function provides 
               Cambridge Massachusetts, USA. Correspondence to: Ferran Alet      a possible implementation. Even though we standardize variable 
               <alet@mit.edu>, Javier Lopez-Contreras <javierlc@mit.edu>.        names, there are still alternative implementations, such as using 
               Proceedings of the    th                                          while instead of for. The Program Expression Graph (only a
                                  38    International Conference on Machine      portion shown) provides a more canonical notation. 
               Learning, PMLR 139, 2021. Copyright 2021 by the author(s). 
