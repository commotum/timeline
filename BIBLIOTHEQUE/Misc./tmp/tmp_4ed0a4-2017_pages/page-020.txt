                       OPTIMAL DESCRIPTION  MODES      3
       them.  Indeed, let
                           0 (0!/)  =   Di(y),
                           D(ly) = D2(y).
       In other words, we consider the first bit of a description as the index of a description 
       mode and the rest as the description (for this mode).
          If y is a description of x with respect to D\  (or D2), then 0y (respectively, 1 y) 
       is  a description  of x  with  respect  to  D  as well.  This  description  is only one bit 
       longer, therefore we have
                         Cd{x) ^ Cd1 (t) + 1,
                         Cd(x) ^ Cd2(x) + 1
       for all x.  Thus the mode D is not worse than both D\  and D^-
          This idea is often used in practice.  For instance, a zip-archive has a preamble; 
       the  preamble says  (among other  things)  which mode  was  used to  compress  this 
       particular file, and the compressed file follows the preamble.
          If we want to use N different compression modes,  we need to reserve initial 
       log2 N bits for the index of the compression mode.
          Using a generalization of this idea, we can prove the following theorem:
          Theorem 1 (Solomonoff-Kolmogorov).  There is a description mode D that is 
       not worse than any other one: for every description m,ode D'  there is a constant c 
       such that
                          Cd(x) ^ Cd'(x) + c
       for every string x.
          A description mode D having this property is called optimal.
          Proof.  Recall that a description mode by definition is a computable function. 
       Every computable function has a program.  We assume that programs are binary 
       strings.  Moreover, we assume that by reading the program bits from left to right, we 
       can determine uniquely where it ends, that is, programs are “self-delimiting”.  Note 
       that every programming language can be modified in such a way that programs are 
       self-delimiting.  For instance, we can double every bit of a given program (changing 
       0 to 00 and 1 to 11) and append the pattern 01 to its end.
          Define now a new description mode D as follows:
                           D{Py) = P{y),
       where P is a program  (in the chosen self-delimiting programming language)  and 
       y  is  any binary string.  That  is,  the algorithm D scans the input string from the 
       left to the right and extracts a program P from the input.  (If the input does not 
       start with a valid program, D does whatever it wants, say, it goes into an infinite 
       loop.  The self-delimiting property guarantees that the decomposition of input  is 
       unique:  if Py — P'y1  for two programs P and P\ then one of the programs is a 
       prefix of the other one.)  Then D applies the extracted program P to the rest of the 
       input (y) and returns the obtained result.  (So D is just a “universal algorithm”, or 
        “interpreter” ; the only difference is that program and input are not separated, and 
       therefore we need to use a self-delimiting programming language.)
          Let us show that indeed D is not worse than any other description mode P.  We 
       assume that the program P is written in the chosen self-delimiting programming
