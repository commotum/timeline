                                         5.5.  MONOTONE COMPLEXITY                              141
             by 6mk2.  So we are able to choose in advance the parameters e and Ö for all the 
             recursive calls.  Also we can bound the number of grandsons of the root used in this 
             process:  it is enough to have Qk2 sons for each son of the root.
                 When all the sons of the root have their reserved intervals, we achieve our goal. 
             Indeed,  let  7  be  the  sum  of requests  made during non-last  recursive  calls.  This 
             gives us a grayed area of size kj outside the reserved intervals, so in total we get at 
             least kj + me for the grayed area while making requests for at most j  + m(e/(3k)). 
             Since 7 ^ me, we get к + 1/2 amplification factor
                                      kj + me ^ (k + 1/2) (7 + me/Зк)
             (a simple computation).
                 This strategy works for infinite branching and for large enough finite branch­
             ing (depending on e, a, k)—but the required branching factor is much larger than 
             needed for Theorem 88.  Let us explain why this happens.  The tree for given e, a, к 
             has branching factor a/e at the root.  In the sons of the root the branching factor 
             is  small  enough not  to  be  a problem,  but  we  should  look at  the  grandsons.  To 
             estimate the branching factor there, we need to bound the ratio a!/e' for the pa­
             rameters of the recursive calls made for the grandsons.  The parameter a' is about 
             ej(3k) and is the same for all the calls, but the parameter e' is different for different 
             calls.  The minimal e' corresponds to the chain of (a/e)6k2 application of the e    Ö 
             transformation from the  induction assumption,  and  it  is  much smaller than the 
             original e.  It  means that the branching factor for the grandson that is processed 
             first should be very large (in fact, we do not know which of the grandsons will be 
             processed first, so we need this large branching for the “oldest” son of every son).5
                 So the problem with our strategy is that it makes too many recursive calls.  It 
             turns out that 0(k2) recursive calls (instead of 0(k2a/e))  are enough if we use a 
             more clever strategy.  It is important that for this strategy the number of calls does 
             not depend on a/e.
                 Here we discuss the modification of the induction step.  Now the  (к + 1/2)- 
             strategy processes all the sons of the root that do not have reserved intervals yet, in 
             parallel (and not sequentially, as we did before).  More precisely, at each iteration we 
             consider all the sons that do not have reserved intervals, we choose one unprocessed 
             son for each of them,  and we process these sons  (who are grandsons of the root) 
             together, making a recursive call.  This means that the format of the game is now 
             changed:  it is played not for one tree,  but for a family of identical disjoint trees. 
             (Server should  provide  disjoint  intervals  for  vertices  that  are  in  different  trees.) 
             This modification alone is still not enough:  it may happen that for each iteration 
             only one son of the root does not have a reserved interval.  In this case there is no
                 5To get a bound for the branching factor for grandsons, we need to bound the ratio e/8 in 
             the strategy by some function fk(a/e).  The value fk+i/2 (a/e) is a product of (a/e)6k2 values of 
             the form fk{a'/e').  Here a!fe'  are different:  the first e'  can be a!, but the following ones should 
             be much smaller:  the second e' should be /*.( 1) times smaller than the first one, the third should 
             be fk(fk( 1))  times  smaller  than  the  second,  etc.  The  last  term  in  the  product  is  obtained  by 
             (a/e)6k2  iterations of fk  starting with 1.  Therefore,
                               fk+iM<*/e) « ЗА: ■ /*,(1) ■ / fc(/fc(l)) • fk(fk(fk(m  
             the product has  (a/e)6k2  factors, and the equation is only approximate since the first e'  is only 
             close to e/(3k).  And we can start, say, with / 3/2 (<*/£) — 2 (see Example 2).  Then /2  (а/e) grows 
             exponentially as а/e increases:  /2  (а/e) ^ 2a/£.  And /2 ,5  (a/e) is a tower of exponents with base 
             2  and  height  а/e.  (One  could  use  the  strategy  from  Example  3  and  increase  к  by  (almost)  1 
             during the induction step, but this would only slightly postpone the problem.)
