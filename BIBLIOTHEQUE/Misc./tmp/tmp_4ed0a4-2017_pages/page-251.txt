          238                      8.  SOME  APPLICATIONS
          bits in Wj for j ^  i) plus O(logiV) (the complexity of the log-file) plus 0(1), which 
          is less than m,N for large N, so we get the desired contradiction.
              The reconstruction goes as follows:  we try all strings of length m as candidates 
          for  Wi  (keeping Wj  with j  ф  i  intact).  For  each  candidate w  we  run  M  on  the 
          resulting string and check whether we get the same protocol P.  There are three 
          possible cases:
              (1)  If (for some w)  M rejects  (does not accept)  the string,  then M does not 
          recognize our language.
              (2) M accepts all these strings (for all candidates) and the protocol P appears 
          only once, for w = W{.  Then reconstruction is possible (and W\ • • ■ wm is compress­
          ible).
              (3) M accepts all these strings, and P appears both for Wi and for some w ф Wj,. 
          Let us show that in this case M accepts a string not in Lm, namely, the string W  
          that has Wj, in the left half while in the right half Wj, is replaced by w.
              Indeed, there are two accepting computations of M :  one if Wj, is used on both 
          sides and the other one for w.  Let us split both of them into parts;  the splitting 
          points are moments when one of the heads enters or leaves Wj, (or w).  The positions 
          of all other heads and the states of M are recorded in P so they are the same for 
          both computations.  (Note that the moments of time can be different since they 
          are not recorded.  In fact,  we may add them also,  but this is not needed.)  So we 
          can glue the computation intervals for both cases; let us show that we can get an 
          accepting computation of M on a bad string (the left half has Wi while the right 
          half has w).
              By our  assumption  during  the  processing  of  W,  there  is  no  moment  when 
          both copies of Wj, carry some heads; since the border crossings for both copies are 
          recorded  in  P,  the same is  true when Wi  is  replaced  by  w.  So  for  each interval 
          between two protocol events related to Wj/w there are three possibilities:  (a) there 
          is  a head in the ith string on the left;  (b)  there is a head in the ith string on the 
          right;  (c)  neither of the  above.  Then we can copy-and-paste the intervals into a 
          new computation:  for part (a) we use the computation of M on W; for part (b) we 
          use the computation of M of changed input  (where Wi is replaced by w); for part
          (c)  we can use either of two (they are the same).  Then we get a computation of M 
          on a mixed string W', so M does not work properly.                 □
                               8.4.  Laws of Large Numbers
              The Strong Law of Large Numbers was proven in Section 3.2  (Theorem 27, 
          p.  56) without any references to Kolmogorov complexity by straightforward count­
          ing.  We consider (mainly) the uniform case.  In this case the SLLN says that the 
          set of all sequences cj = cno^i • • •, such that the sequence
                                      CUo + Wi + • • • + UJn- 1
                                 Pn —         П
          has limit  1/2 as n tends to infinity, has full measure (with respect to the uniform 
          Bernoulli measure on Q).  In other words, the SLLN says that the complement of 
          this set  (i.e., the set of sequences cj such that pn either have no limit or have limit 
          not  equal to  1/2)  is  a null  set.  Later  (Theorem  32,  p.  65)  we  have  shown  that 
          this null set is in fact an effectively null set; this implies that for every ML-random 
          (with respect to the uniform measure) sequence cj the sequence pn converges to 1/2 
          (Theorem 33, p. 65).
