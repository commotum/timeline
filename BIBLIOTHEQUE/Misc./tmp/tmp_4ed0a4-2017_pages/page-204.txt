                                          5.  M ONOTONE  COMPLEXITY
             190
                    •  Declare the corresponding T-vertex as bad.
                    •  Propagate bad T-vertices to the root.  A T-vertex that has only one good 
                       son in T becomes bad, too.  In this way we get a chain of bad T-vertices.
                    •  If some  T-vertices  of the  binary subtree  of T become bad  (the subtree 
                       intersects the chain of bad T-vertices), take the first bad T-vertex in the 
                       subtree (closest to the root) and replace its by its good brother.  (This is 
                       possible since its father is good and therefore has at least two good sons.) 
                       Then grow a replacement binary subtree starting from the new T-vertex 
                       and using only good T-vertices.  (Again this is possible since every good 
                       vertex has at least two good sons.)
                    •  Extend the mapping / to the new part of the binary subtree of T.
                 There is only one case when this construction is impossible:  if the root becomes 
             a bad vertex.  If this happens, then all its T-sons (except maybe one) are bad, all 
             the T-sons of these bad T-sons (except maybe one) are bad, etc.  In this way we 
             get a subtree of bad T-vertices, and its leaves (the T-vertices that became bad not 
             because of their sons) are intervals of U.  Then backward induction shows that the 
             size of U is at least (*), and we get a positive lower bound assuming that the series 
                2~ki converges.  (The infinite product П(1 — &i) is positive if and only if       is 
             finite.)  So one may take, for example, ki =  \2 log г]  (for i ^ 2), and then for small 
             enough sets U the root will never become bad.
                 To justify this construction, we need to note that:
                    •  the set of bad T-vertices can only increase;
                    •  the current binary subtree of T avoids bad T-vertices;
                    •  the T-vertices excluded from the binary subtree will never be added to it 
                       again (so the extension of /  will not contradict the old values).
                 All these properties are direct consequences of the construction.  (The last one: 
             if a T-vertex was excluded, one of its ancestors was bad at the moment, it remains 
             bad, and the binary subtree can never use it again.)
                 It remains to prove that (for /  constructed in this way) every sequence a € fl 
             has  an  /-preimage outside  U.  By  definition,  at  any  stage t  of the  construction 
             there exists /-preimage ojt that is not covered by the already discovered part of U. 
             Moreover, as t increases, the points ojt converge to some limit sequence oj  (we prove 
             the stabilization property at level i by induction over i\  note that the number of 
             possible changes on level i is bounded by 2ki).  It remains to verify that oj  does not 
             belong to U and that f(oj) = a.
                 By way of contradiction,  assume  that  oj  is  in  U.  Then  oj  belongs  to  some 
             interval that is discovered on some step.  After that the sequences ojt do not belong 
             to this interval—a contradiction with the convergence.
                 Finally,  let us verify that  f(oj) = a.  Let 2 be an arbitrary finite prefix of a. 
             We have to show that f(oj) starts with z.  Let к be the length of 2.  At every stage t 
             there exists a /г-block string (a level к vertex of T) that is mapped to z.  When t 
             increases, this string ultimately reaches its final value and therefore oj  has a prefix 
             that guarantees that f(oj) starts with z.                                           □
                  190        Prove that the random sequence constructed in the proof is computable 
             given both the oracles for a and for O' (the halting problem).
                 (Hint:  The limit position of the embedded binary tree is computable given O'.)
