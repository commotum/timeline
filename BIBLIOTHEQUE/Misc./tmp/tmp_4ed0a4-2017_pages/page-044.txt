                      1.  PLAIN  KOLMOGOROV  COMPLEXITY
        28
           (a)  Prove that  the the set  {(x,k)  |  C{x)  <  k}  (the upper graph of C)  is an 
        r-separable set.  The set of compressible strings is r-separable, too.
           {Hint-.  Assume that the upper graph of C is disjoint with some enumerable set 
        V.  The set of the second components of pairs in V is finite, otherwise we get an 
        unbounded computable lower bound for C.  That is, V is included in a horizontal 
        strip of finite height.  The intersection of the strip with the upper graph is finite.)
           (b) We say that a set U\ is m-reducible to a set U2 if there is a total computable 
        function /  such that U\  = f~1{U2).  Prove that if U2 is r-separable and U\  is m- 
        reducible to [/2, then U\  is r-separable as well.
           {Hint:  If V is an enumerable set disjoint with U\, then /(V) is an enumerable 
        set disjoint with U2 .  If R is a decidable set separating /(V) and U2, then f~1{R) 
        is a decidable set separating V and U\.)
          (c)  Prove that  there is an enumerable set  that is not r-separable  (such a set 
        does not m-reduce to the upper graph of C).
          {Hint:  There is a pair of disjoint enumerable inseparable sets.)
           13 Following [74], prove that the following problems are equivalent:  “for a 
        given integer n find some string of complexity at least n” and “for a given algorithm 
        without input find some string that is different from its output”  (if the algorithm 
        does not terminate, any string is OK). An oracle that fulfills one of these tasks can 
        be used to (effectively) fulfill the other.
          {Hint:  Given an algorithm, we can provide an upper bound for the complex­
        ity  of its  output—it  is  bounded  by complexity  (and therefore the length)  of the 
        algorithm itself.  On the other hand, to provide a string of high complexity means 
        to provide a string which is guaranteed to be different from the outputs of finitely 
        many algorithms.  At first, this looks like a more difficult task than for one algo­
        rithm (as the oracle does).  However, the following trick helps:  we may assume that 
        the outputs  are tuples  and construct  a tuple that  differs  from  the output  of ith 
        algorithm in ith position.)
           14  (Continued) Prove that both these problems are equivalent to the problem 
        of computing a fixed-point free function:  “for every algorithm construct  another 
        algorithm that computes a different function”  (not the same as the first one).
           15 (Continued) Prove that an enumerable oracle can solve these problems if 
        and only if it solves the halting problem  (M. Arslanov proved this result without 
        using Kolmogorov complexity).
          {Hint:  Assume that an enumerable oracle A allows us to compute strings of 
        arbitrarily high complexity.  Then let us compute a string of complexity at least n 
        using this oracle,  and look at  all elements of A that were questioned during this 
        computation.  How many steps are needed to enumerate all this elements?  This is 
        a big number:  any T greater than this number, has Kolmogorov complexity of at 
        least n, since T-approximation of A can be used instead of A.  On the other hand, 
        having an oracle for A, we can find T for a given n.)
          Kolmogorov  complexity  and  functions  В  and  BB  turn  out  to  be  useful  in 
        studying  the  so-called  “generic”  and  “coarse”  algorithms  that  solve  the  halting 
        problem for most inputs  (the fraction of errors converges to zero);  see  [11].  The 
        versions of these functions based on prefix complexity were introduced by Gâcs [57]; 
        see  also  [4]  for  recent  results  related  to  the  busy  beaver  functions  for  different 
        versions of Kolmogorov complexity.
