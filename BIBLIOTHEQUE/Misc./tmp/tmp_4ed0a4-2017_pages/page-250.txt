                             8.3.  FINITE  AUTOMATA WITH SEVERAL HEADS               237
               Proof.  For each m ^ 1, consider the language Lm that consists of all strings
                                      Wl# •             ■■■Wi
            (for  any  binary strings w\,..., wm).  Each wt  is repeated twice,  and in the right 
           half the strings Wi go in reverse order (this is crucial for the argument).
               A /с-head automaton can recognize this language if m is not very large (is at 
           most  (2),  see below).  One of the heads goes to the right half,  and the remaining 
           к — 1 heads are placed before w i,..., Wk-i■  Then each of these к — 1 heads checks 
           its string while the first head crosses its copy.  After that the first к — 1 strings are 
           checked,  the first head is of no use  (it is at the end of the input string),  but the 
           remaining к —I heads are useful since they are on the left of the remaining strings 
           Wk,Wk+1,....  Now we repeat the same trick:  one of the к — 1 heads is sent across 
           the right half, к — 2 heads check the next к — 2 strings, etc.  Repeating this, we can 
           check
                            (*_1) + (t_ 2) + ... + 1 = *(*^) = (*)
           strings.  (Note that m is fixed, so for finding a substring with a given number, the 
           finite memory is enough.)
               Therefore, the language Lm can be recognized by a к-head automaton ifm ^ (2).
               It  remains to show that if m >  (2),  the  language Lm  cannot be recognized by 
           a  к-head  automaton.  Assume that is  not  the case  and some  fc-head  automaton 
           M recognizes this language.  To get a contradiction,  let us consider independent 
           random strings W\,..., wm of sufficiently large length N.  More formally, consider 
           a string of length mN and complexity at least mN and split it into m strings of 
           length N denoted by wi,..., wm.  By assumption, the string
                                    W = W 1# ■ • ■ WmftWm# ---Wi
           is accepted by M; we get a contradiction by showing that either w\ • • • wm is com­
           pressible or the automaton does not recognize Lm.
               Let us say that a given pair of heads of M visited Wi if at some moment (while 
           processing W by M) these heads were simultaneously inside two copies of wi.  A key 
           observation:  a given pair of heads cannot visit both Wi  and Wj for i ^ j.  Indeed, 
           consider the moment when Wi was visited.  After that the left head reads only Wj 
           with j > i and the right head visits only Wj with j < i.
               By our assumption m > (2) ; therefore there exists i such that Wi is not visited 
           by any pair of heads.  Let us show that either Wi is compressible or one of its copies 
           can be counterfeited in such a way that M will still accept the string (so M does 
           not work correctly).
               Let us observe the actions of M on W.  Special attention is needed when one 
           of the heads enters or leaves Wi  (any of two copies):  We write down the positions 
           of all heads and the state of M at these moments.  The obtained  “log-file”  P has 
           complexity O(logA^) where the hidden constant depends on k, m, and the number 
           of states in M but not on N.  Indeed, there are at most 4к moments to consider 
           (four per head) and at each moment we record the state of the automaton and head 
           positions, and this requires O(logA^) bits.
               Let us show that (if M recognizes Lm correctly) the string Wi can be uniquely 
           reconstructed if all other Wj  (with j /  i) and P are given.  This would imply that 
           the complexity of the string w\ ■ ■ ■wm does not exceed  (m — 1)A^ (the number of
