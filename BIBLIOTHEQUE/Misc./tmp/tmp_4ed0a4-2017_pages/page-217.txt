             204                    6.  GENERAL SCHEME  FOR COMPLEXITIES
             K(a0 ■ ■ • а,г-1 I n) ~ 0(1).  Note that Theorem 72 characterizes plain complexity in 
             terms of conditional prefix complexity.
                  6.4.2.      Complexity  with  large  numbers  as  conditions.  Let us define a 
             new type of conditional complexity, i.e., the complexity of a string x relative to the 
             set A.  Informally speaking, we want to measure the complexity of the task,  “obtain 
             x given an arbitrary element of A”.  This complexity has several equivalent (up to 
             0 (1)) definitions.
                  Here is one of them.  Fix some reasonable programming language.  (Formally 
             speaking,  “reasonable”  means that the numbering corresponding to this language 
             is  a  Gödel  numbering,  i.e.,  there  exists  a  translation  algorithm  from  any  other 
             programming language,  see  [184]  for details.)  Now let  us define the conditional 
             complexity of an object x with condition A  as the minimal  (plain)  Kolmogorov 
             complexity of a program that maps  every element of A into x.  (A generalization 
             of this definition is considered in Chapter 13.)
                  The existence of a translation  algorithm  guarantees  that  this  notion  is  well 
             defined, i.e., that the complexity defined in this way does not depend on the choice 
             of a programming language (Gödel numbering).
                  One should not mix this complexity with a completely different notion:  a con­
             ditional complexity of x with condition A, where the finite set A is given as a finite 
             object (say, as the list of its elements).  In our case we do not get the list of all ele­
             ments of A, but only one of them, and we should be prepared to deal with arbitrary 
             elements of A.  To stress this distinction, we use the notation C(x || A) for the new 
             complexity (while C(x \ A) denotes the condition complexity of x if a finite set A is 
             given as a list of its elements).
                 A different  (but equivalent) definition of C(x || A) can be given as follows.  Let 
             D  (decompressor)  be a computable partial function of two arguments.  Let x be 
             a binary string,  and let  A be a set of binary strings.  We define Cd{x\\ A)  as the 
             minimal length of a string p such that D(p,y) = x for every y G A.
                  206         Prove that there exists an optimal decompressor in this class (that gives 
             the minimal function Cd(-||-)  up to an  0(l)-additive term).  Prove that Cd  for 
             optimal D coincides (up to an O(l)-tenn) with the complexity defined above.
                 For a singleton A = {a}, both the complexities C(x\ A) and C(x\\A) coincide 
             with the standard conditional complexity C(x\a)  up to an 0(l)-term (see Prob­
             lem 28).
                 Now let  A  be  the  set  of all  integers  greater  than  some  (presumably)  large 
             number n.  (As usual, we identify natural numbers with binary strings.)  The com­
             plexity of a string x with respect to this set is denoted by C(x\\  ^ n).  Obviously, 
             this complexity does not exceed C(x) and is a non-increasing function of n  (and, 
             more generally, C(x\\ A) can only decrease if A becomes smaller; it becomes 0(1) 
             for the empty set A).  So there exists some limit as n       oo.
                 Theorem 131.
                                        lim  C(x II  ^ n) — C° (x) + 0(1).
                                       n —>oо
                 Proof.  Assume that the limit  equals  k.  Then there exists a program p of 
             complexity к that maps all sufficiently large numbers to i.  If an oracle O' is avail­
             able,  this program can be considered as a O'-description of x.  Indeed,  given this 
             program, we search for N and у such that p does not map any n ^ N into an object
