                                                              2.2.    CONDITIONAL COMPLEXITY                                                           35
                           Here g and / are arbitrary computable functions (of one and two arguments, 
                    respectively) and the inequalities are valid if f{x,y) and g(y) are defined.
                           Proof.  First inequalitj':  Any unconditional decompressor can be considered 
                    as a conditional one that ignores the second argument.
                           Second inequality:  Consider D such that D(p, z) — z.
                          Third inequality:  Let D be the optimal conditional decompressor used to define 
                    complexity.  Consider another decompressor D' such that
                                                                   D'[p, y) = f(D(p,y),y),
                    and apply the optimality property.
                          A similar argument works for the last inequality, but D' should be defined in 
                    a different way:
                                                                     D'{p,y) = D(p,g(y)).
                    The theorem is proven.                                                                                                             □
                            25             Prove that conditional complexity is “continuous as a function of its second 
                    argument”:  C(x\yO) — C(x\y) + 0(1);  C(x\yl) — C(x\y) + 0(1).  Using this 
                    property, show that for every string x and for every non-negative integer I ^ C(x) 
                    there exists a string y such that C(x\y) — I + 0(1).
                          A similar argument based on two-dimensional topology is used in [156].
                            26 Prove that for any fixed y the function x                                 C(x \ y) differs from C at most
                    by 2C(p) + 0(1).
                            27 Prove that C([x, z] \ [y, z])  ^  C(x\y) + 0(1)  for any strings x,y,z  (here
                           stands for the computable encoding of pairs).
                            28 Fix some “reasonable”  programming language.  (Formally, we require the
                    corresponding universal function to be a Gödel one.  This means that a translation 
                    algorithm exists for any other programming language; see, e.g., [184].)  Show that 
                    the conditional complexity C(x\y)  is equal  (up to an 0(1)  additive term) to the 
                    minimal complexity of a program that produces output x on input y.
                          (Hint:  Let D be an optimal conditional decompressor.  If we fix its first argu­
                    ment p, we get a program of complexity at most l(p) + 0(1).  On the other hand, 
                    if program p maps y to x, then C(x\y) = C(p(y)\y) ^ C(p) + 0(1).)
                          This  interpretation  of conditional  complexity  as  a  minimal  complexity  of a 
                    program with some property will be considered in Chapter 13.
                          If we restrict  ourselves  to  total  programs  (that  terminate  on  all  inputs),  we 
                   get an essentially different notion of conditional complexity that can be called total 
                    conditional complexity.
                            29 Show that the notion of total conditional complexity CT(x \ y), the minimal 
                    (plain)  complexity of a total program  that  maps  y  to  x,  is  well  defined  (i.e.,  it 
                    changes at most by 0(1) when we change the programming language in a reasonable 
                   way).  Prove that
                                                                C(x\y)^CT(x\y)^C(x)
                   with 0(l)-precision.
                           30  Show that the total complexity sometimes exceeds significantly the usual
                   conditional complexity:  for every n there exist two n-bit strings x and y such that 
                                                         C(x\y) — 0(1) while CT(x\y) ^ n.
