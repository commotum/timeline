                                                Syntax-Guided Synthesis
                                 †                        ‡                          ‡                             †                             †
                   Rajeev Alur          Rastislav Bodik            Garvit Juniwal            Milo M. K. Martin        Mukund Raghothaman
                                    ‡                    ]                                ]                     ‡                            †
                 Sanjit A. Seshia       Rishabh Singh         Armando Solar-Lezama              Emina Torlak              Abhishek Udupa
                  †University of Pennsylvania           ‡University of California, Berkeley            ]Massachusetts Institute of Technology
                Abstract—The classical formulation of the program-synthesis       the potential of even greater impact on software quality than
             problem is to ﬁnd a program that meets a correctness speciﬁca-       program veriﬁcation. Classically, program synthesis is viewed
             tion given as a logical formula. Recent work on program synthesis    as a problem in deductive theorem proving: a program is
             and program optimization illustrates many potential beneﬁts          derived from the constructive proof of the theorem that states
             of allowing the user to supplement the logical speciﬁcation          that for all inputs, there exists an output, such that the desired
             with a syntactic template that constrains the space of allowed
             implementations. Our goal is to identify the core computational      correctness speciﬁcation holds (see [3]). Our work is motivated
             problem common to these proposals in a logical framework. The        by a recent trend in synthesis in which the programmer, in
             input to the syntax-guided synthesis problem (SyGuS) consists        addition to the correctness speciﬁcation, provides a syntactic
             of a background theory, a semantic correctness speciﬁcation          template for the desired program. For instance, in the pro-
             for the desired program given by a logical formula, and a            gramming approach advocated by the SKETCH system, a pro-
             syntactic set of candidate implementations given by a grammar.
             The computational problem then is to ﬁnd an implementation           grammer writes a partial program with incomplete details, and
             from the set of candidate expressions so that it satisﬁes the        the synthesizer ﬁlls in the missing details using user-speciﬁed
             speciﬁcation in the given theory. We describe three different        assertions as the correctness speciﬁcation [4]. We call such
             instantiations of the counter-example-guided-inductive-synthesis     an approach to synthesis syntax-guided synthesis (SyGuS).
             (CEGIS) strategy for solving the synthesis problem, report on        Besides program sketching, a number of recent efforts such as
             prototype implementations, and present experimental results on
             an initial set of benchmarks.                                        synthesis of loop-free programs [5], synthesis of Excel macros
                                    I. INTRODUCTION                               from examples [6], program de-obfuscation [7], synthesis of
                                                                                  protocols from the skeleton and example behaviors [8], synthe-
                In program veriﬁcation, we want to check if a program             sis of loop-bodies from pre/post conditions [9], integration of
             satisﬁes its logical speciﬁcation. Contemporary veriﬁcation          constraint solvers in programming environments for program
             tools vary widely in terms of source languages, veriﬁcation          completion [10], and super-optimization by ﬁnding equivalent
             methodology, and the degree of automation, but they all              shorter loop bodies [11], all are arguably instances of syntax-
             rely on repeatedly invoking an SMT (Satisﬁability Modulo             guided synthesis. Also related are techniques for automatic
             Theories) solver. An SMT solver determines the truth of              generation of invariants using templates and by learning [12]–
             a given logical formula built from typed variables, logical          [14], and recent work on solving quantiﬁed Horn clauses [15].
             connectives, and typical operations such as arithmetic and             Existing formalization of the SMT problem and the in-
             array accesses (see [1], [2]). Despite the computational in-         terchange format does not provide a suitable abstraction for
             tractability of these problems, modern SMT solvers are ca-           capturing the syntactic guidance. The computational engines
             pable of solving instances with thousands of variables due           used by the various synthesis projects mentioned above rely
             to sustained innovations in core algorithms, data structures,        on a small set of algorithmic ideas, but have evolved inde-
             decision heuristics, and performance tuning by exploiting            pendently with no mechanism for comparison, benchmarking,
             the architecture of contemporary processors. A key driving           and sharing of back-ends. The main contribution of this paper
             force for this progress has been the standardization of a            is to deﬁne the syntax-guided synthesis (SyGuS) problem in
             common interchange format for benchmarks called SMT-LIB              a manner that (1) captures the computational essence of these
             (see smt-lib.org) and the associated annual competition (see         recent proposals and (2) is based on more canonical formal
             smtcomp.org). These efforts have proved to be instrumental           frameworks such as logics and grammars instead of features
             in creating a virtuous feedback loop between developers and          of speciﬁc programming languages. In our formalization, the
             users of SMT solvers: with the availability of open-source           correctness speciﬁcation of the function f to be synthesized
             and highly optimized solvers, researchers from veriﬁcation           is given as a logical formula ϕ that uses symbols from a
             and other application domains ﬁnd it beneﬁcial to translate          background theory T. The syntactic space of possible im-
             their problems into the common format instead of attempting          plementations for f is described as a set L of expressions
             to develop their own customized tools from scratch, and the          built from the theory T, and this set is speciﬁed using a
             limitations of the current SMT tools are constantly exposed by       grammar. The syntax-guided synthesis problem then is to ﬁnd
             the ever growing repository of different kinds of benchmarks,        an implementation expression e ∈ L such that the formula
             thereby spurring greater innovation for improving the solvers.       ϕ[f/e] is valid in the theory T. To illustrate an application of
                In program synthesis, we wish to automatically synthesize         the SyGuS-problem, suppose we want to ﬁnd a completion of
             an implementation for the program that satisﬁes the given            a partial program with holes so as to satisfy given assertions.
             correctness speciﬁcation. A mature synthesis technology has          A typical SyGuS-encoding of this task will translate the
