              Learning program synthesis with self-improving language models: A case study on ARC-AGI
            max_i = max((c[0] for c in component))
            min_j = min((c[1] for c in component))
            max_j = max((c[1] for c in component))
            return [row[min_j:max_j + 1] for row in grid[min_i:max_i + 1]]
         rect = find_largest_rectangle(grid)
         rect_grid = extract_rectangle(grid, rect)
         if len(rect_grid) == 2 and len(rect_grid[0]) == 4:
            return rect_grid
         color = grid[rect[0]][rect[1]]
         component = find_largest_connected(grid, color)
         component_grid = extract_component(grid, component)
         return component_grid
       H.3. ARCProblem1f642eb9
       Solve the task online here, then read the program.
       def transform(grid):
         def dfs(x, y, component_num):
            if x < 0 or x >= len(grid) or y < 0 or (y >= len(grid[0])) or (grid[x][y] != 5):
              return
            grid[x][y] = component_num
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
              dfs(x + dx, y + dy, component_num)
         component_num = 1
         for i in range(len(grid)):
            for j in range(len(grid[0])):
              if grid[i][j] == 5:
                dfs(i, j, component_num)
                component_num += 1
                if component_num > 4:
                   component_num = 1
         component_map = {i: num for i, num in enumerate(range(1, component_num), start=1)}
         for i in range(len(grid)):
            for j in range(len(grid[0])):
              if grid[i][j] in component_map:
                grid[i][j] = component_map[grid[i][j]]
         return grid
       H.4. ARCProblemef26cbf6
       Solve the task online here, then read the program.
       def transform(grid):
         transformed_grid = [row[:] for row in grid]
         directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
         def in_bounds(x, y):
            return 0 <= x < len(grid) and 0 <= y < len(grid[0])
         for i in range(len(grid)):
            for j in range(len(grid[i])):
              if grid[i][j] == 8:
                for dx, dy in directions:
                   ni, nj = (i + dx, j + dy)
                   if in_bounds(ni, nj) and grid[ni][nj] != 8:
                     if grid[ni][nj] != 0:
                        transformed_grid[i][j] = grid[ni][nj]
                     else:
                        step = 1
                        while in_bounds(ni + dx * step, nj + dy * step) and grid[ni +
                                                   dx * step][nj +
                                                   dy * step] == 0:
                          step += 1
                                  27
