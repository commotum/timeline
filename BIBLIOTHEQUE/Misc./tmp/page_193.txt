180 « Unified Theories of Cognition

to only one task, following a program in memory. The Soar ar-
chitecture, on the other hand, is structured in terms of problem-
solving requirements. Its primitive actions—what corresponds to
divide and branch-on-zero—are functionally important actions in
terms of Soar’s overall behavior—selecting problem spaces, select-
ing states, selecting operators, and applying the operators. When an
impasse occurs there is @ functionally appropriate action the ar-
chitecture can take. Setting up a subgoal, which records the type of
impasse and points to the implicated objects, is analogous to the
error message. But the form it takes shows that the architecture
knows what needs to be done with it—attempt to resolve it—and
knows how to go about that—set up a subgoal that can evoke the
knowledge in the system that can guide such an attempt. The stan-
dard computer architecture not only does not have a goal structure
it can use to pose the task of resolving the impasse; even if it did,
there would be no way for it to formulate the task to be done,
because the formulation would be buried within the semantics of
the program being interpreted. Soar’s ability to define its subgoals
is one gain from casting the architecture in terms of problem spaces
and not in terms of operations and operands.

4. Operators and Context

Typical problem-solving systems in AI use search in problem
spaces in order to solve problems (often under somewhat different
guises and terminology, in accord with their total systems organiza-
tion), The typical arrangement is that the operators in a problem
space are specified in a standard procedural or functional language,
such as Lisp. Likewise, the search control to select the operators is
realized in a standard program, perhaps with essential parametric
input, such as the weights of an evaluation function. Such systems
have two layers—a problem-solving layer and a program layer. It is
important to see how Soar differs from this organization. Figure 4-9
is meant to emphasize that Soar operates in problem spaces all the
way down. Suppose Soar starts out working on a task in the top
problem space (pl). There might be several operators proposed
that cannot be differentiated—-a tie impasse. This leads Soar to set
up a problem space (p2) to make that selection. The operators of
this space evaluate the alternative operators. One is selected, but it
may not be possible to carry it out in terms of immediate knowl-

