Symbolic Processing for Intelligence = 163

step in the space. These primitive functions are the acts of delibera-
tion that this system must take. The Soar architecture is built to
accomplish these functions directly. That is all it has to do to pro-
duce behavior. Hence, it may fairly be characterized as a problem-
space architecture.

This organization can be contrasted with that of standard com-
puter architectures, as they have developed in computer science.
Such architectures take as the basic task to follow a sequence of
operations, as determined by a data structure in memory (the pro-
gram). The primitive functions are to assemble the operation to be
performed (such as multiply), to assemble the operands to be the
inputs of the operation (a multiplier and a multiplicand), to apply
the operation to the operands, to save the result (the product), and
to select the program structure to determine the next operation
(recall Figure 2-13). It is commonplace in computer science to
realize other processing organizations by programming an architec-
ture in some available operation-operand organization of the classi-
cal kind. This can certainly be done for the problem-space organiza-
tion, and it is exactly how we create a software Soar system to run
on current computers. But if the problem space is the basic organi-
zation, in that nothing but operation in problem spaces occurs, then
the primitive functions can be those of Figure 4-2 without ever
dropping into another computational engine organized in some
other way. The four functions in Figure 4-2 must be genuinely
primitive; and much of the rest of architecture is devoted to accom-
plishing these functions.

It is standard in AI to use search spaces when problems are
difficult (Rich, 1983). When tasks are routine, however, the stan-
dard practice is to formulate them as the behavior specified by a
program in a language that permits sequential and procedural con-
trol, or, in other words, one that uses an operation-operand organi-
zation, With Soar, all behavior, however routine, is represented as
movement through a problem space. Whether search is exhibited
depends on what knowledge is available and brought to bear, If lots
of knowledge is brought to bear Soar goes right to the goal, exhib-
iting routine behavior. If little knowledge is available, then Soar
may do lots of undirected and combinatorial search.

This uniform use of problem spaces as the task representation is
called the problem space hypothesis (Newell, 1980c). It is only one
of several aspects of Soar where a uniform structure or process is

