      Figure 7: DreamCoder develops languages for physical laws (starting from recursive functions) and
      recursion patterns (starting from the Y-combinator, cons, if, etc.) (A) Learning a language for physical
      laws starting with recursive list routines such as map and fold. DreamCoder observes numerical data
      from 60 physical laws and relations, and learns concepts from vector algebra (e.g., dot products) and
      classical physics (e.g., inverse-square laws). Vectors are represented as lists of numbers. Physical
      constants are expressed in Planck units. (B) Learning a language for recursive list routines starting
      with only recursion and primitives found in 1959 Lisp. DreamCoder rediscovers the “origami” basis of
      functional programming, learning fold and unfold at the root, with other basic primitives as variations
      on one of those two families (e.g., map and filter in the fold family), and more advanced primitives
      (e.g., index) that bring together the fold and unfold families.
                          15
