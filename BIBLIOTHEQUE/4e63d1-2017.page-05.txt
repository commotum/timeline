                             3.3   ANDModule
                             For implementing and we Ô¨Årst deÔ¨Åne an auxiliary function called substitute which applies substitu-
                             tions to variables in an atom if possible. This is realized via
                             1. substitute([ ],_) = [ ]
                             2. substitute(g : G,œà) =  x        if g/x ‚àà œà  : substitute(G,œà)
                                                            g    otherwise
                             For example, substitute([fatherOf,X,Z],{X/Q,Y/i}) results in [fatherOf,Q,Z].
                             The signature of and is L √ó N √ó S ‚Üí SN where L is the domain of lists of atoms and N is the
                             numberofpossible output proof states for a list of atoms with a known structure and a provided KB.
                             This module is implemented as
                                     K
                             1. and (_,_,FAIL) = FAIL
                                     Œ∏
                                     K
                             2. and (_,0,_) = FAIL
                                     Œ∏
                                     K
                             3. and ([ ],_,S) = S
                                     Œ∏
                                     K                    00    00      K          0       0     K
                             4. and (G : G,d,S) = [S | S ‚àà and (G,d,S ) for S ‚àà or (substitute(G,Sœà),d‚àí1,S)]
                                     Œ∏                                  Œ∏                        Œ∏
                             where the Ô¨Årst two lines deÔ¨Åne the failure of a proof, either because of an upstream uniÔ¨Åcation
                             failure that has been passed from the or module (line 1), or because the maximum proof depth has
                             been reached (line 2). Line 3 speciÔ¨Åes a proof success, i.e., the list of subgoals is empty before the
                             maximumproofdepthhasbeenreached. Lastly, line 4 deÔ¨Ånes the recursion: The Ô¨Årst subgoal G is
                             proven by instantiating an or module after substitutions are applied, and every resulting proof state
                             S0 is used for proving the remaining subgoals G by again instantiating and modules.
                             Example ContinuingtheexamplefromSection3.2, the and module would instantiate submodules
                             as follows:
                                 K                                                         ÀÜ
                             and ([[fatherOf,X,Z],[parentOf,Z,Y]],d,({X/Q,Y/i},S )) =
                                 Œ∏                                          |       {z      œÅ}
                                                                             result of unify in or
                                    00  00      K                         0       0     K                                         ÀÜ
                                  [S |S ‚ààand ([[parentOf,Z,Y]],d,S )forS ‚àà or ([fatherOf,Q,Z],d‚àí1,({X/Q,Y/i},S ))]
                                                Œ∏                                       Œ∏ |       {z      }        |       {z      œÅ}
                                                                                             result of substitute   result of unify in or
                             3.4   Proof Aggregation
                             Finally, we deÔ¨Åne the overall success score of proving a goal G using a KB K with parameters Œ∏ as
                                                                   K
                                                               ntp (G,d) =          argmax        SœÅ
                                                                   Œ∏
                                                                               S ‚àà orK(G,d,(‚àÖ,1))
                                                                                      Œ∏
                                                                                    S6=FAIL
                             wheredisapredeÔ¨Ånedmaximumproofdepthandtheinitialproofstateissettoanemptysubstitution
                             set and a proof success score of 1.
                             Example Figure2illustrates an examplary NTP computation graph constructed for a toy KB. Note
                             that such an NTP is constructed once before training, and can then be used for proving goals of the
                             structure [s,i,j] at training and test time where s is the index of an input predicate, and i and j are
                             indices of input constants. Final proof states which are used in proof aggregation are underlined.
                             3.5   Neural Inductive Logic Programming
                             WecanuseNTPsforILPbygradientdescent instead of a combinatorial search over the space of
                             rules as, for example, done by the First Order Inductive Learner (FOIL) [32]. SpeciÔ¨Åcally, we are
                             using the concept of learning from entailment [9] to induce rules that let us prove known ground
                             atoms, but that do not give high proof success scores to sampled unknown ground atoms.
                             Let Œ∏r:,Œ∏s:,Œ∏t: ‚àà Rk be representations of some unknown predicates with indices r,s and t respec-
                             tively. The prior knowledge of a transitivity between three unknown predicates can be speciÔ¨Åed via
                                                                                 5
