                                                                                                      Input v       Output
              be explained by synthesizing a distinguishing input on which                                   1
              the transformations behave diÔ¨Äerently [11]. After receiving                             Peter Shaw    110
              the correct output from the user on the distinguishing in-                              Gary Lamb     225
              put, the synthesizer can repeat the learning process with                               Mike Henry    2015
              this additional example.                                                                Sean Riley    495
              4.    LOOKUPTRANSFORMATIONS                                                   CustData                          Sale
                                                                                   Name          Addr    St        Addr   St     Date    Price
                 In this section, we present a lookup transformation lan-          Sean Riley    432     15th      24     18th   5/21    110
              guage Lt that can model transformations that involve map-            Peter Shaw    24      18th      104    12th   5/23    225
              ping a tuple of strings to another string using (possibly            Mike Henry    432     18th      432    18th   5/20    2015
              nested) lookup operations over a given database of relational        Gary Lamb     104     12th      432    15th   5/24    495
              tables. We Ô¨Årst present the syntax and semantics of Lt and           ¬∑ ¬∑ ¬∑         ¬∑ ¬∑ ¬∑   ¬∑ ¬∑ ¬∑     ¬∑ ¬∑ ¬∑  ¬∑ ¬∑ ¬∑  ¬∑ ¬∑ ¬∑   ¬∑ ¬∑ ¬∑
              then present a data structure D to succinctly represent a
                                                t                                 Figure 2: A lookup transformation that requires
              large set of expressions in the language. We then present           joining two tables.
              an eÔ¨Écient synthesis algorithm to learn a set of transforma-
              tions in Lt from a set of input-output examples, such that          Consider the case of m = 4. Let e ‚â° Select(C ,T ,C =
              each of the learned transformations when run on the given                                                             2   1  1
                                                                                  v ) that produces string s . Two possible expressions in L
              inputs produces the corresponding outputs.                           1                         2                                t
                                                                                  toobtainoutputs frominputs are: (i)e ‚â° Select(C ,T ,
              4.1    LookupTransformationLanguageL                                                  4             1          1             3  2
                                                                     t            C = e) (corresponding to path s ‚Üí s ‚Üí s ) and (ii)
                                                                                   1                                  1      2      4
                 ThesyntaxofourexpressionlanguageL forlookuptrans-                e2 ‚â° Select(C2,T3,C1 = Select(C2,T2,C1 = e)) (corre-
                                                         t                        sponding to path s ‚Üí s ‚Üí s ‚Üí s ). The expressions
              formations is deÔ¨Åned in Figure 3(a). An expression et is                                1      2     3      4
                                                                                  e and e share the common sub-expression e which corre-
              either an input string variable vi, or a select expression           1       2
                                                                                  sponds to obtaining the intermediate string s .
              denoted by Select(C,T,b), where T is a relational table                                                            2
              identiÔ¨Åer and C is a column identiÔ¨Åer of the table. The
              Boolean condition b is an ordered conjunction of predicates         4.2    DataStructureforSetofExpressionsinL
              p ‚àß... ‚àß p where predicate p is an equality comparison                                                                          t
               1          n                                                         The set of expressions in language L that are consistent
              between the content of some column of the table with a                                                      t
              constant or an expression. We place a restriction on the            with a given input-output example can be exponential in
              columns present in these conditional predicates namely that         the number of reachable table entries. We represent this set
                                                                                  succinctly using the data structure D , which is described
              these columns together constitute a candidate key of the ta-                                               t
              ble. The main idea behind this restriction is that we want          in Figure 3(b). The data structure consists of a generalized
                                                                                                                                 Àú
                                                                                  expression eÀú , generalized Boolean condition b, and gener-
              to express queries that produce a single output as opposed                      t
                                                                                  alized predicate pÀú (which respectively denote a set of L
              to a set of outputs. The ordering of predicates results in an                                                                   t
              eÔ¨Écient intersection algorithm as described in ¬ß4.3.                expressions, a set of Boolean conditions b, and a set of pred-
                 The language L has expected semantics. The expression            icates p). The formal semantics [[.]] of the data structure is
                                 t                                                described in Figure 3(c). The generalized expression eÀú is
              Select(C,T,b) returns the table entry T[C,r], where r is                                                                      t
              the only row that satisÔ¨Åes condition b (as condition b is over      represented using a tuple (Œ∑Àú,Œ∑t,Progs) where Œ∑Àú is a set of
              candidate keys of the table). If there exists no row r whose        nodes containing a distinct target node Œ∑t (representing the
                                                                                                                      Àú
              columns satisfy b, the expression returns the empty string                                              f
              . The predicate C = e is evaluated for row r by Ô¨Årst eval-         output string), and Progs : Œ∑Àú ‚Üí 2    maps each node Œ∑ ‚àà Œ∑Àú
                                      t                                           to a set consisting of input variables vi or generalized select
              uating the expression e and then comparing the returned             expressions Select(C,T,B). A generalized select expression
                                       t
              string [[et]]œÉ with the string T[C,r].                                                                             Àú
                                                                                  takes a set of generalized Boolean conditions bi as the last
                 We now present an example taken from an Excel help-                                     Àú
                                                                                  argument, where each bi corresponds to some candidate key
              forum that can be represented in L .                                                                        Àú
                                                   t                              of table T. A generalized conditional b is a conjunction of
                                                                                  generalized predicates pÀú , where each pÀú is an equality com-
                 Example 2. An Excel user was working on two tables:                                      i               i
              CustData and Sale. The user wanted to map names of cus-             parison of the jth column of the corresponding candidate key
              tomers to the selling price using address and street num-           with a constant string s or some node Œ∑Àú or both. There are
              ber columns as common columns between the two tables and            two key aspects of this data structure which are explained
              posted the example shown in Figure 2 on a help-forum.               below using some worst-case examples.
                 The transformation can be expressed in L as                      Use of intermediate nodes in Œ∑Àú for sharing: Con-
                                                            t                     sider the problem in Example 3. The set of all transfor-
               Select(Price,Sale,Addr = Select(Addr,CustData,                     mations in L that are consistent with the example s ‚Üí s
                  Name = v )‚àßSt = Select(St,CustData,Name = v )).                              t                                       1     m
                           1                                         1            can be represented succinctly using our data structure as:
                 Thesurface syntax of L allows sharing of sub-expressions
                                         t                                        {{Œ∑ ,...,Œ∑ },Œ∑ ,Progs}, where Progs[Œ∑ ] = {Select(C ,
              (which is the key principle used in data structure D de-               1       m    m                         i               2
                                                                       t          T   , {C = {s     , Œ∑  }}),Select(C ,T      , {C = {s     ,
              scribed in ¬ß4.2). To appreciate this, consider the following         i‚àí1    1      i‚àí1  i‚àí1               3  i‚àí2    1      i‚àí2
                                                                                  Œ∑   }})}, Progs[Œ∑ ] = {v }, and Progs[Œ∑ ] = {Select(C ,T ,
              example, which is also our running example in this section.          i‚àí2              1      1               2               2  1
                                                                                  {C = {s ,Œ∑ }})}. The node Œ∑ essentially corresponds to
                                                                                     1      1  1                   i
                 Example 3. Consider m tables T to T , each contain-              the string s .  Figure 4 illustrates how the various nodes
                                                    1     m                                   i
              ing three columns C , C , and C with C being the primary            can be reached or computed from one another. Let N(i)
                                  1    2       3        1
              key. Suppose table T contains a row (s ,s        ,s   ). Now        denote the number of expressions represented succinctly by
                                    i                    i  i+1 i+2
              given an input-output example s ‚Üí s , we want to com-               Progs[Œ∑ ]. We have N(i) = 2 + N(i-1) + N(i-2), imply-
                                                1      m                                  i
              pute all expressions in L that are consistent with it.                                    i
                                        t                                         ing that N(i) = Œò(2 ). Observe how our data structure
                                                                             743
