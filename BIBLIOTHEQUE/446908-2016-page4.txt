                     Example 4. A user posted the following spreadsheet on
                 StackOverﬂow, where the user wanted to extract the infor-                                                                          Learnt  Transformation
                 mation (of varying length) that was present between two                              a    a                           Synthesis
                                                                                                       1    2        I/O examples     Algorithm
                 strings "nextData" and "moreInfo" as shown in Figure 4.                              b    b         (a ,a )  o                            a    a    o
                                                                                                       1    2          1  2     1                            1    2     1
                                                                                                      c    c                           InputDataGraph       b1   b2   o2
                                                                                                       1    2
                                           Input v1                            Output                 d    d                                                c    c    o
                                                                                                       1    2               GenInputGraph                    1    2     3
                   1         nextData 12 Street moreInfo 35                   12 Street                                                                     d1   d2   o4
                   2           nextData Main moreInfo 36                         Main                   Spreadsheet Data                                 Resulting Spreadsheet
                   3      nextData Albany Street moreInfo 37
                   4    nextData 134 Green Street moreInfo 39                                       Figure 5: An overview of our approach in BlinkFill.
                 Figure 4: Extracting message between the constant                                  consistent with any substring of these strings. This is chal-
                 strings "nextData" and "moreInfo".                                                 lenging because of two reasons: 1) there are a huge number
                                                                                                    of token sequences that are consistent with the quadratic
                    The transformation in this example cannot be learnt by                          number of substrings of a single string, and 2) there are
                 FlashFillsinceitislimitedbyaﬁnitepredeﬁnedlistofreg-                               exponentially many possible alignments of the strings in a
                 ular expression tokens and does not consider constant string                       column. A na¨ıve approach would ﬁrst enumerate exponen-
                 based tokens such as "nextData". BlinkFill, however, is                            tially many token sequences for each string in a column, and
                 not limited by a ﬁnite list of tokens, and considers diﬀerent                      then compute all matching sub-sequences in double expo-
                 possible logical structures in the input strings including all                     nential time. We present a data structure InputDataGraph
                 possible combinations of constant string tokens and regular                        that succinctly represents a large number of token sequences
                 expression tokens. It learns the substring expression to ex-                       that are consistent with a set of input strings, and can be
                 tract the desired substring whose left and right indices are                       constructed eﬃciently in practice.
                 deﬁned by the logics end of 1stConstantStr(" nextData ")
                 and start of 1stConstantStr(" moreInfo ”), with StartT                                 Definition 2. An InputDataGraph G = (V,E,I,L) is a
                           st
                 and −1 Digits◦EndT as contexts respectively.                                       4-tuple where V denotes the set of nodes, E denotes the set
                                                                                                    of edges corresponding to a set of ordered node pairs, I :
                                                                                                    V →{(id,idx) } is a labeling function that labels each node
                 4.     OVERVIEWOFTHEAPPROACH                                                                          i i
                    Weﬁrstdeﬁnetheabstractsemi-supervisedPBEproblem.                                with a set of string id and index pair (id,idx), and L : E →
                 LetDdenotethesetofdataitems,I = {(i ,o ),··· ,(i ,o )}                             {(τ,k)i}i maps each edge to a list of token matches.
                                                                      1   1          n n
                 denote the set of n input-output examples, and L denote the                           The nodes in an InputDataGraph correspond to diﬀerent
                 DSL that deﬁnes the possible space of programs. The tra-                           indices of a set of strings, where the indices are represented
                 ditional PBE techniques solve the following problem: ∃P ∈                          using the labeling function I. An edge between two nodes
                 L ∀(i,o) ∈ I : P(i) = o, i.e. ﬁnd a program P in DSL L                             v1 and v2 in the graph represents all token matches that
                 that is consistent with all input-output examples. The semi-                       match the substrings corresponding to the indices of the
                 supervised approach also takes into account the dataset D                          two nodes. The token matches on an edge are represented
                 for learning the program and solves the following constraint:                      using the edge labeling function L. A path in the graph
                 ∃P ∈ L ∀(i,o) ∈ I : P(i) = o ∧ SubExpr(P) ⊆ G(D,L),                                between two nodes represents a sequence of token matches
                 where G(D,L) denotes a data structure that represents a                            that match the corresponding substrings. In this manner,
                 set of sub-expressions in L and SubExpr(P) denotes the set                         an InputDataGraph represents an exponential number of se-
                 of sub-expressions of P. For a sound and complete synthe-                          quence of token matches succinctly using polynomial space.
                 sis algorithm, we require that the data structure G(D,L)                              Consider the input strings: {"1 lb", "23 g", "4 tons",
                 consists of all sub-expressions in L that are consistent with                      "102 grams", "75 kg"}. The InputDataGraph G for the
                 each data item in the dataset D.                                                                                                                   1
                                                                                                    input string "1 lb" is shown in Figure 6(a). We have G =
                    An overview of our instantiation of the semi-supervised                                                                                                1
                                                                                                    (V ,E ,I ,L ), whereV = {v ,v ,v ,v ,v ,v ,v }, andE =
                 PBEapproachinBlinkFill is shown in Figure 5. The syn-                                 1   1   1   1             1       0   1   2   3   4   5   6          1
                                                                                                    {(v ,v )|j > i ∧ v ∈ V ∧ v ∈ V }. The node labeling
                 thesis algorithm takes two kinds of inputs: 1) the traditional                         i   j               i       1     j       1
                                                                                                    function I (v ) = {(1,i)} for all v ∈ V , where 1 is the
                 input-output examples given by users in the form of a set of                                     1   i                           i      1
                 tuples of spreadsheet rows and the corresponding outputs,                          unique identiﬁer assigned to the string "1 lb". The edge
                                                                                                    labeling function L for each edge is shown in the ﬁgure, e.g.
                 and 2) the InputDataGraph. The GenInputGraph module                                                        1
                                                                                                    L (v ,v ) = {(d,1),(d,-1),(αn,1)(αn,-1),("1",1),("1",-1)}
                 uses the spreadsheet data to construct the InputDataGraph                            1   1   2
                                                                                                    andL (v ,v ) = {("1 ",1),("1 ",−1)}. Similarly, thegraph
                 that succinctly represents the set of all logical patterns that                           1   1   3
                 are shared across the spreadsheet data. The synthesis al-                          for the input string "23 g" is shown in Figure 6(b).
                 gorithm then uses the InputDataGraph to eﬃciently learn a                          5.1      Generation of InputDataGraphs
                 programintheDSLthatisconsistentwiththeinput-output                                    Given a set of n input rows each consisting of k columns,
                 examples, and executes it on the spreadsheet data to com-                          the GenInpDataGraph algorithm constructs the correspond-
                 pute the outputs for the remaining spreadsheet rows.                               ing InputDataGraph G as shown in Figure 7. The key idea of
                 5.     INPUTDATAGRAPHS                                                             the algorithm is to ﬁrst construct a graph for each spread-
                                                                                                    sheet column, and then return the union of these graphs
                    Given a set of strings in a spreadsheet column, our goal                        as the resulting graph for the spreadsheet data. Given a
                 is to learn the set of all logical patterns (in a DSL) that are                    column of string values, it uses the GenGraphStr algorithm
                                                                                              819
