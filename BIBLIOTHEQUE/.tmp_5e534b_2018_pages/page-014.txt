                                         PublishedasaconferencepaperatICLR2019
                                         APPENDIXC UTWITHDYNAMICHALTING
                                         WeimplementthedynamichaltingbasedonACT(Graves,2016)asfollowsinTensorFlow. IneachstepoftheUT
                                         withdynamichalting,wearegiventhehaltingprobabilities,remainders,numberofupdatesuptothatpoint,and
                                         thepreviousstate(allinitializedaszeros),aswellasascalarthresholdbetween0and1(ahyper-parameter). We
                                         thencomputethenewstateforeachpositionandcalculatethenewper-positionhaltingprobabilitiesbasedonthe
                                         state for each position. The UT then decides to halt for some positions that crossed the threshold, and updates the
                                         state of other positions until the model halts for all positions or reaches a predeﬁned maximum number of steps:
                                      1 # While−loop stops when this predicate is FALSE
                                      2 # i . e .       all     ( ( p r o b a b i l i t y   < threshold ) & ( counter < max_steps)) are false
                                      3   def should_continue(u0, u1, halting_probability , u2, n_updates , u3) :
                                      4   r e t u r n   t f . reduce_any (
                                      5                           t f . l o g i c a l _ a n d (
                                      6                                   t f . l e s s ( h a l t i n g _ p r o b a b i l i t y ,    t h r e s h o l d ) ,
                                      7                                   t f . l e s s ( n_updates ,           max_steps)))
                                      8 # Do while loop iterations until predicate above is false
                                      9   ( _ ,  _, _, remainder , n_updates , new_state) = tf . while_loop(
                                     10           should_continue , ut_with_dynamic_halting , ( state ,
                                     11           step ,      halting_probability , remainders , n_updates , previous_state ))
                                                                                         Listing1: UTwithdynamichalting.
                                         Thefollowingshowsthecomputationsineachstep:
                                      1   def ut_with_dynamic_halting( state , step , halting_probability ,
                                      2                                                           remainders , n_updates , previous_state ) :
                                      3          # Calculate the probabilities based on the state
                                      4          p = common_layers. dense( state , 1, activation=tf .nn. sigmoid ,
                                      5                   use_bias=True)
                                      6          # Mask for inputs which have not halted yet
                                      7           still_running = tf . cast (
                                      8                   t f . l e s s ( h a l t i n g _ p r o b a b i l i t y , 1 . 0 ) ,    t f . f l o a t 3 2 )
                                      9          # Mask of inputs which halted at this step
                                     10           new_halted = tf . cast (
                                     11                   t f . g r e a t e r ( h a l t i n g _ p r o b a b i l i t y   + p ∗ still_running , threshold ) ,
                                     12                           t f . f l o a t 3 2 )   ∗ still_running
                                     13          # Mask of inputs which haven’t halted , and didn ’t halt this step
                                     14           still_running = tf . cast (
                                     15                   t f . l e s s _ e q u a l ( h a l t i n g _ p r o b a b i l i t y   + p ∗ still_running ,
                                     16                           t h r e s h o l d ) ,   t f . f l o a t 3 2 )   ∗ still_running
                                     17          # Add the halting probability for this step to the halting
                                     18          # probabilities for those inputs which haven’t halted yet
                                     19           halting_probability += p ∗ still_running
                                     20          # Compute remainders for the inputs which halted at this step
                                     21           remainders += new_halted ∗ (1 − halting_probability )
                                     22          # Add the remainders to those inputs which halted at this step
                                     23           halting_probability += new_halted ∗ remainders
                                     24          # Increment n_updates for all inputs which are still running
                                     25           n_updates += still_running + new_halted
                                     26          # Compute the weight to be applied to the new state and output :
                                     27          #       0 when the input has already halted ,
                                     28          #       p when the input hasn’t halted yet ,
                                     29          #        t he    remainders when it halted this step .
                                     30           update_weights = tf . expand_dims(p ∗ still_running +
                                     31                                                                           new_halted ∗ remainders , −1)
                                     32          # Apply transformation to the state
                                     33           t r a n s f o r m e d _ s t a t e   = transition_function ( self_attention ( state ))
                                     34          # Interpolate transformed and previous states for non−halted inputs
                                     35           new_state = (( transformed_state ∗ update_weights) +
                                     36                                     ( previous_state ∗ (1 − update_weights)))
                                     37           step += 1
                                     38           r e t u r n   ( t r a n s f o r m e d _ s t a t e ,   step ,      halting_probability ,
                                     39                           remainders , n_updates , new_state)
                                                                Listing2: ComputationsineachstepoftheUTwithdynamichalting.
                                                                                                                 14
