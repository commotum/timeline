     review articles
            Figure 1. Architecture of SyGuS solver.                                                          Solving Sygus
                                                                                                             Given a set Exp of expressions speci-
                                  Initial                                                                    fied using a grammar, and a logical 
                                examples                                                                     formula  Spec that constrains the 
                                                                                                             desired function f, the SyGuS problem 
                                                                                                             is to find an expression e in Exp such 
                                                     Candidate                                               that the formula Spec[f/e] obtained by 
                                                    expression                                               replacing f with e in Spec is valid or 
                                 Learner                                   Veriﬁer                           report failure if no such expression 
                                                 Counterexample                                              exists. This search involves an alter-
                                                                                                             nation of quantifiers: there exists an 
                                                                                                             expression e in Exp such that for all 
                                   Fail                                    Success                           inputs, Spec[f/e] holds. The architec-
                                                                                                             ture underlying current solvers 
                                                                                                             involves a cooperation between a 
            Figure 2. Illustrative execution of CEGIS.                                                       learning module that searches for a 
                                                                                                             candidate expression and a verifica-
                              Iteration    Candidate expression        Counterexample                        tion oracle that checks its validity as 
                                                                                                             explained next.
                                   1                   x                 (x = 0, y = 1)                         Counterexamples and inductive 
                                   2                   y                 (x = 1, y = 0)                      syn thesis. The architecture of a typi-
                                   3                   1                 (x = 0, y = 0)                      cal SyGuS solver is shown in Figure 1 
                                   4                x + y                (x = 1, y = 1)                                    27 for alternative querying 
                                   5          ITE((x ≤ y), y, x)           Success                           (see Seshia
                                                                                                             models). The set Examples contains 
                                                                                                             interesting inputs that the learner 
                                                                                                             uses to guide its search. This set can 
           We want to prove that if m is a non-nega-        A predicate f that satisfies all these  initially be empty. The learner is 
           tive integer then when the program ter-          conditions is an inductive invariant  tasked with finding an expression e in 
           minates j equals m + n; that is, assuming        that is strong enough to prove the cor-          Exp such that Spec[f/e] is satisfied at 
           the pre-condition m ≥ 0, the post-condi-         rectness of the program. A modern  least for the inputs in Examples. If the 
           tion j = m + n holds. To apply the standard      proof assistant for program verifica-            learner fails in this task, then there is 
           verification technology, we need to first        tion asks a user to annotate a program           no solution to the synthesis problem. 
           find a Boolean predicate f over the vari-        with such loop invariants, and then  Otherwise, the candidate expression e 
           ables i, j, m, and n, that must hold every       automatically checks whether all  produced by the learner is given to the 
           time the program control is at line num-         these conditions are satisfied.                  verifier that checks if Spec[ f/e] holds 
           ber 3. The desired predicate f (i, j, m, n)         The more ambitious task of auto-              for all inputs. If so, the current expres-
           should satisfy the following three logical       matically synthesizing loop invariants  sion e is the desired answer to the syn-
           requirements: (1) assuming the pre-con-          that satisfy the desired conditions  thesis problem. If not, the verifier 
           dition, the first time the program con-          can be formalized as a SyGuS prob-               produces a counterexample, that is, an 
                                                                 30
           trol reaches the while loop, the desired         lem.  In the above example, the func-            input for which the specification does 
           predicate f holds:                               tion  f to be synthesized takes four  not hold, and this input now is added 
                                                            integer arguments and returns a  to the set Examples to reiterate the 
                                                            Boolean value. The logical specifica-            learning phase. The learning phase is 
                                                            tion is the conjunction Pre ∧ Induct ∧           an instance of the so-called inductive 
           (2) assuming that f (i, j, m, n) holds,          Post. As a syntactic specification for  synthesis as the learner is attempting 
           and the program enters the while loop            the set of potential candidates for  to generalize based on the current set 
           (that is, the test i > 0 is satisfied), after    invariants, we choose expressions that           Examples of inputs it considers sig-
           executing the body of the loop once,             are conjunctions of linear inequalities          nificant. Since the inputs added to 
           the condition f continues to hold for            over program variables. This set is  this set are counterexamples pro-
           the updated variables:                           expressed by the grammar:                        duced by the verifier, the overall solu-
                                                                                                                                                28,29
                                                                                                             tion strategy is called CEGIS.
                                                                                                                For illustrating this strategy, let us 
                                                                                                             show a plausible sequence of itera-
                                                                                                             tions using the logical specification 
           and (3) assuming that f (i,  j,  m,  n)                                                           Spec  and the set Exp  of linear expres-
                                                                                                                  1                   2
           holds, and the program exits the loop,           The following expression f (i, j, m, n)          sions with conditionals noted previ-
           the post-condition of the program  then is a solution satisfying both syn-                        ously. Initially the set Examples is 
           holds:                                           tactic and semantic constraints:                 empty, and as a result, the learner has 
                                                                                                             no constraints and can return any 
                                                                                                             expression it wants. Suppose it 
           88    COMMUNICATIONS OF THE ACM   |  DECEMBER 2018  |  VOL. 61  |  NO. 12
