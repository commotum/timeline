                 R. Alur, D. Fisman, R. Singh & A. Solar-Lezama                                                  7
                 competition, the solution approaches used by each of the participants and the results of the competition
                 on each of the different categories of benchmarks.
                 2    Competition Settings
                 2.1   Participating Benchmarks
                 Wecollected several benchmarks from various sources using an open call for benchmarks, from which
                 wesampled309benchmarksfortheGeneralTrack,73benchmarksfortheInvariantSynthesisTrack,and
                 67benchmarksfortheConditionalLinearArithmetictrack. These benchmarks can broadly be classiﬁed
                 into following 13 categories (11 categories for the General Track). The number of benchmarks in each
                 of these categories and the contributors for the new set of benchmarks is shown in Table 1.
                     • Array Benchmarks: This category consists of benchmarks that involve synthesizing a function
                       over an integer array of a bounded size. Since the current SyGuS-IF format does not support
                       arrays, we represent them using an ordered sequence of integer variables. One major class of
                       benchmarks in this category is array-search, which requires to synthesize a loop-free function
                       to ﬁnd an appropriate index for insertion of a given value into a sorted array of size n. Another
                       major class of benchmark is array-sum-m-n, which requires to synthesize a function to ﬁnd ﬁrst
                       two elements in an array of size n whose sum is greater than m.
                     • Let Benchmarks: The benchmarks in this category use the let construct as speciﬁed in the
                       SyGuS-IF format. The let expressions allow synthesizers to represent multiple occurrences of
                       commonsubexpressions succinctly, which helps in improving the scalability. The let expressions
                       in speciﬁcation constraints can be desugared, but they can not be desugared when used in gram-
                       mar productions. For example, the production T := (let [z=U] z + z) denotes sum of two
                       identical subexpressions built using addition operator, but the same can not be speciﬁed using a
                       context-free grammar.
                     • Invariant Generation Benchmarks (Bounded and Unbounded Integers): This category of
                       benchmarks consists of loop invariant synthesis problems from the domain of program veriﬁca-
                       tion. Some of these benchmarks are obtained from the Competition of Software Veriﬁcation (SV-
                       COMP)andothers are from the literature on invariant synthesis. It involves two sub-categories:
                       onethat uses unbounded integers and second that bounds the range of integers that can be used for
                       the invariant expression.
                     • ICFPBenchmarks: Thisbenchmarksinthiscategoryaresomeofthechallengingproblemstaken
                       from the 2013 ICFP Programming Competition on program synthesis. These benchmarks in-
                       volve synthesizing bit-vector functions from a domain-speciﬁc language of bit-vectors consisting
                       of primitive bitwise operators such as shift, not, add, or, xor etc. The language also consists of
                       a constrained comparison operator and a fold operator. The correctness speciﬁcation for these
                       benchmarks is provided using 64-bit input-output bit-vector examples.
                     • Hacker’s Delight Benchmarks: This category involves benchmarks that are derived from 20 dif-
                       ferent bit-manipulation problems from the Hackers Delight book. For these benchmarks, there are
                       3 increasingly challenging levels of grammars (d0, d1, and d5) that are provided for the unknown
                       function, where the level d0 consists of only operators that are necessary for the unknown function
                       and the level d5 consists of complete bit-vector grammar.
