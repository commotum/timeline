              6                                               Results and Analysis of SyGuS-Comp’15
              SyGuSformat, but they can be expressed more concisely using the extensions explicitly deﬁned for this
              purpose. Speciﬁcally, the encoding will be as follows.
              (set-logic LIA)
              (synth-inv inv-f ((i Int) (j Int) (i0 Int) (j0 Int)))
              (declare-primed-var i0 Int)
              (declare-primed-var j0 Int)
              (declare-primed-var i  Int)
              (declare-primed-var j  Int)
              (define-fun pre-f ((i Int) (j Int) (i0 Int) (j0 Int)) Bool
                                (and (>= i 0) (and (= i i0) (= j j0))))
              (define-fun trans-f ((i Int) (j Int) (i0 Int) (j0 Int)
                                   (i! Int) (j! Int) (i0! Int) (j0! Int)) Bool
                                   (and (and (= i! (- i 1)) (= j! (+ j 1)))
                                        (and (= i0! i0) (= j0! j0))))
              (define-fun post-f ((i Int) (j Int) (i0 Int) (j0 Int)) Bool
                                 (= j (+ j0 i0)))
              (inv-constraint inv-f pre-f trans-f post-f)
              (check-synth)
                 The directive (declare-primed-var i) is equivalent to separately declaring i and i!, where the
              primed version of the variables is used to distinguish their value before and after the loop body. Just like
              in the earlier example, the function to be synthesized inv f does not include a grammar, so the entire
              LIAgrammarisassumed. HerethereturntypeisalsonotgivenandisassumedtobeBoolsinceinvariant
              are assumed to be predicates. The constraint inv-constraint is syntactic sugar for the full veriﬁcation
              condition involving the invariant, precondition, postcondition and transition function.
              1.3  SyGuS-Comp’14summary
              The ﬁrst SyGuS competition, SyGuS-Comp’14 consisted of a single track — the general track — in
              which the benchmark provides the grammar describing the desired syntactic restrictions for that bench-
              mark. The background theory could be either linear interger arithmetic or bitvectors. Five solvers com-
              peted in SyGuS-Comp’14. The solver who won the ﬁrst place was the ENUMERATIVE solver which
              solved 126 out of 241 benchmarks.
              1.4  SyGuS-Comp’15summary
              The 2015 instance of SyGuS-Comp was the second iteration of the competition and the ﬁrst iteration to
              include the separate conditional linear integer arithmetic and invariant synthesis tracks. As elaborated
              in Section 2, there were a total of eight solvers submitted to the competition which represent a range
              of solution strategies. In the rest of the paper, we describe the details of the benchmarks used for the
