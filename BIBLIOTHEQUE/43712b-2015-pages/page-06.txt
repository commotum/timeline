                  8                                                          Results and Analysis of SyGuS-Comp’15
                       BenchmarkCateogry          NumberofBenchmarks               Contributors (in 2015)
                       Arrays                                31
                       Bitvectors                             5
                       CompilerOptimizations                 21                        Nissim Ofek (Yale):  21
                       HackersDelight                        44
                       ICFP                                  50
                       Integers                              34               Shambwaditya Saha (UIUC):     14
                       InvariantGeneration                   28
                       InvariantGenerationUbdd               28
                       Let                                   15
                       MotionPlanning                        12              Sarah Chasins (UC Berkeley):   12
                       MultipleFunctions                     41
                       INVTrack                              73                      Pranav Garg (UIUC):    51
                       LIATrack                              67
                  Table 1: The number of benchmarks in each individual category used in SyGuS-COMP 2015 together
                  with the number of new contributions and their contributors.
                     • Integer Benchmarks: These benchmarks involve synthesizing functions that involve complex
                        branching structure over linear arithmetic expressions. For example, the max benchmarks require
                        to synthesize a function using comparison operator to compute maximum of n integers.
                     • BitVector Benchmarks: This category of benchmarks involve synthesizing a complex function
                        over a set of Boolean values represented using a bit-vector. For example, the parity benchmarks
                        compute the parity of a given set of Boolean values, and the Morton benchmarks compute the
                        Mortonnumbers.
                     • Compiler Optimization Benchmarks: The benchmarks in this category come from the domain
                        of compiler optimization where the goal is to synthesize a simpler expression (constrained by a
                        grammar) that is functionally equivalent with a given complicated expression.
                     • Multiple Functions Benchmarks: This class of benchmarks consists of synthesis problems that
                        involve synthesizing multiple unknown functions that satisfy a given set of constraints.
                     • MotionPlanningBenchmarks: Thebenchmarksinthiscategorycomefromthedomainofrobot
                        motionplanning,wherethetaskistosynthesizeafunctiontocontrolrobotmovement(constrained
                        by a grammar of possible movements) that reach from one point in space to another while main-
                        taining some invariant constraints such as no collision.
                     • LIA Track Benchmarks: The benchmarks in this category come from the General Track cat-
                        egories such as integer benchmarks, array benchmarks, and motion planning benchmarks. The
                        grammar for the unknown functions for this category comprises of expressions from the entire
                        theory of Integer Linear Arithmetic with ITE conditionals as described in Section 3.2.
                     • INV Track Benchmarks: The benchmarks in this category come from the domain of program
                        veriﬁcation, wherethepre-condition,transitionfunction, andthepost-conditionarespeciﬁedusing
                        explicit constructs in the SyGuS-IF format.
