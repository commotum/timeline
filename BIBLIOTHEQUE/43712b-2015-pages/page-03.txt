                 R. Alur, D. Fisman, R. Singh & A. Solar-Lezama                                                  5
                 1.1   Conditional Linear Integer Arithmetic Track
                 For problems where the grammar consists of the set of all possible integer linear arithmetic terms, it
                 is sometimes possible to apply specialized solution techniques that exploit the information that decision
                 proceduresforintegerlineararithmeticareabletoproduce. Forthisreason, the2015SyGuScompetition
                 included a separate track where the grammar for all the unknown functions was assumed to be the entire
                 theory of Integer Linear Arithmetic with ITE conditionals.
                 Example As a simple example, consider the problem of synthesizing a function max2 that produces
                 the maximumoftwointegers. The problem can be speciﬁed with the constraint below:
                 (set-logic LIA)
                 (synth-fun max2 ((x Int) (y Int)) Int)
                 (declare-var x Int)
                 (declare-var y Int)
                 (constraint (>= (max2 x y) x))
                 (constraint (>= (max2 x y) y))
                 (constraint (or (= x (max2 x y)) (or (= y (max2 x y)))))
                 (check-synth)
                     Note that the deﬁnition of the unknown function max2 does not include a grammar this time, but
                 because the problem is deﬁned in the theory of linear integer arithmetic (LIA), the default grammar
                 consists of all the operations available in the theory.
                 1.2   Invariant Synthesis Track
                 One of the main applications of SyGuS is invariant synthesis. For this problem, the goal is to discover
                 an invariant that makes the veriﬁcation condition for a given loop valid. Such a problem can be easily
                 encoded in SyGuS, but invariant synthesis problems have structure that some solution algorithms are
                 able to exploit and that can be lost when encoding it into SyGuS. For this reason, the 2015 installment
                 of the competition also included a separate track for invariant synthesis problems where the additional
                 structure is made apparent. In the invariant synthesis version of the SyGuS format, the constraints are
                 separated into pre-condition, post-condition and transition relation, and the grammar for the unknown
                 invariant is assumed to be the same as that for the conditional linear arithmetic track.
                 Example Forexample,considerthefollowing simple loop.
                 Pre: i >= 0     and    j=j0 and i=i0;
                 while(i > 0){
                      i = i - 1;
                      j = j + 1;
                 }
                 Post: j = j0 + i0;
                 Suppose we want to prove that the value of j at the end of the loop equals the value of i + j at the
                 beginning of the loop. The veriﬁcation condition for this loop would check that (a) the precondition
                 implies the invariant, (b) that the invariant is inductive, so if it holds before an iteration and the loop
                 condition is true, then it will hold after that iteration, and (c) that the invariant together with the negation
                 of the loop condition implies the postcondition. All of these constraints can be expressed in the standard
