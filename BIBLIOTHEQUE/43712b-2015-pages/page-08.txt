                 10                                                        Results and Analysis of SyGuS-Comp’15
                              Solver    Authors
                     ALCHEMIST-CS       Daniel Neider (UIUC), Shambwaditya Saha (UIUC) and P. Madhusudan (UIUC)
                   ALCHEMIST-CSDT       Shambwaditya Saha (UIUC), Daniel Neider (UIUC) and P. Madhusudan (UIUC)
                   CVC4-1.5-SYGUS       AndrewReynolds(EPFL),ViktorKuncak(EPFL),CesareTinelli (Univ. of Iowa),
                                        Clark Barrett (NYU), Morgan Deters (NYU) and Tim King (Verimag)
                      ENUMERATIVE       Abhishek Udupa (Penn)
                             ICE-DT     Daniel Neider (UIUC), P. Madhusudan (UIUC) and Pranav Garg (UIUC)
                         SKETCH-AC      Jinseong Jeon (UMD), Xiaokang Qiu (MIT), Armando Solar-Lezama (MIT) and
                                        Jeffrey S. Foster (UMD)
                        SOSYTOAST       Heinz Riener (DLR) and Ruediger Ehlers (DLR)
                        STOCHASTIC      MukundRaghothama(Penn)
                                             Table 3: Submitted solvers and their authors
                 bine enumeration and constraint-solver based technique to ﬁnd leaf expressions The ALCHEMIST-CSDT
                 works in two modes, in the ﬁrst all variables (qunatiﬁed and unquantiﬁed) are assumed to be integers,
                 and in the second variables may be either integers or Booleans. The ALCHEMIST-CS tool can only solve
                 point-wise SyGuS problems. A SyGuS problem is said to be point-wise if the following holds: let F be
                 the class of all functions that are solutions to the speciﬁcation; then any function h that maps each input
                 to an output consistent to some function in F, is also a solution to the speciﬁcation.
                     The ICE-DT [11] tool is a specialized solver for the invariant synthesis track. It builds on the ICE
                 learning approach [6] — an invariant synthesis approach in which the teacher responses to a given hy-
                 pothesis may be concrete examples, counterexamples or implication. ICE-DT extends the ICE approach
                 by using decision trees as suggested in [7].
                     The CVC4-1.5-SYGUS solver is the only solver that is implemented inside an SMT solver [14]. It
                 reducesthesynthesisproblemtoanunsatisﬁbilityofquantiﬁedSMTformulae. Indeed,asnotedin[2,1],
                 for linear integer arithmetic problems, suppose the synthesis problem involves two variables x and y, then
                 it can be articulated as the following quantiﬁed SMT satisﬁability query: ∃a,b,c. ∀x,y. ϕ[f/ax+by+
                 c]. Since traditional SMT solvers are focused on instnatiation-based methods to show unsatisﬁability,
                 the CVC4-1.5-SYGUS tool reformulates LIA problems as unsatisﬁability of the synthesis conjecture
                 ∀f,∃x0,x1,...,xi,¬ϕ[f,x0,x1,...,xi]. For non-LIA problems, the CVC4-1.5-SYGUS uses an encoding
                 of the syntax restrictions using ﬁrst order variables and uses a deep embedding into an extension of the
                 background theory T with a theory of algebraic data types.
                 2.3   Experimental Setup
                 ThesolverswererunontheStarExecplatform[21]withadedicatedclusterof12nodes,whereeachnode
                 consisted of two 4-core 2.4GHz Intel processors with 256GB RAM and a 1TB hard drive. The memory
                 usage limit of each solver run was set to 128GB. The wallclock time unit was set to 3600 seconds (thus,
                 a solver that used all cores could consume at most 14400 seconds cpu time).
                     Thesolutionsthat the solvers produce are being checked for both syntactic and semantic correctness.
                 That is, a ﬁrst post-processor checks that the produced expression adheres to the grammar speciﬁed in
                 the given benchmark, and if this check passes, a second post-processor checks that the solution adheres
                 to semantic constraints given in the benchmark (by invoking an SMT solver).
