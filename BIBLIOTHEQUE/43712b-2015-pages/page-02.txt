        4                        Results and Analysis of SyGuS-Comp’15
        The syntactic restriction implies that the function fimp must belong to the grammar G also provided by
        the user.
        Example Asanexample,considertheproblemofﬁndingabit-vectorfunctionthatreturnsabit-vector
        with a 1 in the position of the least signiﬁcant zero in its input bit-vector and zero everywhere else. This
        problem is deﬁned in terms of the theory of bit-vectors, which includes operations such as bitwise and,
        bitwise or, as well as left and right shifts and basic arithmetic among bit-vectors. The example problem
        can be formalized in terms of two constraints that must be satisﬁed by the desired function. The ﬁrst
        constraint is that if x is not zero, f(x) should have a one in the same position as x has a zero, so bitwise
        and(&)of f(x) and the bitwise negation of x (∼x) should not be zero.
                       ∀x. x > 0 ⇒(f(x) & ∼x)>0
        The way we enforce that there is a single one and that it corresponds to the least signiﬁcant zero is by
        enforcing that if we shift f(x) right by any amount, then bitwise anding with the bitwise negation of x
        will now yield zero.
                     ∀x,y. y > 0 ⇒ (f(x)  y & ∼x)=0
         These two constraints can be expressed succinctly in SyGuS with the following notation.
        (set-logic BV)
        (synth-fun f ((x (BitVec 32))) (BitVec 32)
               ((Start (BitVec 32) (x 0 1
                         (bvand Start Start)
                         (bvor Start Start)
                         (bvnot Start)
                         (bvadd Start Start)))))
        (declare-var x (BitVec 32))
        (declare-var y (BitVec 32))
        (constraint (=> (bvult 0 x) (bvult 0 (bvand (f x) (bvnot x)))))
        (constraint (=> (bvult 0 y) (= 0 (bvand (bvshr (f x) y) (bvnot x)))))
        (check-synth)
        The set-logic directive indicates that the constraints should be interpreted in terms of the theory of
        bitvectors. The directive declare-var is used to declare x and y as 32-bit bitvector variables. The con-
        straints are introduced with the directive constraint, and check-synth marks the end of the problem
        and prompts the synthesizer to solve for the missing function. Crucially, in order for the synthesizer to
        generate f, it needs a grammar, which is provided as part of the synth-fun directive. In this example,
        we have signiﬁcantly reduced the space of possible functions by restricting the search to expressions
        involving bitwise and, or, bitwise negation, sum and the constants 0 and 1, instead of asking the system
        to consider completely arbitrary expressions in the theory of bitvectors.
