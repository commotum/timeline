              Learning program synthesis with self-improving language models: A case study on ARC-AGI
       H.2. ARCProblem72ca375d
       Solve the task online here, then read the program.
       def transform(grid):
         def find_largest_rectangle(grid):
            rows, cols = (len(grid), len(grid[0]))
            max_area = 0
            max_rectangle = (0, 0, 0, 0)
            for i in range(rows):
              for j in range(cols):
                if grid[i][j] == 0:
                   continue
                color = grid[i][j]
                width = 1
                while j + width < cols and grid[i][j + width] == color:
                   width += 1
                for k in range(i, rows):
                   if grid[k][j] != color:
                     break
                   for l in range(j, j + width):
                     if grid[k][l] != color:
                        break
                   else:
                     continue
                   break
                area = (k - i) * (l - j)
                if area > max_area:
                   max_area = area
                   max_rectangle = (i, j, k, l)
            return max_rectangle
         def extract_rectangle(grid, rect):
            i, j, k, l = rect
            return [row[j:l] for row in grid[i:k]]
         def find_largest_connected(grid, color):
            rows, cols = (len(grid), len(grid[0]))
            visited = [[False] * cols for _ in range(rows)]
            max_size = 0
            max_component = []
            def dfs(i, j, component):
              if i < 0 or i >= rows or j < 0 or (j >= cols) or visited[i][j] or (grid[i][j]
                                         != color):
                return
              visited[i][j] = True
              component.append((i, j))
              dfs(i + 1, j, component)
              dfs(i - 1, j, component)
              dfs(i, j + 1, component)
              dfs(i, j - 1, component)
            for i in range(rows):
              for j in range(cols):
                if grid[i][j] == color and (not visited[i][j]):
                   component = []
                   dfs(i, j, component)
                   if len(component) > max_size:
                     max_size = len(component)
                     max_component = component
            return max_component
         def extract_component(grid, component):
            min_i = min((c[0] for c in component))
                                  26
