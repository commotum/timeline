                227:8                                                                         Shraddha Barke, Hila Peleg, and Nadia Polikarpova
                  Cost  #Programs                                                           Bank
                   2         4                                                        arg, "", "<", ">"
                   8        15                                (replace arg "<" arg), (replace arg "<" ""), (replace arg "<" ">")
                                                               (replace arg ">" "<"), (concat "<" arg), (concat "<" "<") . . .
                   20      1272      (replace "<" (replace arg (replace arg "<" "") "") ""), (replace "<" (replace arg (replace arg "<" "") "") ">") . . .
                                      (replace (replace arg ">" "<") (replace arg ">" "") arg), (replace (replace arg ">" "<") (replace arg ">" "") ">")
                    .        .                                                                .
                    .        .                                                                .
                    .        .                                                                .
                   38      130K       (str.replace (replace arg "<" (replace (replace arg ">" "<") ">" arg)) (replace (replace arg "<" "") ">" arg) "<")
                                      (replace (replace arg "<" (replace (replace arg ">" "<") ">" arg)) (replace (replace arg "<" "") ">" arg) ">") ...
                   Fig. 9. Programs generated for remove-angles using guided bottom-up search with the PCFG in Fig. 8
                the costs of í µí±¥ and í µí±¦ sum up to 8 âˆ’ 4 = 4. The cost of our solution replace-6 is 38, which places
                it within the first 130K programs the search encounters; on the other hand, its size is 19, placing
                it within the first âˆ¼ 4í µí±€ programs in the order of size. As a consequence, size-based enumeration
                cannot find this program within 20 minutes, but guided enumeration, given the PCFG from Fig. 8,
                is able to discover replace-6 within 5 seconds.
                3.3     Just-in-Time Learning
                In the previous section we have seen that guided bottom-up search can find solutions efociently,
                given an appropriately biased PCFG. But how can we obtain such a PCFG for each synthesis
                problem? Prior approaches have proposed learning probabilistic models from a corpus of existing
                solutions [Lee et al. 2018; Menon et al. 2013] (see Sec. 7 for a detailed discussion). While achieving
                impressive results, these approaches are computationally expensive and, more importantly, require
                high-quality training data, which is generally hard to obtain. Can we benefit from guided search
                whentraining data is not available?
                    Our second key contribution is a new approach to learning probabilistic models of programs,
                which we dub just-in-time learning. This approach is inspired by an observation made in prior
                work[PelegandPolikarpova2020; Shi et al. 2019] that partial solutionsÃprograms that satisfy a
                subset of the semantic specificationÃoften share syntactic similarity with the full solution. We
                can leverage this insight to iteratively bias the PCFG during synthesis, rewarding productions that
                occur in partial solutions we encounter.
                Enumeration with just-in-time learning. We illustrate just-in-time learning on our running
                example remove-angles. We begin enumeration with a uniform PCFG, which assigns the same
                probability to each production5. In this initial PCFG every production has cost 3 (see Fig. 10).
                    WithauniformPCFG,oursearchstartsoff exactly the same as size-based search of Sec. 3.1. At
                size 7 (cost level 21), the search encounters the program replace-2, which satisfies the example í µí±’0.
                Sincethisprogramcontainsproductionsreplace,arg,"",">",and"<",wereward theseproductions
                by decreasing their cost, as indicated in Fig. 10; after this update, the cost of the production concat
                does not change, so our solution is now cheaper relative to other programs of the same size. With
                thenewPCFGathand,theenumerationsoonencountersanotherpartialsolution,replace-3,which
                covers the examples í µí±’0 and í µí±’1. Since this program uses the same productions as replace-2 and
                satisfies even more examples, the difference in cost between the irrelevant production concat and
                the relevant ones increases even more: in fact, we have arrived at the same biased PCFG we used in
                Sec. 3.2 to illustrate the guided search algorithm.
                Challenge: selecting promising partial solutions. As this example illustrates, the more partial
                solutions we encounter that are similar to the final solution, the more biased the PCFG becomes,
                gradually steering the search in the right direction. The key challenge with this approach is that
                the search might encounter hundreds or thousands of partial solutions, and many of them have
                5Thealgorithm can also be initialized with a pre-learned PCFG if one is available.
                Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
