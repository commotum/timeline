          Just-in-Time Learning for Bottom-Up Enumerative Synthesis                        227:15
             (1) Restart from scratch: If we restart the search with an empty bank, the program (indexof arg
          "+") is now encountered before the program 0 and selected as the representative of it equivalence
          class. In other words, the desired the behavior under the new PCFG is that the class [0,0,0] has
          cost 7. Can we achieve this behavior without restarting the search?
             (2) Keep the bank unchanged: Resuming the enumeration with B unchanged would be incorrect:
          in this case the representative of [0,0,0] is still the program 0 with cost 5. As a result, any program
          webuildinthenewcyclethatusesthisequivalence class as a sub-program would have a wrong
          cost, and hence the enumeration order would be different from that prescribed by the new PCFG.
             (3) Re-index the bank: Another option is to keep the programs stored in B but re-index it with
          their updated costs: for example, index the program 0 with cost 10. This does not solve the problem,
          however: now class [0,0,0] has cost 10 instead the desired cost 7, because it still has a wrong
          representative in B. Therefore, in order to enforce the correct enumeration order in the new cycle
          weneedtoupdatetheequivalenceclass representatives stored in the bank.
             (4) Updaterepresentatives:Tobeabletoupdatetherepresentatives,weneedtostoretheredundant
          programs in the bank instead of discarding them. To this end, prior work [Phothilimthana et al.
          2016; Wang et al. 2017c,b] has proposed representing the bank as a finite tree automaton, i.e. a
          hypergraphwherenodescorrespondtoequivalenceclasses(suchas [0,0,0])andedgescorrespond
          to productions (with the corresponding arity). The representative program of an equivalence class
          can be computed as the shortest hyper-path to the corresponding node from the set of initial nodes
          (inputs and literals); the cost of the class is the length of such a shortest path. When the PCFG is
          updated, leading to modified costs of hyper-edges, shortest paths for all nodes in this graph need
          to be recomputed. Algorithms for doing so [Gao et al. 2012] have super-linear complexity in the
          numberofaffected nodes. Since in our case most nodes are likely to be affected by the update, and
          since the number of nodes in the hypergraph is the same as the size of our bank B, this update step
          is roughly as expensive as rebuilding the bank from scratch. In addition, for a search space as large
          as the one Probe explores for the SyGuS String benchmarks, the memory overhead of storing the
          entire hypergraph is also prohibitive.
             Since restarting the search is expensive, Probe does not return from the guided search immedi-
          ately once a partial solution is found and instead keeps searching until a fixed cost limit and returns
          partial solutions in batches. There is a trade-off between restarting synthesis too often (wasting
          time exploring small programs again and again) and restarting too infrequently (wasting time on
          unpromising parts of the search space when an updated PCFG could guide the search better). In
          our implementation, we found that setting the cost limit to 6 Â·í µí°¶ works best empirically, where
          í µí°¶ is the maximum production cost in the initial PCFG (this roughly corresponds to enumerating
          programs in size increments of six with the initial grammar).
          6 EXPERIMENTS
          Wehaveimplemented the Probe synthesis algorithm in Scala8. In this section, we empirically
          evaluate how Probe compares to the baseline and state-of-the-art synthesis techniques. We design
          our experiments to answer the following research questions:
           (Q1) Howeffective is the just-in-time learning in Probe? We examine this question in two parts:
               1. by comparing Probe to unguided bottom-up enumerative techniques, and
               2. by comparing different schemes for partial solution selection.
           (Q2) Is Probe faster than state-of-the-art SyGuS solvers?
           (Q3) Is the quality of Probe solutions comparable with state-of-the-art SyGuS solvers?
          8https://github.com/shraddhabarke/probe.git
                             Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
