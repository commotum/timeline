                Just-in-Time Learning for Bottom-Up Enumerative Synthesis                                                                            227:5
                     ID                                                      Program                                                    ExamplesSatisfied
                  replace-2                                   (replace (replace arg "<" "") ">" "")                                            {Ì†µÌ±í0}
                  replace-3                           (replace (replace (replace arg "<" "") "<" "") ">" "")                                 {Ì†µÌ±í0,Ì†µÌ±í1}
                  replace-6 (replace (replace (replace (replace (replace (replace arg "<" "") "<" "") "<" "") ">" "") ">" "") ">" "")       {Ì†µÌ±í0,Ì†µÌ±í1,Ì†µÌ±í2}
                           Fig. 5. Shortest solutions for different subsets of examples of the remove-angles problem.
                  Height #Programs                                                             Bank
                     0           4                                                       arg, "", "<", ">"
                     1          15           (concat arg arg), (concat arg "<"), (concat arg ">"), (concat "<" "<"), (concat "<" ">"), . . .
                                             (replace arg "<" arg), (replace arg "<" ""), (replace arg "<" ">"), (replace arg ">" "<"), . . .
                     2         1023         (concat arg (concat arg arg)), (concat arg (concat ">" ">")), . . . (concat "<" (concat arg arg)),
                                          (concat "<" (replace arg "<" arg)), (concat ">" (concat "<" "<")), (concat ">" (replace arg ">" "<"))
                     3         ‚àº30Ì†µÌ±Ä        (concat arg (concat (replace arg "<" arg) arg)), (concat arg (concat (replace arg "<" arg) "<"))
                                           (concat arg (concat (replace arg "<" arg) ">")), (concat arg (concat (replace arg "<" "") arg)) ...
                  Fig. 6. Programs generated for remove-angles-short from the grammar in Fig. 4 in the order of height.
                 Fig. 3. The program to be synthesized takes as input a string arg and outputs this string with every
                 occurrence of "<" and ">" removed. Because the grammar in Fig. 4 allows no loops or recursion,
                 and the replace operation only replaces the first occurrence of a given substring, the solution
                 involves repeatedly replacing the substrings "<" and ">" with an empty string "". Fig. 5 shows one
                 of the shortest solutions to this problem, which we dub replace-6. Note that this benchmark has
                 multiple solutions of the same size that replace "<" and ">" in different order; for our purposes
                 they are equivalent, so hereafter we refer to any one of them as ≈Çthe shortest solution≈æ. The figure
                 also shows two shorter programs, replace-2 and replace-3, which satisfy different subsets of the
                 semantic specification and which we refer to throughout this and next section.
                 2.2    Bottom-upEnumeration
                 Bottom-up enumeration is a popular search technique in program synthesis, first introduced in
                 the tools Transit [Udupa et al. 2013] and Escher [Albarghouthi et al. 2013]. We illustrate this
                 search technique in action using a simplified version of our running example, remove-angles-short,
                wherethesemantic specification only contains the examples {Ì†µÌ±í0,Ì†µÌ±í1} (the shortest solution to this
                 problem is the program replace-3 from Fig. 5).
                 Bottom-up Enumeration. Bottom-up enumeration is a dynamic programming technique that
                 maintains a bank of enumerated programs and builds new programs by applying production rules
                 to programs from the bank. Fig. 6 illustrates the evolution of the program bank on our running
                 example. Starting with an empty bank, each iteration Ì†µÌ±õ builds and adds to the bank all programs of
                 heightÌ†µÌ±õ. In the initial iteration, we are limited to production rules that require no subexpressions√ê
                 literals and variables; this yields the programs of height zero: "", "<", ">", and arg. In each
                 following iteration, we build all programs of height Ì†µÌ±õ + 1 using the programs of height up to Ì†µÌ±õ
                 as subexpressions. For example at height one, we construct all programs of the form concat Ì†µÌ±• Ì†µÌ±¶
                 andreplaceÌ†µÌ±† Ì†µÌ±• Ì†µÌ±¶, where ‚ü®Ì†µÌ±†,Ì†µÌ±•,Ì†µÌ±¶‚ü© are filled with all combinations of height-zero expressions. The
                 efociency of bottom-up enumeration comes from reusing solutions to overlapping sub-problems,
                 characteristic of dynamic programming: when building a new program, all its sub-expressions are
                 taken directly from the bank and never recomputed.
                 Observational Equivalence Reduction. Bottom-up synthesizers further optimize the search by
                 discarding programs that are observationally equivalent to some program that is already in the bank.
                Twoprogramsareconsideredobservationally equivalent if they evaluate to the same output for
                 every input in the semantic specification. In our example, the height-one program (concat arg "")
                 is not added to the bank because it is equivalent to the height-zero program arg. This optimization
                 shrinks the size of the bank at height one from 80 to 15; because each following iteration uses all
                                              Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
