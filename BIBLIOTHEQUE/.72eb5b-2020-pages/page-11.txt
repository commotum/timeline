                         Just-in-Time Learning for Bottom-Up Enumerative Synthesis                                                                                                                                            227:11
                        Algorithm1GuidedBottom-upsearchalgorithm
                         Input: PCFG G , input-output examples E, and optionally, the initial state of the search
                                                        Ì†µÌ±ù
                         Output: AsolutionÌ†µÌ±É or ‚ä•, and the current state of the search
                           1: procedure Guided-Search(G ,E,‚ü®Lvl ,B ,E ,PSol ‚ü© = ‚ü®0,‚àÖ,‚àÖ,‚àÖ‚ü©)
                                                                                            Ì†µÌ±ù                0      0      0            0
                           2:           Lvl,B,E,PSol ‚Üê Lvl ,B ,E ,PSol                                                                                                          ‚ä≤ Initialize state of the search
                                                                                  0      0     0             0
                           3:           whileLvl ‚â§ Lvl +Limdo
                                                                         0
                           4:                  for Ì†µÌ±É ‚àà New-Programs(G ,Lvl,B) do                                                                                              ‚ä≤ For all programs of cost Lvl
                                                                                                   Ì†µÌ±ù
                           5:                         Eval ‚Üê [‚ü®Ì†µÌ±ñ,‚ü¶Ì†µÌ±É‚üß(Ì†µÌ±ñ)‚ü© | ‚ü®Ì†µÌ±ñ,Ì†µÌ±ú‚ü© ‚àà E]                                                                                        ‚ä≤ Evaluate on inputs from E
                           6:                         if (Eval = E) then
                           7:                                return (Ì†µÌ±É, ‚ü®Lvl,B,E,PSol‚ü©)                                                                            ‚ä≤ Ì†µÌ±É fully satisfies E, solution found!
                           8:                         else if (Eval ‚àà E) then
                           9:                                continue                                                     ‚ä≤ Ì†µÌ±É is observationally equivalent to another program in B
                         10:                          else if (Eval ‚à© E ‚â† ‚àÖ) then                                                                                                           ‚ä≤ Ì†µÌ±É partially satisfies E
                         11:                                 PSol ‚ÜêPSol‚à™Ì†µÌ±É
                         12:                          B[Lvl] ‚Üê B[Lvl] ‚à™ {Ì†µÌ±É}                                                                                          ‚ä≤ Add to the bank, indexed by cost
                         13:                          E‚ÜêE‚à™Eval                                                                                                                          ‚ä≤ Cache evaluation result
                         14:                   Lvl ‚ÜêLvl+1
                         15:            return (‚ä•,‚ü®Lvl,B,E,PSol‚ü©)                                                                                                                                 ‚ä≤ Cost limit reached
                         Input: PCFG G , cost level Lvl, program bank B filled up to Lvl ‚àí 1
                                                        Ì†µÌ±ù
                         Output: Iterator over all programs of cost Lvl                                                                                                                 ‚ä≤ For all production rules
                         16: procedure New-Programs(G , Lvl, B)
                                                                                           Ì†µÌ±ù
                         17:            for (R = N ‚Üí (Ì†µÌ±° N N                           . . .  N ) ‚àà R) do
                                                                            1      2             Ì†µÌ±ò
                         18:                   if cost(R) = Lvl ‚àßÌ†µÌ±ò = 0 then                                                                                                                            ‚ä≤ Ì†µÌ±° has arity zero
                         19:                          yield Ì†µÌ±°
                         20:                   else if cost(R) < Lvl ‚àßÌ†µÌ±ò > 0 then                                                                                                              ‚ä≤ Ì†µÌ±° has non-zero arity
                                                                                         n                     √ç                                        o
                         21:                          for (Ì†µÌ±ê , . . . ,Ì†µÌ±ê         ) ‚àà       [1,Lvl]Ì†µÌ±ò              Ì†µÌ±ê   =Lvl‚àícost(R) do                                          ‚ä≤ For all subexpression costs
                                                                 1             Ì†µÌ±ò                {                   Ì†µÌ±ñ                  | √ì                ‚àó       }
                         22:                                 for (Ì†µÌ±É , . . . , Ì†µÌ±É ) ‚àà               B[Ì†µÌ±ê ] √ó . . . √ó B[Ì†µÌ±ê ]                       N ‚áí Ì†µÌ±É                 do                ‚ä≤ For all subexpressions
                                                                         1             Ì†µÌ±ò                 1                          Ì†µÌ±ò         Ì†µÌ±ñ   Ì†µÌ±ñ            Ì†µÌ±ñ
                         23:                                        yield (Ì†µÌ±° Ì†µÌ±É1 . . . Ì†µÌ±É )
                                                                                                    Ì†µÌ±ò
                         production in the derivation of the new program, we have a budget of Lvl ‚àí cost(R) to allocate
                         betweenthesubexpressions;line21iteratesoverallpossiblesubexpressioncoststhatadduptothis
                         budget. Once the subexpression costsÌ†µÌ±ê1,...,Ì†µÌ±êÌ†µÌ±ò have been fixed, line 22 iterates over all Ì†µÌ±ò-tuples of
                         programs from the bank that have the right costs and the right types to serve as subexpressions:
                         N ‚áí‚àóÌ†µÌ±É meansthatÌ†µÌ±É canreplacethenonterminal N in the production rule R. Finally, line 23
                            Ì†µÌ±ñ             Ì†µÌ±ñ                             Ì†µÌ±ñ                                                                   Ì†µÌ±ñ
                         builds a program from the production rule R and the subexpressions Ì†µÌ±ÉÌ†µÌ±ñ.
                         4.3         Guarantees
                         Soundness. The procedure Guided-Search is sound: given G = ‚ü®G,Ì†µÌ±ù‚ü© and E, if the procedure
                                                                                                                                                               Ì†µÌ±ù
                         returns (Ì†µÌ±É,_), then Ì†µÌ±É is a solution to the inductive SyGuS problem (G,E). It is straightforward to
                         showthat Ì†µÌ±É satisfies the semantic specification E, since we check this property directly in line
                         6. Furthermore, Ì†µÌ±É ‚àà L(G), since Ì†µÌ±É is constructed by applying a production rule R to programs
                         derived from appropriate non-terminals (see check in line 22).
                         Completeness.TheprocedureGuided-Searchiscomplete:ifÌ†µÌ±É‚àóisasolutiontotheinductiveSyGuS
                         problem (G,E), such that cost(Ì†µÌ±É‚àó) = Ì†µÌ∞∂, andÌ†µÌ∞∂ ‚â§ Lvl + Lim, then the algorithm will return (Ì†µÌ±É,_),
                                                                                                                                         0
                        where cost(Ì†µÌ±É) ‚â§ Ì†µÌ∞∂. Completeness follows by observing that each level of the bank is complete
                         up to observational equivalence: if Ì†µÌ±É ‚àà L(G) and cost(Ì†µÌ±É) ‚â§ Ì†µÌ∞∂, then at the end of the iteration
                        with Lvl =Ì†µÌ∞∂, either Ì†µÌ±É ‚àà B or ‚àÉÌ†µÌ±É‚Ä≤ ‚àà B s.t. cost(Ì†µÌ±É‚Ä≤) ‚â§ cost(Ì†µÌ±É) and ‚àÄ‚ü®Ì†µÌ±ñ,Ì†µÌ±ú‚ü© ‚àà E s.t. ‚ü¶Ì†µÌ±É‚üß(Ì†µÌ±ñ) = ‚ü¶Ì†µÌ±É‚Ä≤‚üß(Ì†µÌ±ñ).
                                                                      Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
