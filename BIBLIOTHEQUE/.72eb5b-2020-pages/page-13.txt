              Just-in-Time Learning for Bottom-Up Enumerative Synthesis                                                  227:13
                                                 ID             Input              Output
                                                 í µí±’0     "+95 310-537-401"          "310"
                                                 í µí±’1     "+72 001-050-856"          "001"
                                                 í µí±’2    "+106 769-858-438"          "769"
                     Fig. 11. A set of input-output examples for a string transformation (adapted from [eup 2018]).
                  Cycle     ID ExamplesSatisfied                             Partial Solutions                       Cost
                     1      í µí±ƒ0           {í µí±’0,í µí±’1}                           (substr arg 4 3)                         20
                     2      í µí±ƒ1           {í µí±’0,í µí±’1}               (replace (substr arg 4 3) " " arg)                   21
                     3      í µí±ƒ2           {í µí±’1,í µí±’2}          (substr arg (indexof arg (at arg 5) 3) 3)                 37
                     3      í µí±ƒ3           {í µí±’1,í µí±’2}           (substr arg (- 4 (to.int (at arg 4))) 3)                 37
                Fig. 12. Partial solutions and the corresponding subset of examples satisfied for the problem in Fig. 11
              9), the second step is to use the promising partial solutions to Update the PCFG, and the third step
              is to restart the search (line 11). These three steps are detailed in the rest of this section.
              5.2   Selecting Promising Partial Solutions
              Theprocedure Select takes as input the set of partial solutions PSol returned by Guided-Search,
              andselects the ones that are promising and should be used to update the PCFG. We illustrate this
              process using the synthesis problem in Fig. 11; some partial solutions generated for this problem
              are listed in Fig. 12. The shortest full solution for this problem is:
                                             (substr arg (- (indexof arg "-" 3) 3) 3)
              Objectives. An effective selection procedure must balance the following two objectives.
                 (a) Avoid rewarding irrelevant productions: The reason we cannot simply use all generated partial
              solutions to update the PCFG is that partial solutions often contain irrelevant subprograms, which
              do not in fact contribute to solving the synthesis problem; rewarding productions from these
              irrelevant subprograms derails the search. For example, consider í µí±ƒ0 and í µí±ƒ1 in Fig. 12: intuitively,
              these twoprogramssolvetheexamples {í µí±’0,í µí±’1} inthesameway,butí µí±ƒ1 alsoperformsanextraneous
              character replacement, which happens to not affect its behavior on these examples. Hence, we
              wouldlike to discard í µí±ƒ1 from consideration to avoid rewarding the irrelevant production replace.
              Observe that í µí±ƒ0 and í µí±ƒ1 satisfy the same subset of examples but í µí±ƒ1 has a higher cost; this suggests
              discarding partial solutions that are subsumed by a cheaper program.
                 (b) Reward different approaches: On the other hand, different partial solutions might represent
              inherently different approaches to solving the task at hand. For example, consider partial solutions
              í µí±ƒ0 and í µí±ƒ2 in Fig. 12; intuitively, they represent different strategies for computing the starting
              position of the substring: fixed index vs. search (indexof). We would like to consider í µí±ƒ2 promising:
              indeed, indexof turns out to be useful in the final solution. We observe that although í µí±ƒ2 solves the
              samenumberofexamplesandhasahighercostthaní µí±ƒ0,itsolvesadifferentsubset of examples,
              andhenceshouldbeconsideredpromising.
                 Ourgoal is to find the right trade-off between the two objectives. Selecting too many partial
              solutions might lead to rewarding irrelevant productions and more frequent restarts (recall that
              search is restarted only if new promising partial solutions were found in the current cycle). On the
              other hand, selecting too few partial solutions might lead the synthesizer down the wrong path or
              simply not provide enough guidance, especially when the grammar is large.
                                      Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
