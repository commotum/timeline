              Just-in-Time Learning for Bottom-Up Enumerative Synthesis                                                    227:7
                                                                         Ì†µÌ±ù        ‚àílog(Ì†µÌ±ù )     cost
                                                                           Ì†µÌ±Ö               Ì†µÌ±Ö        Ì†µÌ±Ö
                                      Ì†µÌ±Ü   ‚Üí arg|""|"<"|">" 0.188 2.41                           2
                                             |    (replaceÌ†µÌ±Ü Ì†µÌ±Ü Ì†µÌ±Ü)      0.188     2.41          2
                                             |    (concat Ì†µÌ±Ü Ì†µÌ±Ü)         0.059     4.09          4
              Fig. 8. A PCFG for string expressions that is biased towards the solution replace-6. For each production
              rule Ì†µÌ±Ö, we show its probability Ì†µÌ±ù  and its cost cost , which is computed as a rounded negative log of the
                                                 Ì†µÌ±Ö                  Ì†µÌ±Ö
              probability.
              bottom-up synthesizer is able to solve the remove-angles-short benchmark in only one second!
              (Recall that the baseline height-based synthesizer times out after 20 minutes).
                 Unfortunately, the number of programs in the bank still grows exponentially with program size,
              limiting the range of sizes that can be explored efociently: for example, the solution to the original
              remove-angles benchmark (replace-6) has size 19, and size-based enumeration is unable to find it
              within the 20 minute timeout. This is where guided bottom-up search comes to the rescue.
              3.2   GuidedBottom-upSearch
              Previous work has demonstrated significant performance gains in synthesizing programs by ex-
              ploiting probabilistic models to guide the search [Balog et al. 2016; Lee et al. 2018; Menon et al.
              2013]. These techniques, however, do not build upon bottom-up enumeration, and hence cannot
              leverage its two main benefits: reuse of subprograms and observational equivalence reduction
              (Sec. 2.2). Our first key contribution is modifying the size-based bottom-up enumeration technique
              fromprevious section to guide the search using a probabilistic context-free grammar (PCFG). We
              refer to this modification of the bottom-up algorithm as guided bottom-up search.
              Probabilistic context-free grammars. A PCFG assigns a probability to each production rule in a
              context-free grammar. For example, Fig. 8 depicts a PCFG for our running example that is biased
              towards the correct solution: it assigns high probabilities to the rules (operations) that appear in
              replace-6 and a low probability to the rule concat that does not appear in this program. As a result,
                                                                                        4
              this PCFG assigns a higher likelihood to the program replace-6 than it does to other programs of
              the same size. Hence, an algorithm that explores programs in the order of decreasing likelihood
              wouldencounter replace-6 sooner than size-based enumeration would.
              Fromprobabilities to discrete costs. Unfortunately, size-based bottom-up enumeration cannot
              be easily adapted to work with real-valued probabilities. We observe, however, that the order of
              programenumerationneednotbeexact:enumeratingapproximately in the order of decreasing
              likelihood still benefits the search. Our insight therefore is to convert rule probabilities into discrete
              costs, which are computed as their rounded negative logs. According to Fig. 8, the high-probability
              rules have a low cost of two, and the low-probability rule concat has a higher cost of four. The cost
              of a program is computed by summing up the costs of its productions, for example:
                                   cost(concat arg "<") = cost(concat) + cost(arg) + cost("<")
                                                             =4+2+2=8
              Hence, the order of increasing cost approximately matches the order of decreasing likelihood.
              Extending size-based enumeration. With the discrete costs at hand, guided bottom-up search is
              essentially the same as the size-based search detailed in Sec. 3.1, except that it takes the cost of the
              top-level production into account when constructing a new program. Fig. 9 illustrates the working
              of this algorithm. For example, at cost level 8, we build all programs of the form concat Ì†µÌ±• Ì†µÌ±¶, where
              4Thelikelihood of a program is the product of the probabilities of all rules involved in its derivation.
                                       Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
