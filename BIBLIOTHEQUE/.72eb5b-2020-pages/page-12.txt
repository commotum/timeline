            227:12                                                     Shraddha Barke, Hila Peleg, and Nadia Polikarpova
            Algorithm2TheProbealgorithm
            Input: CFG G, set of input-output examples E
            Output: AsolutionÌ†µÌ±É or ‚ä•
              1: procedure Probe(G,E)
              2:    G ‚Üê‚ü®G,Ì†µÌ±ù ‚ü©                                                           ‚ä≤ Initialize PCFG to uniform
                      Ì†µÌ±ù       Ì†µÌ±¢
              3:    Lvl,B,E ‚Üê 0,‚àÖ,‚àÖ                                                           ‚ä≤ Initialize search state
              4:    whilenottimeoutdo
              5:       Ì†µÌ±É, ‚ü®Lvl, B, E, PSol‚ü© ‚Üê Guided-Search (G ,E, ‚ü®Lvl,B,E,‚àÖ‚ü©)     ‚ä≤ Search with current PCFG G
                                                               Ì†µÌ±ù                                                 Ì†µÌ±ù
              6:       if Ì†µÌ±É ‚â† ‚ä• then
              7:           returnÌ†µÌ±É                                                                 ‚ä≤ Solution found
              8:       PSol ‚ÜêSelect(PSol,E)                                       ‚ä≤ Select promising partial solutions
              9:       if PSol ‚â† ‚àÖ then
             10:           G ‚ÜêUpdate(G ,PSol,E)                                               ‚ä≤ Update the PCFG G
                             Ì†µÌ±ù             Ì†µÌ±ù                                                                    Ì†µÌ±ù
             11:           Lvl,B,E ‚Üê 0,‚àÖ,‚àÖ                                                       ‚ä≤ Restart the search
             12:    return ‚ä•
            This in turn follows from the completeness of New-Programs (it considers all combinations
            of costs of R and the subexpressions that add up to Lvl), monotonicity of costs (replacing a
            subexpression with a more expensive one yields a more expensive program) and compositionality
            of program semantics (replacing a subexpression with an observationally equivalent one yields an
            observationally equivalent program).
            Prioritization.WewouldalsoliketoclaimthatGuided-Searchenumeratesprogramsintheorder
            of decreasing likelihood. This property would hold precisely if we were to enumerate programs
            in order of increasing real cost rcost: since the log function is monotonic, Ì†µÌ±ù(Ì†µÌ±É1) < Ì†µÌ±ù(Ì†µÌ±É2) iff
            rcost(Ì†µÌ±É1) < rcost(Ì†µÌ±É2). Instead Guided-Search enumerates programs in the order of increasing
            discrete cost cost, so this property only holds approximately due to the rounding error. Empirical
            evaluation shows, however, that this approximate prioritization is effective in practice (Sec. 6).
            5 JUSTINTIMELEARNING
            In this section, we introduce a new technique we call just-in-time learning that updates the
            probabilistic model used to guide synthesis by learning from partial solutions. We first present the
            overall Probe algorithm in Sec. 5.1 and then discuss the three steps involved in updating the PCFG
            in the remainder of the section.
            5.1   Algorithmsummary
            Theoverall structure of the Probe algorithm is presented in Algorithm 2. The algorithm iterates
            between the following two phases until timeout is reached:
               (1) Synthesis phase searches over the space of programs in order of increasing discrete costs
                   using the procedure Guided-Search from Sec. 4.
               (2) Learning phase updates the PCFG using the partial solutions found in the synthesis phase.
               ProbetakesasinputaninductiveSyGuSproblemG,E.ItstartsbyinitializingthePCFGwithCFG
             GandauniformdistributionÌ†µÌ±ùÌ†µÌ±¢, which assigns every production rule R = N ‚Üí Ì†µÌªΩ the probability
            Ì†µÌ±ù(R) = 1/|R(N)|. Each iteration of the while-loop corresponds to one synthesis-learning cycle. In
            each cycle, Probe first invokes Guided-Search with the current search state. If the search finds
            a solution, Probe terminates successfully (line 7); otherwise it enters the learning phase, which
            consists of three steps. First, procedure Select selects promising partial solutions (line 8); if no
            such solutions have been found, the search simply resumes from the current state. Otherwise (line
            Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
