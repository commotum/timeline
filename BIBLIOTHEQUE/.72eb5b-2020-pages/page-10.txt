            227:10                                                Shraddha Barke, Hila Peleg, and Nadia Polikarpova
            Programs. A programÌ†µÌ±É is a sentence derivable from some N ‚àà N; we call a program whole if it is
            derivable from S. The set of all programs is called the language of the grammar G: L(G) = {Ì†µÌ±† ‚àà
             ‚àó       ‚àó
            Œ£ | N ‚áí Ì†µÌ±†}. The trace of a program tr(Ì†µÌ±É) is the sequence of production rules R ,...,R used in
                                                                                           1      Ì†µÌ±õ
            its derivation (N ‚áí Ì†µÌªº1 ‚áí ... ‚áí Ì†µÌªºÌ†µÌ±õ‚àí1 ‚áí Ì†µÌ±É). The size of a program |Ì†µÌ±É| is the length of its trace. We
            assign semantics ‚ü¶Ì†µÌ±É‚üß: Val‚àó ‚Üí Val to each program Ì†µÌ±É, where Val is the set of run-time values.
            Inductive syntax-guided synthesis. An inductive syntax-guided synthesis (SyGuS) problem is
                                                                           ‚àí‚àí‚àí‚Üí               ‚àó         7
            defined by a grammar G and a set of input-output examples E = ‚ü®Ì†µÌ±ñ,Ì†µÌ±ú‚ü©, where Ì†µÌ±ñ ‚àà Val , Ì†µÌ±ú ‚àà Val . A
            solution to the problem is a program Ì†µÌ±É ‚àà L(G) such that ‚àÄ‚ü®Ì†µÌ±ñ,Ì†µÌ±ú‚ü© ‚àà E, ‚ü¶Ì†µÌ±É‚üß(Ì†µÌ±ñ) = Ì†µÌ±ú. Without loss of
            generality, we can assume that only whole programs can evaluate to the desired outputsÌ†µÌ±ú, hence
            our formulation need not explicitly require that the solution be whole.
            Probabilistic Context-free Grammar. A probabilistic context-free grammar (PCFG) G is a pair
                                                                                                  Ì†µÌ±ù
            of a CFG G and a function Ì†µÌ±ù : R ‚Üí [0,1] that maps each production rule R ‚àà R to its probability.
            Probabilities of all the rules for given non-terminal N ‚àà N sum up to one: ‚àÄN.√çR‚ààR(N) Ì†µÌ±ù(R) = 1.
            APCFGdefinesaprobabilitydistribution on programs: a probability of a program is the product of
            probabilities of all the productions in its trace Ì†µÌ±ù(Ì†µÌ±É) = √é  Ì†µÌ±ù(R ).
                                                                   R ‚ààtr(Ì†µÌ±É)  Ì†µÌ±ñ
                                                                    Ì†µÌ±ñ
            Costs. We can define the real cost of a production as rcost(R) = ‚àílog(Ì†µÌ±ù(R)); then the real costs
            of a program can be computed as rcost(Ì†µÌ±É) = ‚àílog(Ì†µÌ±ù(Ì†µÌ±É)) = √ç         rcost(R ). For the purpose
                                                                          R ‚ààtr(Ì†µÌ±É)      Ì†µÌ±ñ
                                                                           Ì†µÌ±ñ
            of our algorithm, we define discrete costs, which are real costs rounded to the nearest integer:
            cost(R) = ‚åärcost(R)‚åâ. The cost of a program Ì†µÌ±É is defined as the sum of costs of all the productions
            in its trace: cost(Ì†µÌ±É) = √ç     cost(R ).
                                   R ‚ààtr(Ì†µÌ±É)      Ì†µÌ±ñ
                                    Ì†µÌ±ñ
            4.2  GuidedBottom-upSearchAlgorithm
            Algorithm 1 presents our guided bottom-up search algorithm. The algorithm takes as input a PCFG
            G andaset of input-output examples E, and enumerates programs in the order of increasing
             Ì†µÌ±ù
            discrete costs according to G , until it finds a program Ì†µÌ±É that satisfies the entire specification E
                                        Ì†µÌ±ù
            or reaches a certain cost limit Lim. The algorithm maintains a search state that consists of (1) the
            current cost level Lvl; (2) program bank B, which stores all enumerated programs indexed by their
            cost; (3) evaluation cache E, which stores evaluation results of all programs in B (for the purpose
            of checking observational equivalence); and (4) the set PSol, which stores all enumerated partial
            solutions. Note that the algorithm returns the current search state and optionally takes a search
            state as input; we make use of this in Sec. 5 to resume search from a previously saved state.
              Every iteration of the loop in lines 3≈õ14 enumerates all programs whose costs are equal to
            Lvl. New programs with a given cost are constructed by the auxiliary procedure New-Programs,
            which we describe below. In line 5, every new program Ì†µÌ±É is evaluated on the inputs from the
            semantic specification E; if the program matches the specification exactly, it is returned as the
            solution. Otherwise, if the evaluation result is already present in E, thenÌ†µÌ±É is deemed observationally
            equivalent to another program in B and discarded. A program with new behavior is added to the
            bank at cost Lvl and its evaluation result is cached in E; moreover, if the program satisfies some of
            the examples in E, it is considered a partial solution and added to PSol.
              The auxiliary procedure New-Programs takes in the PCFG G , the current cost Lvl, and a
                                                                             Ì†µÌ±ù
            bankBwherealllevels below the current one are fully filled. It computes the set of all programs
            of cost Lvl in G . For the sake of efociency, instead of returning the whole set at once, New-
                            Ì†µÌ±ù
            Programs is implemented as an iterator: it yields each newly constructed program lazily, and
            will not construct the whole set if a solution is found at cost Lvl. To construct a program of cost
            Lvl, the procedure iterates over all production rules R ‚àà R. Once R is chosen as the top-level
            7In general, the SyGuS problem allows first-order formulae as a specification, and prior work has shown how to reduce this
            general formulation to inductive formulation using CEGIS [Alur et al. 2017b; Lee et al. 2018].
            Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
