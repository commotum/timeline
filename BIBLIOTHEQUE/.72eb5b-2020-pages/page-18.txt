           227:18                                                Shraddha Barke, Hila Peleg, and Nadia Polikarpova
           are able to solve 48, 42 and 9 problems, respectively. Additionally, at every point after one second,
           Probehassolvedmorebenchmarksthaneithersize-based or height-based enumeration.
           Just-in-timelearningandgrammarsize.Inadditiontoourregularbenchmarksuite,wecreated
           a version of the String benchmarks (except 12 outliers that have abnormally many string literals)
           that uses an extended string grammar, which includes all operations and literals from all String
           benchmarks. In total this grammar has all available string, integer and boolean operations in the
           SyGuS language specification and 48 string literals and 11 integer literals. These 70 extended-
           grammar benchmarks allow us to test the behavior of Probe on larger grammars and thereby
           larger program spaces.
              Within a timeout of 10 minutes, Probe solves 25 benchmarks (52% of the original number)
           whereas height-based and size-based enumeration solved 1 (11% of original) and 9 (21% of original)
           benchmarks respectively as shown in Fig. 13b. We find this particularly encouraging, because
           the size of the grammar usually has a severe effect on the synthesizer (as we can see for size-
           based enumeration), so much so that carefully constructing a grammar is considered to be part
           of synthesizer design. While the baseline synthesizers need the benefit of approaching each task
           with a different, carefully chosen grammar, Probe’s just-in-time learning is much more robust to
           additional useless grammar productions. Even with a larger grammar, Probe’s search space does
           not grow as much: once it finds a partial solution, it hones in on the useful parts of the grammar.
           Results for BitVec Domain. The results for the BitVec benchmarks are shown in Fig. 13c. Out
           of the 27 BitVec benchmarks, Probe, size-based and height-based solve 21, 20 and 13 benchmarks,
           respectively. In addition to solving one more benchmark, Probe is also considerably faster than
           size-based enumeration, as we can see from the horizontal distance between the two curves on the
           graph. Probe significantly outperforms the baseline height-based enumeration technique.
           ResultsforCircuitDomain.TheresultsfortheCircuitbenchmarksareshowninFig.13d.Each
           of the three techniques solves 22 out of 31 benchmarks, with size-based enumeration outperforming
           Probeintermsofsynthesis times. The reason Probe performs worse in this domain is that the
           Circuit grammar is very small (only four operations in the median case) and the solutions tend to
           use most of productions from the grammar. Thus, rewarding specific productions in the PCFG does
           not yield significant benefits, but in fact the search is slowed down due to the restarting overhead
           incurred by Probe.
           Summaryofresults.Outofthe210benchmarksfromthreedifferentdomainsandtheextended
           String grammar, Probe solves 116, size-based solves 93 and height-based solves 45. We conclude
           that overall, Probe outperforms both baseline techniques, and is therefore an effective
           synthesis technique.
           6.3   Q1.2: Selection of partial solutions
           In this section, we empirically evaluate the schemes for selecting promising partial solutions.
           Wecomparefourdifferent schemes: the three described in Sec. 5.2 and the baseline of using all
           generated partial solutions. The results are shown in Fig. 14.
              Theallbaselineschemeperformsconsistentlyworsethantheotherschemesonallthreedomains
           (and also worse than unguided size-based enumeration). For the circuit domain (Fig. 14c), the all
           scheme solves none of the benchmarks. The performance of the remaining schemes is very similar,
           indicating that the general idea of leveraging small and semantically unique partial solutions to
           guide search is robust to minor changes in the selection criteria. We select First Cheapest as the
           schemeusedinProbesinceitprovidesabalancebetweenrewardingfewpartialsolutions while
           still considering syntactically different approaches.
           Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
