            Just-in-Time Learning for Bottom-Up Enumerative Synthesis                                    227:21
            median times of 193.6s and 36s. CVC4 solves 19 benchmarks with average and median times of
            60s and 41s. Probe outperforms both CVC4 and EuPhony in terms of the number of benchmarks
            solved. Moreover CVC4 generates much larger solutions than Probe, as discussed in Sec. 6.5.
            Summaryofresults.Ofthetotal140benchmarks,Probesolves91withinthe10-minutetimeout,
            EuPhonysolves50,andCVC4solves107.ProbeoutperformsEuPhony’spre-learnedmodelsinall
            three domains, and while CVC4 outperforms Probe in the String domain; the next subsection will
            discuss the quality of the results it generates.
            6.5   Q3:Qualityofsynthesizedsolutions
            So far, we have tested the ability of solvers to arrive at a solution, without checking what the
            solution is. When a PBE synthesizer finds a program for a given set of examples, it guarantees
            nothing but the behavior on those examples. Indeed, the SyGuS Competition scoring system9
            awardsthemostpoints(five)forsimplyreturninganyprogramthatmatchesthegivenexamples.It
            is therefore useful to examine the quality of the solutions generated by Probe and its competition.
              Size is a common surrogate measure for program simplicity: e.g., the SyGuS Competition awards
            anadditionalpointtothesolverthatreturnsthesmallestprogramforeachbenchmark.Programsize
            reflects two sources of complexity: (i) unnecessary operations that do not influence the result, and,
            perhaps more importantly, (ii) case splitting that overfits to the examples. It is therefore reasonable
            to assume that a smaller solution is more interpretable and generalizes better to additional inputs
            beyondtheinitial input-output examples.
              Based on these observations, we first estimate the quality of results for all three domains by
            comparing the sizes of solutions generated by Probe and other tools. We next focus on the String
            benchmarks, as this is the only domain where the specification is given in the form of input-output
            examples, and hence is prone to overfitting. For this domain, we additionally measure the number
            of case splits in generated solutions and test their generalization accuracy on unseen inputs.
            Size of generated solutions. Fig. 16 shows the sizes of Probe solutions in AST nodes, as compared
            to size-based enumeration (which always returns the smallest solution by definition), as well as
            EuPhonyandCVC4.Eachcomparisonislimitedtothebenchmarksbothtoolscansolve.
            String domain. First, we notice in Fig. 16a that Probe sometimes finds larger solutions than
            size-based enumeration, but the difference is small. Likewise, Fig. 16b shows that EuPhony and
            Probereturn similar-sized solutions. Probe returns the smaller solutions for 10 benchmarks, but
            the difference is not large. On the other hand, CVC4 solutions (Fig. 16c) are larger than Probe’s
            on41outof45benchmarks,sometimesbyasmuchastwoordersofmagnitude.Fortheremaining
            four benchmarks, solution sizes are equal. On one of the benchmarks not solved by Probe (and
            therefore not in the graph), CVC4 returns a result with over 7100(!) AST nodes.
            Otherdomains.Fig.16dshowsthatontheBitVecdomainProbefindstheminimalsolutionin
                                                                                                          10
            all cases except one. Solutions by EuPhony (Fig. 16e) and CVC4 (Fig. 16f) are slightly larger   in
            one (resp. two) cases, but the difference is small. For the Circuit benchmarks, Probe always finds
            minimal solutions, as shown in Fig. 16g. Both EuPhony (Fig. 16h) and CVC4 (Fig. 16i) generate
            larger solutions for all of the commonly solved benchmarks. Hence, on the Circuit domain, Probe
            outperforms its competitors with respect to both synthesis time and solution size.
            Case splitting. So why are the CVC4 String programs so large? Upon closer examination, we
            determined that they perform over-abundant case splitting, which hurts both readability and
            generality. To confirm our intuition, we count the number of if-then-else operations (ite) in the
            9https://sygus.org/comp/2019/results-slides.pdf, slide 13
            10Note that we use linear scale for BitVec and Circuit as opposed to logarithmic scale for String.
                                 Proc. ACMProgram. Lang., Vol. 4, No. OOPSLA, Article 227. Publication date: November 2020.
