                                                                                                                                   review articles
            returns x. Now the verifier checks if  learning problem is based on enu-                        and y + y, in that order. Of these, the 
            setting f (x, y) = x satisfies the logical      merating all expressions in Exp one by          first one is equivalent to x, and the 
            specification; that is, it checks               one in increasing order of size, and  next two are equivalent to y, and hence 
            the validity of the formula  
                                                            checking for each one if it satisfies  discarded. The expression y + y is the 
            (x ≥ x) ∧ (x ≥ y) ∧ (x ∈ {x, y}). This for-     Spec for all inputs in Examples. Since          only interesting example of size 3, and 
            mula does not hold for all values of x          the number of expressions grows  the algorithm checks if it satisfies the 
            and  y, and the verifier returns one  exponentially with the size, we need  specification. Indeed that is the case, 
            such counterexample, say, (x = 0, y =           some heuristics to prune the search  and the learner returns y + y. The veri-
            1). This input is added to the set  space. An optimization that turns out                       fier will discover that this solution 
            Examples, and the learner now needs             to be effective is based on a notion of         does not satisfy the specification for 
            to find a solution for f that satisfies         equivalence among expressions with  all inputs, and will generate a coun-
            the specification at least for this  respect to the given set of inputs. Let                    terexample, say, (x = 1, y = 0). Note that 
            input. The learner can possibly return          us say that two expressions e1 and e2           adding this input to Examples changes 
            the expression y, and when the veri-            are  Examples-equivalent if for all  the notion of equivalence of expres-
            fier checks the validity of this answer         inputs in Examples, e1 and e2 evaluate          sions (for instance, the size 1 expres-
            it returns (x = 1, y = 0) as a counterex-       to the same value. Notice that if e is an       sions x and 0 are no longer equivalent), 
            ample. Figure 2 shows the expres-               expression that contains e1 as a subex-         so in the next iteration, the learning 
            sions learnt and the corresponding  pression, and if we obtain e′ by substi-                    algorithm needs to start enumeration 
            counterexamples produced by the  tuting e1 by another expression e2 that                        from scratch.
            verifier in successive iterations. For  is Examples-equivalent to e1, then e′ is                   We conclude the discussion of the 
            instance, in iteration 4, the learner  guaranteed to be Examples-equivalent                     enumerative search algorithm with a 
            attempts to find a candidate solution           to e. As a result, the enumeration algo-        few observations. First, if the set Exp  
            that satisfies the specification for the        rithm maintains a list of only inequiv-         is unbounded, the algorithm may 
            inputs (0, 1), (1, 0), and (0, 0), and f (x,    alent expressions. To construct the  simply keep enumerating expres-
            y) = x + y is indeed such a plausible  next expression, it uses only the  sions of larger and larger size without 
            answer. The verifier then checks the  expressions from this list as potential                   ever finding one that satisfies the 
            validity of (x + y ≥ x) ∧ (x + y ≥ y) ∧ (x +    subexpressions, and as a new expres-            specification. Second, if we know (or 
            y ∈ {x, y}) and returns (x = 1, y = 1) as a     sion is constructed, it first checks if it      impose) a bound k on the depth of the 
            counterexample. In the subsequent  is equivalent to one already in the list,                    expression we are looking for, the 
            iteration, when the learner attempts  and if so, discards it.                                   number of possible expressions is 
            to find a solution that fits all the four          To illustrate the algorithm, sup-            exponential in k. The equivalence-
            inputs currently in Examples, the  pose the logical specification is Spec2,                     based pruning leads to significant 
            shortest expression possible is ITE( (x         the set of expressions is Exp , and the         savings, but the exponential depen-
                                                                                             1
            ≤ y), y, x), which the verifier finds to be     current set of Examples contains a  dence remains. Fin ally, to translate 
            a valid solution.                               single input (x = 0, y = 1) (as noted ear-      the idea described above to an actual 
               Given a candidate solution for the           lier). The job of the learning algorithm        algorithm that works for the set of 
            desired function, checking whether it           is to find an expression e that satisfies       expressions described by a context-
            satisfies the logical specification for         Spec  for x = 0 and y = 1, that is, e(0, 1)     free grammar some fine-tuning is 
                                                                 2
            all inputs is a standard verification  > 1. Two expressions are equivalent in                   needed. For example, consider the 
            problem, and we can rely upon a  this case if e (0, 1) = e (0, 1). The enu-                     grammar for the set Exp  of linear 
                                                                           1          2                                                     2
            mature verification technology such  merator starts by listing expressions  expressions with conditionals, the 
                                                        5   of size 1 one by one. The first expres-         algorithm needs to enumerate 
            as SMT solvers for this purpose.
            Learning an expression from the set  sion considered is x. It is added to the                   (inequivalent) expressions generated 
            Exp of candidate expressions that sat-          list, and since it does not satisfy the         by both non-terminals T and C con-
            isfies the specification for the current        specification, the search continues.  currently by employing a dynamic 
                                                                                                                                                        2 
            inputs in Examples is a new challenge,          The next expression is y, which is  programming strategy (see Alur et al.  
                                                                                                                                32).
            and has been the focus of research in           inequivalent to x and does not satisfy          and Udupa et al.
            design and implementation of SyGuS              the specification, so is added to the 
            solvers.                                        list and the search continues. The  An Infrastructure for Solvers
               Enumerative search. Given a set  next expression is 0, which turns out                       In the world of constraint solving, the 
            Exp of candidate expressions speci-             to be equivalent to x (both evaluate to         standardization of the input format, 
            fied by a (context-free) grammar, a  0 for the input (0, 1) ), and is hence dis-                collection and categorization of a 
            finite set Examples of inputs, and a  carded. The next expression is 1,  large number of benchmarks, access 
            logical specification Spec, the learn-          which is also discarded as it is equiva-        to open-source computational infra-
            ing problem is to find an expression e          lent to y. Next the algorithm considers         structure, and organization of an 
            in Exp such that Spec[f/e] is satisfied         the expressions generated by the  annual competition of solvers, had a 
            for all inputs in Examples.  application of the rule E + E. The algo-                           transformative impact on both the 
            Furthermore, we want to find the sim-           rithm considers only x and y as poten-          development of powerful computa-
            plest such expression.                          tial subexpressions at this step, and  tional techniques and the practical 
                                                                                                                                                        5 
               The simplest solution to the  thus, examines only x + x, x + y, y + x,                       applications to diverse problems.
                                                                                         DECEMBER 2018 |  VOL. 61  |  NO. 12  |  COMMUNICATIONS OF THE ACM    89
