                 synthesis [17]–[19] seeks to ﬁnd a program matching a set                                        INITIALIZE       “Concept Class”, Initial Examples
                 of input-output examples. It is thus an instance of learning
                 from examples, also termed as inductive inference or machine
                 learning [20], [21]. Many current approaches to synthesis                                                             Candidate
                 blend induction and deduction [22]; syntax guidance is usually                                                         Concept
                 a key ingredient in these approaches.
                    Inductive synthesizers generalize from examples by search-                                    LEARNING                               VERIFICATION
                 ing a restricted space of programs. In machine learning, this                                   ALGORITHM                                   ORACLE
                 restricted space is called the concept class, and each element                                                    Counterexample
                 of that space is often called a candidate concept. The concept
                 class is usually speciﬁed syntactically. Inductive learning is                                   Learning Fails                         Learning Succeeds
                 thus a natural ﬁt for the syntax-guided synthesis problem
                 introduced in this paper: the concept class is simply the set L                              Fig. 1.   Counterexample-Guided Inductive Synthesis (CEGIS)
                 of permissible expressions.                                                           repair in the former case, and synthesizing an abstraction
                 A. Synthesis via Active Learning                                                      function in the latter (see [22] for a more detailed discussion).
                                                                                                          The deﬁning aspect of CEGIS is its example selection strat-
                    Acommon approach to inductive synthesis is to formulate                            egy: learning from counterexamples provided by a veriﬁcation
                 the overall synthesis problem as one of active learning using                         oracle. The learning algorithm, which is initialized with a
                 a query-based model. Active learning is a special case of                             particular choice of concept class L and possibly with an initial
                 machine learning in which the learning algorithm can control                          set of (positive) examples, proceeds by searching the space of
                 the selection of examples that it generalizes from and can                            candidate concepts for one that is consistent with the examples
                 query one or more oracles to obtain both examples as well as                          seen so far. There may be several such consistent concepts,
                 labels for those examples. In our setting, we can consider the                        and the search strategy determines the chosen candidate, an
                 labels to be binary: positive or negative. A positive example                         expression e. The concept e is then presented to the veriﬁcation
                 is simply an interpretation to f in the background theory                             oracle O , which checks the candidate against the correctness
                                                                                                                  V
                 T that is consistent with the speciﬁcation ϕ; i.e., it is a                           speciﬁcation. OV can be implemented as an SMT solver that
                 valuation to the arguments of the function symbol f along with                        checks whether ϕ[f/e] is valid modulo the theory T. If the
                 the corresponding valuation of f that satisﬁes ϕ. A negative                          candidate is correct, the synthesizer terminates and outputs this
                 example is any interpretation of f that is not consistent with ϕ.                     candidate. Otherwise, the veriﬁcation oracle generates a coun-
                 Werefer the reader to a paper by Angluin [23] for an overview                         terexample, an interpretation to the symbols and free variables
                 of various models for query-based active learning.                                    in ϕ[f/e] that falsiﬁes it. This counterexample is returned to
                    In program synthesis via active learning, the query oracles                        the learning algorithm, which adds the counterexample to its
                 are often implemented using deductive procedures such as                              set of examples and repeats its search; note that the precise
                 model checkers or satisﬁability solvers. Thus, the overall                            encoding of a counterexample and its use can vary depending
                 synthesis algorithm usually comprises a top-level inductive                           onthedetails of the learning algorithm employed. It is possible
                 learning algorithm that invokes deductive procedures (query                           that, after some number of iterations of this loop, the learning
                 oracles); e.g., in our problem setting, it is intuitive, although                     algorithm may be unable to ﬁnd a candidate concept consistent
                 not required, to implement an oracle using an SMT solver for                          with its current set of (positive/negative) examples, in which
                 the theory T. Even though this approach combines induction                            case the learning step, and hence the overall CEGIS procedure,
                 and deduction, it is usually referred to in the literature simply                     fails.
                 as “inductive synthesis.” We will continue to use this termi-                            Several search strategies are possible for learning a can-
                 nology in the present paper.                                                          didate expression in L, each with its pros and cons. In the
                    Consider the syntax-guided synthesis problem of Sec. II.                           following sections, we describe three different search strategies
                 Given the tuple (T, f, ϕ, L), there are two important choices                         and illustrate the main ideas in each using a small example.
                 one must make to ﬁx an inductive synthesis algorithm: (1)
                 search strategy: How should one search the concept class L?                           C. Illustrative Example
                 and (2) example selection strategy: Which examples do we
                 learn from?                                                                              Consider the problem of synthesizing a program which
                                                                                                       returns the maximum of two integer inputs. The speciﬁcation
                 B. Counterexample-Guided Inductive Synthesis                                          of the desired program max is given by:
                    Counterexample-guided inductive synthesis (CEGIS) [16],
                 [24] shown in Figure 1 is perhaps the most popular approach                                           max(x,y) ≥ x ∧ max(x,y) ≥ y ∧
                 to inductive synthesis today. CEGIS has close connections                                                 (max(x,y) = x∨max(x,y) = y)
                 to algorithmic debugging using counterexamples [19] and
                 counterexample-guided abstraction reﬁnement (CEGAR) [25].                                The search space is suitably deﬁned by an expression
                 This connection is no surprise, because both debugging and                            grammar which includes addition, subtraction, comparison,
                 abstraction-reﬁnement involve synthesis steps: synthesizing a                         conditional operators and the integer constants 0 and 1.
