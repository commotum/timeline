             Published as a conference paper at ICLR 2024
             concatenating these components’ text data, we first remove any Markdown-style comments, then
             look through the remaining text for references to issue numbers (a pound # sign followed by a
             number) and check whether the word preceding the issue number reference is included in a set of
             keywords suggesting that the issue was resolved by the PR (e.g. “closes”, “fixes”, “resolves”). The
             found issues are recorded in the issue numbers field, then separate web requests are made to
             retrieve each issue’s data. To form the problem statement, each issue’s title and body are
             addedtogether and then concatenated with the next issue’s if there are multiple. It is also during this
             step that the hints text field is created and collected from the PR’s comment section, where text
             fromcommentscreatedbeforethePR’sinitialcommit. Theintuitionforthiscollectionmethodology
             is that such PR comments would likely contain natural language and pseudo-code suggestions to
             the original human task worker regarding how to complete the problem at hand. The experiments
             presented in this work do not make use of hints text, but we believe this information may be
             interesting for future investigations.
             Codebase. The codebase C content is not stored in plaintext for every task instance. Rather, the
             task instance contains a reference to the relevant codebase via the repo and base commit field.
             Both fields are available in the original PR’s data. To make retrieval of the codebase C from these
             two elements reproducible and reliable, we create mirrors of the original repository. Mirrors for
             the repository constituting both the evaluation and fine tuning data are collected and open-sourced
             undertheSWE-benchGitHuborganization. Becauseanoriginalrepository’scodemaybesubjectto
             changes in its commit and edit history outside of the authors’ control, we choose to create a mirror
             repository to ensure that later modifications to the codebase do not potentially render a task instance
             unusable due to a corruption or removal of the associated base commit. Additionally, we create
             a mirror instead of cloning and storing the latest version of a repository. This is because a mirror
             retains the original commit hashes, history, branches, and tags, serving as a faithful and complete
             history of the technical details of the original repository. A mirror does not retain stars, watchers,
             issues, or pull requests from the original repository.
             Wecreate a mirror from a repository after and within the same day when task instances were col-
             lected. The mirror retains the original repository’s “owner/name” moniker, except that the “/”
             character is converted to a “ ” to confirm to GitHub naming conventions. Given this infrastructure,
             retrieving a task instance’s codebase is straightforward. First, the correct mirror can be cloned from
             the SWE-bench organization using repo. Next, within the local copy of the mirror, checking out
             the base commit will reset the repository to codebase C. To proceed to another task instance
             from the same repository, git version control is used to automatically remove any modifications
             associated with the current task instance before checking out the next task instance’s base commit.
             Solution, Test Patches. The solution δ and tests T are derived from the file changes data, or diff,
             of a PR. As mentioned in Section 2.1, the original diff along with solution δ and tests T are
             represented as a .patch file, a format for efficiently specifying transformations to line-based text
             files. Generally speaking, a .patch is structured as a list of blocks, where each block consists of
             a header and one or more hunks that collectively correspond to changes to a single file. The header
             contains metadata specifying a file path and line numbers, while the actual modifications to the
             target file are encoded as multiple lines prefixed by “+” and “-” to indicate additions and removals.
             To create the tests T, we first identifying every unique block within the patch, then pick out and
             conglomerate blocks with file paths that contain testing-related keywords (e.g. “tests”, “testing”).
             The remaining blocks are merged to form the solution δ. We validate the robustness of the script
             written to parse correctly T and δ by applying both patches to the corresponding codebase C and
             running the tests; we then check that the results reproduce the behavior of the base PR’s diff data.
             Thesolution δ is saved as the patch field while the tests T are saved as the test patch field.
             RemainingFields. Thecreated atfieldisatimestampthatspecifieswhenthebasePRwascre-
             ated. We retain the created at field from the original data and use this field to perform temporal
             analysis of model performance. The version field is a string that corresponds to the release ver-
             sion, with respect to the repo, during which the PR was released. Depending on availability and the
             amount of effort required for each method, we create the version field by retrieving the informa-
             tion directly from the source code, building the repository locally and invoking code to display the
             version to standard output, or comparing the created at field with a timeline of release versions
              Documentation for creating a mirror repository using GitHub
                                  17
