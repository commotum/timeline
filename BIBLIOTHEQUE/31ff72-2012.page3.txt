               3.   OVERVIEW                                                           Thesynthesis algorithm Synthesize involves invoking the
                 We describe our expressive transformation language and             GenerateStr procedure on each input-output example, and
               associated data structures and algorithms for inductive syn-         intersecting the results using the Intersect procedure:
                                                                                         Synthesize((σ ,s ),...,(σ ,s ))
               thesis in two steps (§4 and §5). In this section, we introduce                           1   1         n n
                                                                                        1 P :=GenerateStr(σ ,s );
               the common formalism and our user interaction model (as                                           1  1
               derived from recent work on inductive synthesis [8, 9]).                 2 for i = 2 to n:
                                                                                        3    P0 := GenerateStr(σ ,s );P := Intersect(P,P0);
               3.1    Formalism                                                                                     i  i
                                                                                        4 return P;
               Transformation language L. The ﬁrst step in inductive                Ranking. An expressive domain-speciﬁc language L for in-
               synthesis is to deﬁne a domain speciﬁc language that is ex-          ductive synthesis can often require a large number of ex-
               pressive enough to capture several real-world tasks, but at          amples to learn the intended transformation. We address
               the same time is restrictive enough to enable eﬃcient learn-         this problem by developing a ranking scheme that can be
               ing from input-output examples. In this paper, we introduce          used to rank the possibly large number of transformation ex-
               a string transformation expression language L, which con-            pressions that are consistent with a small number of input-
               tains expressions e that map an input state σ, which holds           output examples. This ranking scheme is inspired by the
               values for m string variables v ,..,v  (denoting the multiple
                                              1     m                               Occam’s razor principle, which states that a smaller and
               input columns in a spreadsheet), to an output string s.              simpler explanation is usually the correct one. We deﬁne a
                         e : (String × ... × String) → String                       comparison scheme between diﬀerent expressions by deﬁn-
               This formalism can also be used for string processing tasks          ing a partial order between them. Any partial order can be
               that require generating a tuple of n strings as output by            used that is consistent with the sharing used in data struc-
               solving n independent problems. We characterize an ex-               ture D for succinct representation of sets of such expressions.
               pression language L with the following components: (a) a             In other words, the comparison of any two sub-expressions
               set of grammar rules R, (b) a top-level symbol e, which is a         should be based only on attributes that are not shared at
               uniquely distinguished non-terminal symbol occurring in R.           the level of the sub-expressions. This allows us to eﬃciently
               §4.1 and §5.1 describe two examples of such a language.              identify the top ranked expressions from among a set of ex-
               Data structure D for set of expressions in L. The num-               pressions represented using D. We give examples of such a
               ber of transformation expressions that are consistent with a         ranking scheme in §4.4 and §5.4. Some of these choices are
               given set of input-output examples can be huge. We deﬁne             subjective, but our experiments illustrate that our ranking
               a data structure D to succinctly represent such a large set          scheme works very eﬀectively in practice: all of our bench-
               of expressions. We describe D itself using a set of gram-            mark tasks required at most 3 input-output examples.
                           ˜
               mar rules R with top-level symbol e˜.       §4.2 and §5.2 de-
               scribe examples of such a data structure that uses a top-level       3.2    User Interaction Model
               graph/DAG representation respectively.                                  The user expresses her intent of the task using few input-
               Synthesis algorithm: GenerateStr and Intersect. The                  output examples. The synthesizer based on the above for-
               inductive synthesis algorithm Synthesize for an expression           malism then generates a ranked set of transformations that
               language L learns the set of expressions in L (represented           are consistent with those examples. We describe below some
               using data structure D) that are consistent with a given set         interaction techniques for automating the desired task or for
               of input-output examples. Our synthesis algorithm consists           generating a reusable transformation.
               of the following two procedures:                                        The user can run the top-ranked synthesized transforma-
               • The GenerateStr procedure for computing the set of all             tion on other inputs in the spreadsheet and check the gener-
                  expressions (represented using data structure D) that are         ated outputs. If any output is incorrect, the user can ﬁx it
                  consistent with a given input-output example.                     and the synthesizer can repeat the learning process with the
               • The Intersect procedure for intersecting two sets of ex-           additional example that the user provided as a ﬁx. Requir-
                  pressions (represented using data structure D). We de-            ing the user to check the results of the synthesizer, especially
                  scribe Intersect procedure also using a set of rules.             onalargespreadsheet, can be cumbersome. Toenableeasier
                                                                                    interaction, the synthesizer can run all transformations on
                 Definition 1. (Soundness/k-completeness of Generate-               each new input to generate a set of corresponding outputs
               Str) Let e˜ = GenerateStr(σ,s). We say that GenerateStr              for that input. The synthesizer can then highlight those in-
               procedure is sound if all expressions in e˜ are consistent with      puts (for user inspection) whose corresponding output set
               the input-output example (σ,s). We say that GenerateStr              contains at least two outputs. The user can then focus their
               procedure is k-complete if e˜ includes all expressions with at       inspection on the highlighted inputs. Our prototype, imple-
               most k recursive sub-expressions that are consistent with the        mented as an Excel add-in, supports this interaction model
               input-output example (σ,s).                                          (which is also used in [8]).
                                                                                       On the other hand, if the user wishes to learn a reusable
                 Definition 2. (Soundness/Completeness of Intersect)                script, then the synthesizer may present the set of synthe-
                    00                  0                                           sized transformations to the user. Either the top-k trans-
               Let e˜ = Intersect(e,˜ e˜ ). We say that Intersect is sound
                                   00                                               formations can be shown, or the synthesizer can walk the
               and complete iﬀ e˜ includes all expressions that belong to
                            0                                                       user through the data structure that succinctly represents
               both e˜ and e˜ .
                                                                                    all consistent transformations and let the user select the de-
                 §4.3 and §5.3 give examples of GenerateStr/Intersect               sired one. The transformations can be shown using the sur-
               procedures that are sound and k-complete/complete and                face syntax, or can be paraphrased in a natural language.
               that have polynomial time complexity.                                The diﬀerences between diﬀerent transformations can also
                                                                                742
