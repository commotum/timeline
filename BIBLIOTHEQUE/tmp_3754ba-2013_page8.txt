               but the overall trend we observe is that the encoding of                      Acknowledgements: We thank Nikolaj Bjorner and Stavros
               the problem space into grammar has a signiﬁcant impact on                  Tripakis for their feedback. This research is supported by the
               performance, although the solvers are often good at mitigating             NSF Expeditions in Computing project ExCAPE (award CCF
               the effect of larger search spaces. We can also see that non-              1138996).
               symbolic techniques can be effective in exploring spaces of                                            REFERENCES
               implementations and can surpass symbolic techniques, espe-
               cially when the problems do not require the synthesizer to                  [1] C. Barrett, R. Sebastiani, S. A. Seshia, and C. Tinelli, “Satisﬁability
               derive complex bit-vector constants, which is true for all the                  modulo theories,” in Handbook of Satisﬁability, 2009, vol. 4, ch. 8.
               bit-vector benchmarks used. Moreover, we observe that the                   [2] L. M. de Moura and N. Bjørner, “Satisﬁability modulo theories: Intro-
                                                                                               duction and applications,” Commun. ACM, vol. 54, no. 9, 2011.
               enumerative technique was better than the stochastic search for             [3] Z. Manna and R. Waldinger, “A deductive approach to program synthe-
               all but two benchmarks, so although both implementations are                    sis,” ACM TOPLAS, vol. 2, no. 1, pp. 90–121, 1980.
                                                                                                                                  ´
               immature, these results suggest that it may be easier to derive             [4] A. Solar-Lezama, R. Rabbah, R. Bodık, and K. Ebcioglu, “Programming
                                                                                               by sketching for bit-streaming programs,” in PLDI, 2005.
               good pruning rules for the explicit search than an effective                [5] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan, “Synthesis of loop-
               ﬁtness function for the stochastic solver.                                      free programs,” SIGPLAN Not., vol. 46, pp. 62–73, June 2011.
                 The symbolic solver used for these experiments represents                 [6] S. Gulwani, W. R. Harris, and R. Singh, “Spreadsheet data manipulation
                                                                                               using examples,” Commun. ACM, vol. 55, no. 8, pp. 97–105, 2012.
               one of many possible approaches to encoding the synthesis                   [7] S. Jha, S. Gulwani, S. A. Seshia, and A. Tiwari, “Oracle-guided
               problem into a series of constraints. We have some evidence                     component-based program synthesis,” in ICSE, 2010, pp. 215–224.
               that more optimized encodings can make the symbolic ap-                     [8] A. Udupa, A. Raghavan, J. V. Deshmukh, S. Mador-Haim, M. M. Martin,
                                                                                               and R. Alur, “TRANSIT: Specifying Protocols with Concolic Snippets,”
               proach more competitive, although there are still many prob-                    in PLDI, 2013, pp. 287–296.
               lems for which the enumerative approach is more effective.                  [9] S. Srivastava, S. Gulwani, and J. S. Foster, “From program veriﬁcation
               Speciﬁcally, we have transcribed all the hacker’s delight and                   to program synthesis,” in POPL, 2010, pp. 313–326.
                                                                                          [10] V. Kuncak, M. Mayer, R. Piskac, and P. Suter, “Software synthesis
               integer benchmarks into the input language of the Sketch                        procedures,” Commun. ACM, vol. 55, no. 2, pp. 103–111, 2012.
               synthesis system [24]. Sketch completed all but 11 of the hd               [11] E. Schkufza, R. Sharma, and A. Aiken, “Stochastic superoptimization,”
               benchmarks, and it was able to synthesize array-search                          in ASPLOS, 2013, pp. 305–316.
                                                                                                      ´
                                                                                          [12] M. Colon, S. Sankaranarayanan, and H. Sipma, “Linear invariant gener-
               up to size 7. This experiment is not an entirely fair comparison                ation using non-linear constraint solving,” in CAV, 2003, pp. 420–432.
               because, although Sketch uses a specialized constraint solver              [13] A. Rybalchenko, “Constraint solving for program veriﬁcation: Theory
               and carefully tuned encodings, the symbolic solver presented                    and practice by example,” in CAV, 2010, pp. 57–71.
                                                                                          [14] R. Sharma, S. Gupta, B. Hariharan, A. Aiken, P. Liang, and A. V. Nori,
               in this paper uses a direct encoding of the problem into                        “A data driven approach for algebraic loop invariants,” in ESOP, 2013,
               sequences of constraints and uses Z3, a widely used off-                        pp. 574–592.
               the-shelf SMT solver which is not as aggressively tuned for                [15] N. Bjørner, K. L. McMillan, and A. Rybalchenko, “On solving univer-
                                                                                               sally quantiﬁed Horn clauses,” in SAS, 2013, pp. 105–125.
                                                                                                                                  ´
               synthesis problems. Despite these limitations, the symbolic                [16] A. Solar-Lezama, L. Tancau, R. Bodık, S. A. Seshia, and V. Saraswat,
               solver was able to solve many of the benchmarks, providing a                    “Combinatorial sketching for ﬁnite programs,” in ASPLOS, 2006.
               lower bound on what can be achieved with a straightforward                 [17] E. M. Gold, “Language identiﬁcation in the limit,” Information and
                                                                                               Control, vol. 10, no. 5, pp. 447–474, 1967.
               use of off-the-shelf technology.                                           [18] P. D. Summers, “A methodology for LISP program construction from
                 Moreover, the enumerative solver was able to solve more                       examples,” J. ACM, vol. 24, no. 1, pp. 161–175, 1977.
               hd problems than even the more optimized symbolic solver.                  [19] E. Y. Shapiro, Algorithmic Program Debugging. Cambridge, MA, USA:
                                                                                               MIT Press, 1983.
               The problems where the enumerative solver succeeded but                    [20] D. Angluin and C. H. Smith, “Inductive inference: Theory and methods,”
               Sketch failed were the d5 versions of problems 11, 12, 14                       ACM Computing Surveys, vol. 15, pp. 237–269, Sep. 1983.
               and 15, which suggests that the enumerative solver was better              [21] T. M. Mitchell, Machine Learning.   McGraw-Hill, 1997.
                                                                                          [22] S. A. Seshia, “Sciduction: Combining induction, deduction, and structure
               at pruning unnecessary instructions from the grammar. On                        for veriﬁcation and synthesis,” in DAC, 2012, pp. 356–365.
               the other hand, the more optimized symbolic solver did have                [23] D. Angluin, “Queries and concept learning,” Machine Learning, vol. 2,
               a signiﬁcant advantage in the array-search benchmarks                           pp. 319–342, 1988.
                                                                                          [24] A. Solar-Lezama, “Program synthesis by sketching,” Ph.D. dissertation,
               which the enumerative solver could only solve up to size 4.                     University of California, Berkeley, 2008.
                                                                                          [25] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith,
                                        V. CONCLUSIONS                                         “Counterexample-guided abstraction reﬁnement for symbolic model
                 Aimed at formulating the core computational problem                           checking,” J. ACM, vol. 50, no. 5, pp. 752–794, 2003.
                                                                                          [26] B. McKenzie, “Generating strings at random from a context free
               common to many recent tools for program synthesis in a                          grammar,” 1997.
               canonical and logical manner, we have formalized the problem               [27] H. S. Warren, Hacker’s Delight.  Boston, MA, USA: Addison-Wesley
               of syntax-guided synthesis. Our prototype implementation of                     Longman Publishing Co., Inc., 2002.
               the three approaches to solve this problem is the ﬁrst attempt
               to compare and contrast existing algorithms on a common set
               of benchmarks. We are already working on the next steps in
               this project. These consist of (1) ﬁnalizing the input syntax
               (SYNTH-LIB) based on the input format of SMT-LIB2, with
               an accompanying publicly available parser, (2) building a
               more extensive and diverse repository of benchmarks, and
               (3) organizing a competition for SyGuS-solvers. We welcome
               feedback and help from the community on all of these steps.
