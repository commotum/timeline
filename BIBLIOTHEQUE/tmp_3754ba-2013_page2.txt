             concrete parts of the partial program and the assertions into         to a ﬁrst order formula in the background theory with all
             the speciﬁcation formula ϕ, while the holes will be represented       its variables universally quantiﬁed, and (3) the universe of
             with the unknown functions to be synthesized, and the space           possible functions f is restricted to syntactic expressions
             of expressions that can substitute the holes will be captured         described by a grammar. We now elaborate on each of these
             by the grammar.                                                       points.
                Compared to the classical formulation of the synthesis               Background Theory: The syntax for writing speciﬁcations is
             problem that involves only the correctness speciﬁcation, the          the same as classical typed ﬁrst-order logic, but the formulas
             syntax-guided version has many potential beneﬁts. First, the          are evaluated with respect to a speciﬁed background theory
             user can use the candidate set L to limit the search-space for        T. The theory gives the vocabulary used for constructing
             potential implementations, and this has signiﬁcant computa-           formulas, the set of values for each type, and the interpretation
             tional beneﬁts for solving the synthesis problem. Second, this        for each of the function and relation (predicate) symbols in
             approach gives the programmer the ﬂexibility to express the           the vocabulary. We are mainly interested in theories T for
             desired artifact using a combination of syntactic and semantic        which well-understood decision procedures are available for
             constraints. Such forms of multi-modal speciﬁcations have the         determining satisfaction modulo T (see [1] for a survey).
             potential to make programming more intuitive. Third, the set          A typical example is the theory of linear integer arithmetic
             L can be used to constrain the space of implementations for           (LIA) where each variable is either a boolean or an integer,
             the purpose of performance optimizations. For example, to             and the vocabulary consists of boolean and integer constants,
             optimize the computation of the product of two two-by-two             standard boolean connectives, addition (+), comparison (≤),
             matrices, we can limit the search space to implementations that       and conditionals (ITE). Note that the background theory can
             use only 7 multiplication operations, and such a restriction can      be a combination of logical theories, for instance, LIA and the
             be expressed only syntactically. Fourth, because the synthesis        theory of uninterpreted functions with equality.
             problem boils down to ﬁnding a correct expression from the              Correctness Speciﬁcation: For the function f to be syn-
             syntactic space of expressions, this search problem lends itself      thesized, we are given the type of f and a formula ϕ as
             to machine learning and inductive inference as discussed in           its correctness speciﬁcation. The formula ϕ is a Boolean
             Section III. Finally, it is worth noting that the statement “there    combination of predicates from the background theory, in-
             exists an expression e in the language generated by a context-        volving universally quantiﬁed free variables, symbols from the
             free grammar G such that the formula ϕ[f/e] is valid in a             background theory, and the function symbol f, all used in a
             theory T” cannot be translated to determining the truth of a          type-consistent manner.
             formula in the theory T, even with additional quantiﬁers.               Example 1: Assuming the background theory is LIA, con-
                The rest of the paper is organized in the following manner.        sider the speciﬁcation of a function f of type int×int 7→ int:
             In Section II, we formalize the core problem of syntax-                          ϕ : f(x,y) = f(y,x) ∧ f(x,y) ≥ x.
             guided synthesis with examples. In Section III, we discuss                         1
             a generic architecture for solving the proposed problem us-           The free variables in the speciﬁcation are assumed to be
             ing the iterative counter-example guided inductive synthesis          universally quantiﬁed: a given function f satisﬁes the above
             strategy [16] that combines a learning algorithm with a ver-          speciﬁcation if the quantiﬁed formula ∀x,y.ϕ1 holds, or
             iﬁcation oracle. For the learning algorithm, we show how              equivalently, if the formula ϕ is valid.
                                                                                                                  1
             three techniques from recent literature can be adapted for our          Set of Candidate Expressions: In order to make the synthe-
             purpose: the enumerative technique generates the candidate            sis problem tractable, the “syntax-guided” version allows the
             expressions of increasing size relying on the input-output            user to impose structural (syntactic) constraints on the set of
             examples for pruning; the symbolic technique encodes parse            possible functions f. The structural constraints are imposed
             trees of increasing size using variables and constraints, and         by restricting f to the set L of functions deﬁned by a given
             it calls an SMT solver to ﬁnd a parse tree consistent with            context-free grammar GL. Each expression in L has the same
             all the examples encountered so far; and the stochastic search        type as that of the function f, and uses the symbols in the
             uniformly samples the set L of expressions as a starting point,       background theory T along with the variables corresponding
             and then executes (probabilistic) traversal of the graph where        to the formal parameters of f.
             two expressions are neighbors if one can be obtained from               Example 2: Suppose the background theory is LIA, and the
             the other by a single edit operation on the parse tree. We            type of the function f is int×int 7→ int. We can restrict the set
             report on a prototype implementation of these three algorithms,       of expressions f(x,y) to be linear expressions of the inputs
             and evaluate their performance on a number of benchmarks in           by restricting the body of the function to expressions in the
             Section IV.                                                           set L1 described by the grammar below:
                              II. PROBLEM FORMULATION                                       LinExp := x | y | Const | LinExp + LinExp
                At a high level, the functional synthesis problem consists         Alternatively, we can restrict f(x,y) to conditional expres-
             of ﬁnding a function f such that some logical formula ϕ               sions with no addition by restricting the body terms from the
             capturing the correctness of f is valid. In syntax-guided             set L2 described by:
             synthesis, the synthesis problem is constrained in three ways:         Term := x|y|Const|ITE(Cond,Term,Term)
             (1) the logical symbols and their interpretation are restricted
             to a background theory, (2) the speciﬁcation ϕ is limited              Cond := Term≤Term|Cond∧Cond|¬Cond|(Cond)
