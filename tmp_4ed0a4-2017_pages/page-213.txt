            200                   6.  GENERAL  SCHEME  FOR COMPLEXITIES
            between KM and К A  for n-bit strings can be about log log n (so here we have a 
            gap between the known lower and upper bounds).
                 None of the mentioned results guarantees that the difference between К(x) and 
            C(x) tends to infinity as x goes to infinity (here we consider a; as a natural number). 
            But this follows from Theorem 73  (p.  112).  Some other bounds relating different 
            versions of complexity are mentioned in [195].
                                     6.3.  Conditional complexities
                We have already considered several versions of conditional  complexity  (of a 
            string relative to the other one).  In Section 2.2 we have defined the conditional 
            complexity C(x \ y) as the minimal length of a string p that describes x when у is 
            given, i.e., a string p such that S(p, y) — x.  Here S is the conditional decompressor 
            that is optimal in the class of all partial computable binary functions.
                In  Section 4.7 we defined the conditional prefix complexity K(x\y).  In this 
            definition we required S(p, y) to be prefix stable with respect to p for every fixed, y: 
            this means that if S(p,y) = x for some p, then S(p',y) = x for all strings p' that 
            have prefix p.
                Finally,  in the proof of Theorem 93 we mentioned the conditional monotone 
            complexity  KM(x\y).  For its definition a description  mode  (decompressor)  is  a 
            computable family of computable continuous mappings Dy : E  —>  E  (indexed by 
            string y).  The computability of this family means that the set of triples  (y,u, v) 
            such that v ^4 Dy(u) is enumerable.
                The conditional decision complexity can be defined in a similar way.
                In these four definitions we consider conditions as terminated bit strings, and 
            the behavior of the decompressor is unrelated for different conditions:  if we know 
            that p is  a description of x relative to y,  this gives us no information about  the 
            values of decompressor for other values of y.
                In other words, a decompressor (say, for the conditional prefix complexity) can 
            be considered as a computable mapping
                                             P:Ex N -» Nj_;
            in the pair  (p, y)  G  E x N,  the string p  is  considered as  a description  (and  D  is 
            monotone with respect to p) and y is a condition, and no monotonicity is required.
                If we change this and consider conditions also as vertices of a binary tree re­
            quiring monotonicity over conditions, we get four other versions of conditional com­
            plexity.  These versions are not widely used ([40] is a rare exception).
                In this way we get eight versions of conditional complexities (for each of three 
            components, i.e., conditions, descriptions,  and objects,  we have two possibilities). 
            The most non-technical definition of these complexities goes as follows.  Let a,ß, 7 G 
            {=,x} (see Section 6.2).  An (a, ß) | 7-decompressor (description mode) is an enu­
            merable set S of triples (p,x,y), such that
                       {pi,Xx,yi) e S,    (Р2,Х2,У2) £ S,   piap2,   y\iy2^X\ßX2 
            The we define Ks(x\y) as the minimal length of a string p such that (p,x,y) G S.
                Theorem 129.  In all eight cases there exists an optimal decompressor S that 
            gives the smallest complexity K$  (up to 0 (1))  among all the decompressors ofthat 
            class.
