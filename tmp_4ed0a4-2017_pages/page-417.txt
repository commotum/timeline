             408                         13.  INFORMATION  AND  LOGIC
                 It may happen that w — z.  In this case we know z (if we get an advice bit that 
             says that this indeed the case).
                 If w ф z, then we can find both x and a solution to y —> z as follows.  First, 
             let  us  show that x — u.  Indeed,  if it were not the case, then there would exist a 
             function r that maps both x to y and и to v.  Both triples (x, y, z) and (и, v, w) are 
             compatible with p, therefore p(lT) would be equal to both w and z, contradicting 
             to the assumption w Ф z.
                 It  remains to show how to find z given у in the second case (w ф z).  This is 
             easy:  in general, the problem у —> z is easier than (x —> y) —> z, since every у can 
             be considered as a (constant) function that is a solution to x —» y.                □
                 Historical remark.  All the examples in this section are taken from [182] except 
             for Theorem 241, which was taken from [142].
                         13.4.  More examples and the proof of Theorem 238
                 Theorem 242.  The complexity of the problem ((x —» y)  —» y) —>  (x V y)  is 
             equal to min(C(x |y), C(y\x)) + O(logn) for strings x and у of length at most n.
                 In particular, if x, у are independent random strings of length n, the complexity 
             of this problem is close to n.
                 Proof.  First, it is easy to see that the complexity of ((x —> y) —> y) —> (x V y) 
             does not exceed C(y |x) + 0(1).  Indeed,  if p maps x to у and g is a solution .to 
             (x —> y) —> y, then y equals \p](q).
                 Now let  us  prove  that  the  complexity of ((x  —»  y)  —»  y)  —»  (x V y)  is  also 
             bounded by C(x\y) + O(logn).  It is enough to show that given a program p that 
             maps y to x, a solution q to  (x —> y) —> y and the number n, we can find x or y. 
             Consider again the set S of all strings of length at most n.  Call a pair (u, v) G S x S 
             compatible with q if q(lr) — v for all r: S —> S such that t(u) = v.  Obviously, the 
             pair (x, y) is compatible with q.
                 We have seen that any two pairs compatible with q have either the same first 
             components or the same second components.  This implies that either all compatible 
             pairs have first component x or all compatible pairs have second component y (or 
             both).  Indeed,  assume that there is a pair whose first  component x'  is different 
             from x.  Then its second component  is y,  so the pair is  (x',y).  For the sake of 
             contradiction,  assume that there is a pair whose second component y' is different 
             from y, and thus that pair is  (x,y').  Now the pairs  (x,y')  and (x',y) violate the 
             requirement mentioned above.
                 So let us assume that n, p,  and q are given.  We search for pairs compatible 
             with q until the first such pair (и, v)  is found.  Then we do two things in parallel: 
             (1)  we  look for other pairs compatible with q,  and  (2)  we run p on v  and verify 
             the equality p(v) = u.  One of these two things will happen:  if p(v) is undefined or 
            p(v) Ф u, then (и, v) ф (x, y) so another pair will appear.  If we find another pair 
             (u',v')  compatible with q,  then we know either x  (if v ф v', then и — x)  or y  (if 
             и ф и', then v = у).  And if we know that p(v) = u, we can be sure that и — x (if 
             и Ф x, then v = y, hence и = p(v) = p(y) — x).
                 It  remains to show that the complexity of ((x —> y) —> y) —> (x V y) cannot be 
             much less than min{C(y | x), C(x \ y)}.  We do this in the following way.  We present 
             a way to convert any program p that solves ((x —> y) —> y) —>  (x V y) into a pair 
             of programs (гх,гъ) such that either rq  maps x to у or Г2 maps у to x.  However,
