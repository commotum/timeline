          98          4.  A  PRIORI  PROBABILITY  AND  PREFIX  COMPLEXITY
          decompressor D'.  Informally,  the  algorithm  D'  reads  the  input  until  it  finds  a 
          description of x.  Then it reads the rest of the input until it finds a description of y. 
          Formally, we define D' as
                                  D/(pq) = [D(p),D(q)}.
          Here pq stands for the concatenation of strings p and q.  In other words, we try to 
          split the input into two parts p and q in such a way that both D(p) and D{q) are 
          defined.
             We need to verify that D' is well defined.  Indeed, assume that x is represented 
          as pq in two different ways, x — pq = p'q',  and all the values D(p), D(q), D(p'), 
          D(q') are defined.  Then p and p' are compatible (being prefixes of the same string x) 
          and thus coincide (as D is prefix free), hence q — q'.
             In a similar way we can prove that the function D1 is prefix free.  Let pq be a 
          prefix of p'q',  and let both belong to the domain of D.  The strings p and p'  are 
          compatible and both D(p)  and D(p')  are defined, therefore p = p'.  This implies 
          that g is a prefix of q'.  As both D(q) and D(q') are defined, we have q = q'.
             The function D1 is computable: to find D'(x), we compute in parallel D(p) and 
          D(q) for each possible way to split x into p and q.  We have shown that there is at 
          most one representation of x as pq such that D{jp) and D(q) are defined.  If we find 
          such p and q, we output the string [D(p), D(q)].
             It remains to note that
                              KDi([x,y]) ^ KD(x) + KD{y).
          Indeed, let p and q be shortest descriptions of x and y with respect to D.  The string 
          pq is a description of [x,y] with respect to D1 and has length Kd(x) + Ko(y)- 
             In other words, D1 reads the input as D does until p and D(p) are found, then 
          reads the rest of the input again to find q and D(q).
              103 Prove Theorem 60 using the definition of prefix-free decompressors in
          terms of machines with blocking read operation (see Theorem 50 on p. 86).
              104  A set of binary strings is called prefix free if any two elements of it are
          incompatible.  Show that if sets A and В both are prefix free, then so is the set
                                AB = {ab \ a £ A,b £ B}.
             Which proof of Theorem  60  (using  a priori  probability  or  using  prefix-free 
          decompressors)  is easier and more natural?  It is  a matter of taste—the authors 
          believe that the first one is more natural.  The next theorem provides an opposite 
          example:  encoding arguments here seem to be simpler than the arguments using 
          the a priori probability.
             Theorem 61.
                               K(x,K(x)) = K(x) + 0( 1).
             (Problem 23 asks us to prove the same equality for plain complexity.)
             Proof.  The inequality K{x) ^ K(x, K(x)) + 0(1) is straightforward, as the 
          string x can by computed given the encoding [x, K{x)] of the pair.
             To prove the converse inequality, let D be an optimal prefix-free decompressor 
          used in the definition of prefix complexity K'.  Define a new decompressor D1 as
                                  O’ip) = [D(p),i(p)J.
