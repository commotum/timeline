                                         4.3.  PREFIX  MACHINES                          83
            such that ïji is a prefix of y.  Once we encounter such a pair, we print the result 2* 
            and halt.
                For every program p the function у    \p\(y)  is prefix stable.  Indeed,  assume 
            that  \p](y)  = 2.  By construction there is a non-deleted pair  (yi,z)  such that yi  is 
            a prefix of y.  Assume furthermore that у is a prefix of y'.  We need to show that 
            \p](y') — z•  The string yi is a prefix of y' as well, therefore \p\{y') — z or \p](y') = Zj 
            where {yj,Zj) is a non-deleted pair such that j < i and yj is a prefix of y'.  In the 
            latter case yj  is compatible with yi and, since the pair  (yi,z)  does not contradict 
            the pair (yj, Zj), we have Zj — z.
                If p is prefix stable,  then no pair is deleted in the run of its transformed ver­
            sion [p].  Therefore \p\(y) is defined as p’s output on у or a prefix of y.  As we assume 
            that p is prefix stable, the result is the same.
                Now we are able to finish the proof.  Let
                                            D(py)  =   lp](y)-
            We have to verify that D is prefix stable and optimal (in the class of all prefix-stable 
            decompressors).
                To prove the first statement, assume that p\yx  is a prefix of ргР2-  We need to 
            show that D(pxyx) and Б(р2У2)  coincide.  As both the strings pi, p2  are prefixes 
            of the string Р2У2 ,  they are compatible.  Thus pi  = P2  (as the encoding p (->■ p is 
            self-delimiting)  and  y\  is  a prefix of y2-  Since the program  [pi]  (=[рг])  is prefix 
            stable, we conclude that D(pxyx) = \px\(yx) = [Р1КЫ = \p2Ky2) = D(p2y2).
                So we have shown that D is prefix stable.  To prove optimality,  assume that 
            some prefix-stable decompressor D' is given and p is its program.  Then we have 
            D(py) — \p](y) — p(y)-  Therefore the complexity of all strings with respect to D' 
            is at most l(p) greater than the complexity with respect to D.               □
                Let us fix some optimal prefix-stable decompressor and omit the subscript D 
            in  K d (x),  speaking about  the prefix complexity K(x)  of x.  As well as the plain 
            complexity, the prefix complexity is defined up to an 0 (1) additive term.
                There is another way to define prefix complexity.  Instead of prefix-stable func­
            tions, we consider prefix-free functions.  A function is called prefix free if every two 
            different strings in its domain are incompatible.  If a prefix free function is defined 
            on a string, it is undefined on all its proper prefixes and extensions.
                This  time  we restrict  the  class  of decompressors  to  prefix-free ones,  that  is, 
            computable prefix-free functions.  We have the following theorem that is similar to 
            Theorem 48:
                Theorem 49.  The class of all prefix-free decompressors contains an optimal 
            element.
                Proof.  The proof is very similar to the proof of Theorem 48.  This time we 
            construct, for every program p, a prefix-free program {p} that works as follows:
                (1) Just as before, run the program p on all inputs to obtain a sequence (yi, zf) 
            of all pairs such that 2 = p(y).
                (2)  Delete all pairs  (yi, zf) such that yi is compatible with yj for some j < i.
                (3)  Let у denote the input to the program {p}.  We find the first non-deleted 
            pair (yi, Zi) with yi = у and output 2* = {p}(y).
