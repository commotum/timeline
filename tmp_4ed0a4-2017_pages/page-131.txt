                              5.1.  PROBABILISTIC  MACHINES  AND SEMIMEASURES  ON THE TREE                                      117
                        120  Show that for a semicomputable tree semimeasure the sum                                    a(x) can 
                 be infinite.
                       (Hint:  Consider the algorithm that copies random bits to output.)
                       The converse of Theorem 75 is also true:
                       Theorem 76.  Every lower semicomputable continuous semimeasure is gener­
                 ated by some probabilistic algorithm.
                       Proof.  The idea of the proof can be easily explained in terms of space alloca­
                 tion,  as was done for Theorem 46 (p. 78).  The difference is that now the requests 
                 are hierarchical.  Two big organizations (called 0 and 1) need space in Q (which we 
                 identify with [0,1]); the subsets allocated for 0 and 1 should be disjoint, and their 
                 space requests increase over time (but never become greater than 1 in total).
                       Each of the organizations has two divisions  (called 00,01  inside 0 and  10,11 
                 inside 1) that request some space inside the regions allocated to their organization as 
                 a whole.  Their requests also increase over time, but never become greater (in total) 
                 than the organization’s request (at the same time).  Then we consider subdivisions 
                 (say,  01  has  subdivision  010  and  Oil)  that  have  increasing  requests  that  do  not 
                 exceed (together) the request of their parent division, and so on.
                      For  each  subdivision  x  (at  any  level)  we  have  increasing  requests.  All  the 
                 allocations are final, i.e., the space allocated to some x remains allocated to x.
                      This scheme is used in the proof as follows:  Having a lower semicomputable 
                 semimeasure a, we construct a family of requests such that the limit of the requests 
                 for subdivision x is equal to a(x).  Then we choose a way to satisfy all the requests, 
                 and then we say that if a sequence of random bits gets into the region allocated to 
                 x, then the output of randomized algorithms starts with x.
                      It is more or less obvious that the requests can indeed be fulfilled.  The reader 
                 may skip the rest  of the proof,  where we provide a more formal argument  (and 
                 explain the intuitive meaning of its steps).
                      Lemma 1.  Let a  be  a lower semicomputable semimeasure on the  binary tree. 
                 Then there exists a total computable monotone  (in the second argument) function 
                 (x, i)     a(x, i)  whose values are non-negative rational numbers with denominators 
                 being powers of two, such that
                       (1)  limia(x,i) — a(x) for every string x;
                      (2)  for each i  the function x i->  a(x,i)  is  a continuous semimeasure that has 
                 only finitely many non-zero values.
                      In other words, the memory manager can impose the following additional re­
                 strictions:
                          •  all the requests are dyadic-rational numbers;
                          •  at each step only finitely many subdivisions have non-zero requests;
                          •  at each step requests are coherent  (the request of any subdivision should 
                             be greater than or equal to the sum of requests of its children).
                      PROOF.  Our goal is to change the function a from the definition of lower semi­
                computable semimeasure (but not change the semimeasure itself) so that it satisfies 
                the requirements of Lemma 1.  First, we make all values dyadic rationale.  To achieve 
                this,  we replace a(x,i)  by the maximal rational number with denominator 2l not 
                exceeding a(x,i)  (negative numbers are replaced by zeros).
