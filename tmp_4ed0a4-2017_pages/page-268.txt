                                              8.6.  A  PROOF  OF  AN  INEQUALITY                                255
                                                          e  f   9   h
                                                                     U
                                                                 a
                                                          Figure 26
               i.e.,  2m/8  =  2m~3  according to the assumption.  When going down,  only one bit 
               that indicated the direction is sufficient.  (In other words, when making a recursive 
               call, we perform a push operation for the stack of calls, and we should specify the 
               top of the stack; for pop operation no additional information is needed.)
                    So for each vertex  (except  the root)  we use log t + 2  bits  (we  need log t + 1 
               bits when we come to this vertex from below, and then one more bit when going 
               back to its father).  In total (for all the vertices) we need N + n + k(\ogt + 2) bits 
               for description.  If the random bits used in the algorithm are incompressible, then 
               N + n + к (log t + 2) ^ n + km, and we get an upper bound for k.  Namely, we get 
               the bound к ^ N (recall that logt + 2 = m — 1), so we make at most N calls of the 
               procedure Fix, and the algorithm is polynomial (in N + ri).
                    Some final clarifications are needed still.
                    1.  If we literally use Kolmogorov complexity, then some constant appears, and 
               we should keep track of all these details.  As usual, when the idea is clear, we can 
               switch to the probabilistic language:  If к — N + c, then the difference between the 
               number of random bits used and the number of bits in the description is c.  This 
               means that the number of random bit strings that cause N + c or more calls of Fix 
               is  2C  times smaller than the total number of possible strings, so the probability is 
               bounded by 2~c.
                    2.  When we describe several objects by a sequence of bits,  we should check 
               that no separators are needed to perform the decoding.  Here it is indeed the case: 
               The number of variables, clauses, and the clause size (as well as the bound for the 
               number of neighbors)  are known;  after a bit that specifies the direction (whether 
               we go up or down) is read, the decoder knows how many bits it should read next.
                    3.  The last  problem:  It  may  happen that  we stopped  the execution at  the
               moment when one of the trees is only partially processed, so we should be able to 
               describe the unfinished tree walk.  But our way of description works in this case as 
               well; we should only note that at every moment the number of steps down does not 
               exceed the number of steps up (the number of Fix-calls).                                          □
                                             8.6.  A proof of an inequality
                    As we have said (see p.  12), the inequalities for Kolmogorov complexity have 
               quite unexpected consequences.  In this section we explain one of them, a version 
               of the Loomis-Whitney inequality (this topic will be continued in Chapter 10).
