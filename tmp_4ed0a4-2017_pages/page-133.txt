                     5.1.  PROBABILISTIC  MACHINES  AND  SEMIMEASURES  ON  THE TREE       119
                   •  for each x and i the sets U(xO,i) and U(xl,i) are disjoint subsets of the 
                     set U(x,i);
                   •  U(x,i) C U(x,i + 1) for each x and i.
                Now the probabilistic algorithm that generates the semimeasure a can be con­
            structed  as  follows:  we  construct  the sets  U(x,i)  for  all  x  and  i  and  in  parallel 
            generate random bits obtaining a sequence со.  If at  some step we discover that 
            со E U(x, i) for some x and г, we output those bits of the string x that have not yet 
            been printed.
                Note that if a;  €  U(x.i),  then со  E  U(y,i)  for every prefix y  of x.  Note also 
            that со  cannot  be an element of both U(x,i)  and  U(x',i)  if strings x  and x'  are 
            incompatible  (neither of them is the prefix of the other one).  Therefore the bits 
            sent to the output never need to be “recalled”.
                An output of this algorithm starts with some string x if and only if the sequence 
            со of random bits belongs to the union of the increasing sequence of sets U(x, i) (for 
            г  =  0,1, 2,...).  The probability of this event is the limit  of measures of the sets 
            U(x,i),  and  this  limit  is  by  construction  equal to  a(x),  so  we have achieved  our 
            goal.                                                                         □
                Theorems  75  and  76  show  that  lower  semicomputable  semimeasures  can  be 
            equivalently  defined  as  probability  distributions  generated  by  randomized  algo­
            rithms (of the described class).
                There is an important special case when a randomized algorithm almost surely 
            generates an infinite sequence  (i.e.,  the probability of getting a finite sequence is 
            zero).  Such algorithms generate computable measures,  as the following theorem 
            shows.
                Theorem 77.  (a) Let у be a computable measure onfl.  Then function p defined 
            on the  Cantor space as p(x) —          a lower semicomputable semimeasure and
            p(x) — p(x0) +p(x 1) for all x.
                (b)  If  a  lower  semicomputable  semimeasure p  satisfies  the  equality p{x)  = 
            p{x0) + p(x 1) for all x,  then it determines some computable measure on £7.
                Proof,  (a) If a real number a is computable and an is a rational approximation 
            to a with accuracy 1/n, then bn — an — 1/n is a lower bound for a that is at most 2/n 
            apart from a.  The sequence bn constructed in this way can violate the monotonicity 
            requirement but we may replace it by the sequence cn = max(&o, 6i,  ,bn) and get 
            a non-decreasing sequence of rational numbers converging to a.  Therefore, every 
            computable real number is lower semicomputable.  Doing this in parallel for all x, 
            we obtain computable rational lower bounds for p(x) tending to p(x), and we prove 
            that every computable measure is a lower semicomputable semimeasure.  Since 
                                                                       p(x) = p{x0) +p{x 1).
            is the union of two disjoint subsets  and      we also have 
                (b)  Assume that p is a lower semicomputable semimeasure that satisfies our 
            condition, i.e., p(x) — p(x0) +p(x 1) for all x.  We show inductively how p(x) can be 
            computed with arbitrary precision for every x.  For empty x we have p(A) = 1 by 
            definition.  Imagine that we already know how to find p(x) with arbitrary precision 
            for some string x.  How can we do the same for p(x0) and p(x 1)?  We have to wait 
            until the sum of (increasing) lower bounds for p(x0) and p(x 1) becomes close enough 
            to the (decreasing) upper bound for p(x).  In other words, an upper bound for p(x 1) 
            can be obtained if we take an upper bound for p(x)  (constructed recursively) and 
            subtract a lower bound for p{x0), and vice versa.                             □
