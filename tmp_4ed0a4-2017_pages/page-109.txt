        94        4.  A  PRIORI  PROBABILITY  AND  PREFIX  COMPLEXITY
          The simplest strategy is to allocate a new interval (in the free memory) each 
        time the request increases.  This does not work, however:  if two clients’ requests in­
        crease in alternating order and in small steps, the overhead cannot be compensated 
        by any fixed e, and we will run out of space.
          The remedy is well known:  one should look forward and increase the allocated 
        interval significantly even if the current increase in the request is small.  For exam­
        ple,  one may allow only powers of 2 as the interval lengths  (then the sum of the 
        lengths is at most twice more than the maximal summand).
          It  is  not  hard  to  present  a detailed proof based on this strategy,  but we will 
        not do that.  Instead, we present a slightly different proof that uses the following 
        statement often called Kraft-Chaitin lemma.  This lemma can be considered as a 
        computable version of the Kraft lemma from information theory (see p. 214).
          Lemma.  Let /о, h, h, ■ ■ ■ be a computable sequence of non-negative integers such
        that
                              г
        Then  there  exists  a  computable  sequence  of pairwise  incompatible  binary  strings 
        xo, X\,X2 , ■ ■ ■  such that l(xi) — l{.
          Note that the inequality of the lemma is a necessary condition for the existence 
        of such a sequence:  the intervals IXi  do not overlap, and their lengths are equal to 
        2~li.  The lemma states that this necessary condition is also sufficient.
          Proof.  Again we have an infinite sequence of clients; the ith client demands 
        we allocate a properly aligned interval of length 2~li for her.  The intervals reserved 
        for different clients should not overlap.  We need to design a computable strategy 
        to fulfill all the clients’ requests.
          There are several ways to describe such a strategy.  Here is probably the simplest 
        one:  let us maintain the representation of the free space (part of [0,1]  that is not 
        allocated) as the union of properly aligned intervals of different lengths.
          Initially this list contains one interval [0,1].  We serve the requests lo, h,h, ■ ■ ■ 
        sequentially.
          Assume that the current request is li, so the required length is w = 2~li.  First 
        note that  one  of the  free  intervals  has  length  at  least  w.  Indeed,  if all  the  free 
        intervals had smaller lengths, their sum (the total amount of free space) would be 
        less than w since they have different lengths and the sum of powers of 2 less that 
        w = 2~l is less than w.
          If there is a free interval in the list that has size exactly w, our task is simple.  We. 
        just allocate this interval and delete it from the free list (maintaining the invariant 
        relation).
          Assume that this is not the case.  Then we have some intervals in the list that 
        are bigger than requested.  Using the best-fit strategy, we take the smallest among 
        these intervals.  Let w'  > w be its length.  Then we split a free interval of size w1 
        into properly aligned intervals of size w, w, 2w, 4w, 8w,..., w'/2; note that
                    w + w + 2w + 4w + 8w + • ■ • + w'/2 = w'.
        The first  interval  (of size w)  is allocated,  and all the other intervals are added to 
        the free list.  We have to check out the invariant relation:  all new intervals in the 
        list  have different sizes starting from w up to w'f 2;  old free intervals cannot have 
        this size since w' was the best fit in the list.
