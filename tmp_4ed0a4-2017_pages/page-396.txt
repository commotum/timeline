            386           12.  M ULTISOURCE  ALGORITHMIC  INFORMATION  THEORY
            the numbers (positions) of bits sent in these envelopes, in non-decreasing order, and 
            write on the edge the subsequence of bits in these positions.
                Let  us show that bounds for conditional complexities are satisfied.  Consider 
            some node and the output and input strings for this node.  The output strings are 
            made by combining the bits obtained from the input string.  The scheme (which 
            bits go where) does not depend on A and can be computed if n is known, so this 
            scheme has complexity O(logn), and it is enough to know it to transform incoming 
            strings into outgoing strings.
                This finishes the proof for the case of one output node.
                To prove the same result in the general case, we use random linear codes.  In the 
            previous argument we just moved bits from incoming strings to outgoing strings. 
            Now we use a more general tool—we apply some linear operator in each vertex. 
            Imagine for now that bits are elements of the two-element field F2  (it consists of 0 
            and  1,  and 1 + 1  = 0).  Then /-bit strings are vectors in the /-dimensional vector 
            space over this field.
                Consider a node that has incoming edges of capacities i\,..., ip, and outgoing 
            edges of capacities           (We replace  all  infinite  capacities  by  n:  since  we
            send only  n  bits,  we  never  will  need  to  send  more  than  n  bits  along  an  edge.) 
            Then the linear transformation in the node can be specified by a matrix of size 
            (ii + • • • + jq)  X  (?’i + • • • + ip),  and we multiply the incoming bits vector by this 
            matrix to get the outgoing bits vector.  Note that we send exactly к bits along an 
            edge of capacity к (even if this edge looks useless).
                (It  is  easy to see that our solution for the three outputs example has exactly 
            this form.)
                Assume that for some vertex such a transformation matrix is chosen.  Then we 
            get for each output some linear transformation (from input n-dimensional space to 
            output n-dimensional space)  over the field F2.  We want to make all these linear 
            operators  invertible.  This  would  guarantee  that  the  output  string  contains  full 
            information (up to a fixed linear transformation)  about the input string.  So if we 
            can find some matrices in the nodes that make all the input-output transformations 
            invertible, we are done.
                There is  one subtle  point  here:  The  mere  existence  of good  transformation 
            matrices for all nodes is not enough.  We need these matrices to be simple.  However, 
            a standard trick helps.  If good matrices exist, we can use the first example in some 
            ordering, and it has complexity O(logn); recall that the graph is fixed.
                A more serious problem is that in some cases it is not possible to make these 
            matrices invertible for each output.
                328       Consider the information request from Figure 46.  Assume that the input 
            string  consists  of two  bits  and  the  capacities  of all  edges  are  equal  to  1.  Show 
            that  no  linear  transformations  in  the  nodes  make  all six  input-output  mappings 
            invertible.
                (Hint:  There are only three non-linear functionals on two-dimensional space, 
            so two of the intermediate vertices will carry the same information.)
                Note that  for  each  output  it  is  possible  to  find  transformations  in  the  ver­
            tices that make the transformation for this output invertible; indeed, we have seen 
            that we do not even need arbitrary linear transformations—repackaging the bits 
            (from envelopes to envelopes) is enough.  The problem is that we cannot make the 
            transformation for all output nodes invertible simultaneously.
