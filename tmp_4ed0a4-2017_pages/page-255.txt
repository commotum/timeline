             242                            8.  SOME  APPLICATIONS
                 (Hint:  Consider two cases:  If all binary strings appear as substrings, the claim 
             is  evident.  If ш  does  not  contain  some  string  и  of length  к,  we  can  split  long 
             substrings into blocks of length к and use efficient coding that takes into account 
             that block и is never used and does not need a code; this gives complexity per letter 
             at most (log(2fc — 1 ))/k.)
                 The proof of Theorem 157 consists of two steps.  First we prove its special case, 
             Theorem 158.  Then it turns out (surprisingly) that the general case follows from 
             this special one.
                 PROOF.  To  prove Theorem  158,  let  us consider an intermediate ß such that 
             a < ß <  1.  Using Theorem 71  (p.  Ill), we find a number N with the following 
             property:  to each string x we can append N bits (on the right) in such a way that 
             the prefix complexity of the string increases at least by ßN.
                 Let us use this property iteratively starting from the empty string.  We get an 
             infinite sequence of iV-bit  blocks;  the prefix complexity increases at  least  by ßN 
             when the next block is appended.  This implies that the complexity of every group 
             of consecutive к blocks is at least ßkN — 0(1).  Indeed, by appending this group, we 
             increase complexity by ßkN at least, but the inequality K(xy) ^ K(x)+K(y)+0( 1) 
             shows that K(y) ^ K(xy) -  K(x) -  0(1).
                 This implies that for every substring и (not necessarily block aligned) the com­
             plexity of и is at least ßl(u) — 0(1) since the change in complexity and length due 
             to boundary effects (by cutting the incomplete block on the border) is 0(1).  It re­
             mains to note that we have some reserve due to the difference between a and /3, and 
             this reserve is enough to compensate both the boundary effects and the difference 
             between plain and prefix complexities (for sufficiently long substrings).           □
                  245  Give  a similar  argument  that  uses  plain  complexity  instead  of prefix
             complexity.
                 (Hint:  Use Problem 46, p. 42.'
                  246  Prove the statement of Problem 47 (p. 42) with prefix complexity instead
             of plain complexity.
                 PROOF.  Now  let us prove Theorem 157;  the simplest  approach is to use the 
             relativized version of complexity.  Let us consider the set F of forbidden strings as 
             an oracle;  this means that we consider algorithms that can ask (for free) whether 
             a given string is forbidden or not.  As usual, this relativization goes smoothly both 
             in  the  statement  of Theorem  158  and  its proof,  and  this  theorem  is true  for  F- 
             relativized complexity.
                 Now all forbidden strings of length n have F-complexity at most an + 0(\ogn), 
             since each forbidden string can be determined by n and by its ordinal number in the 
             list of all forbidden strings of length n.  In fact the stronger bound an + 0(1) is valid 
             since we can use the list of all forbidden strings in the order of increasing length, 
             but this does not matter much since a small change in a covers this difference.  So 
             it  remains to apply Theorem 158 and to get a sequence which does not have long 
            substrings with complexity less than ß (per letter), for some ß > a.                □
                 One can also make the following (rather unexpected) observation [160]:  The­
            orem  157 can be derived from Theorem  158 directly,  without  any relativization, 
             using the following statement:
