             128                         5.  MONOTONE COMPLEXITY
                 This definition is self-contained and does not require any interpretation in terms 
             of machines.  All we say below about the interpretation of this notion in terms of 
             machines of special type is not necessary (and is not used in the sequel).  However, 
             to give a motivation for this definition, it is instructive to understand which type of 
             machine (program) corresponds to computable continuous mappings of type E —> E.
                 5.4.2.  Monotone machines with non-blocking read operation.  Let us
             consider programs that use a non-blocking read operation (we can get the next bit 
             from the input queue and also check whether this queue is non-empty).  We have 
             discussed this type of input  paradigm in Section 4.4.2,  p.  87.  However,  now we 
             assume that the output is created bit  by bit,  using the procedure  OutputBit(fe) 
            with a Boolean argument.
                 The output sequence generated by a program of this type can be finite or infi­
            nite.  In general, it depends not only on the input sequence but also on the timing 
             (the moments when keys “0”  and “1” were pressed).  We say that a machine (pro­
            gram) is robust if the timing does not matter, i.e., if the output sequence depends 
            only on the input sequence but not on the timing.  (Of course, the output timing 
            may still depend on the input timing.)  A robust program determines (computes) 
            some mapping of the set E into itself.
                 Theorem 82.  Robust programs compute computable mappings  (in the abstract 
             sense,  as  described  above);  on  the  other  hand,  every  computable  mapping  is  com­
            puted by some robust program.
                 Proof.  Assume that M is a robust program.  Let x and x' be two (finite or 
            infinite) sequences such that x =<! x'.  Let us show that M(x)    M(x') where M(z) 
            stands for the output of program M on the input 2 (since M is robust, the output 
            depends only on 2,  not  on the timing).  If x  is  infinite,  this  is  trivial  (x = x'). 
            Assume that x is finite.  There are two possibilities:  M(x) is either finite or infinite.
                 If M(x)  is  finite,  let  us  submit  input  x  and wait  until  M(x)  appears  at  the 
            output.  This should happen at some point;  after that  we submit the remaining 
            bits  of x'  (that  are not  in x)  to  the input.  Then we get  output  M(x')  which by 
            construction is the extension of M(x).
                 If M(x) is infinite, then every bit of M(x) should appear at some time after we 
            submit x to the input.  Since the remaining bits of x' can be sent after this moment, 
            this bit should appear also in M(x').  Therefore, M(x) = M(x') in this case.
                 It  is  also  clear that  for an infinite sequence из the value M(u>)  is the union of 
            M(x) for finite x =<! u)\  indeed,  at each moment only a finite number of input bits 
            have been read.
                 The set of all pairs of strings x, у such that у =<! M(x) is enumerable since we 
            can enumerate it by simulating the behavior of M on all inputs.  So each robust 
            machine computes a computable mapping.
                 On the other hand, let / be an arbitrary computable mapping.  We show how 
            to construct  a robust machine M that computes it.  The machine M enumerates 
            the lower graph Г/ of the mapping /.  At the same time M reads input bits and 
            stores them.  If it  turns out that Г/  includes a pair  (x, y)  such that x is a prefix 
            of the input sequence, we output the remaining bits of у (requirements (2) and (3) 
            guarantee that  all the strings у found in this way are compatible,  so there is no 
            need to recall the bits already sent to the output).                               □
