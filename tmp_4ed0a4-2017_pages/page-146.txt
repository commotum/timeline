             132                         5.  M ONOTONE  COMPLEXITY
                 (Hint:  Consider  the  optimal  prefix-free  decompressor  Dp  and  the  optimal 
             monotone  decompressor  Dm.  Now  let  D'(uv)  =  Dp(u)Dm(v)  (when  Dp  stops 
             reading the input, the remaining part of the input is read by Dm).)
                  135       Show that in the preceding problem one can replace KM(y) by the condi­
             tional monotone complexity KM(y\x) defined in a natural way (we do not require 
             monotonicity with respect to condition x, see Chapter 6 for details).
                  136       Prove that statement (g) remains true if we replace KM by KA  (in the 
             both sides of the inequality).
                 (Hint:  The mapping /  can be applied to the output of a probabilistic machine; 
             the new probabilistic machine is not better than the optimal one.)
                 We can give an equivalent definition of monotone complexity that does not use 
            computable mappings of type E —> E; in this way we get a simpler (but somewhat 
            less natural, in our opinion) definition.
                 Let  £  be  the  set  of all  binary  strings.  Consider  the  binary  relation  “to  be 
            compatible”  on this set:  x is compatible with y    x ^ у ох y ^ x (an equivalent 
            property requires that x and y are prefixes of the same string).  An enumerable set 
             (binary relation) D C £ x £ is called consistent if it has the following property:
             (x\i Ui)i{x2, У2 )  and (xi  is compatible with X2)  =>  (y\  is compatible with г/2)
            for all xi, x2 , Vi, У2 -  Then the monotone complexity of a string у with respect to 
            D is defined as the minimal length of a string x such that  (x, y)  G D.  There is an 
            optimal consistent enumerable binary relation on £.
                1137 I Prove that this definition leads to a notion of monotone complexity that 
            differs from the previous one by at most 0 (1).
                 (Hint:  The lower graph of any computable mapping E —» E is a consistent bi­
            nary relation.  On the other hand, if О is a consistent binary relation, the gap filling 
            described in the proof of Theorem 83 makes it a lower graph of some computable 
            mapping.)
                 It is instructive to compare this definition with the definition of plain complexity 
             (where we use graphs of computable functions, i.e., uniform enumerable sets instead 
            of consistent  relations  D).  In  the  definition  of monotone  complexity  we  do  not 
            require D to be a graph of some function:  several pairs (x, y) with the same x and 
            different у are allowed;  we require only that all y’s in these pairs are compatible. 
            This makes KM smaller.  For example,  all prefixes of some computable sequence 
            (say,  0000 ••• )  have bounded complexity  (note that C(0n)  = C(n)  is about logn 
            for most n).
                 On the other hand we apply additional restrictions:  if a string x is a description 
            of some string y, then the strings that are compatible with x can be descriptions 
            only of strings  that  are compatible with y.  This makes complexity larger.  This 
            is especially clear when we consider complexities of the elements of a computable 
            sequence of pairwise incompatible strings:  in this case monotone complexity coin­
            cides with prefix complexity,  and the difference can be about  logn for strings of 
            length n.
                Summing up  (and recalling that  both the  a priori complexity and  the plain 
            complexity  differ  from  the  prefix  complexity  at  most  by  О (logn)  for  strings  of 
            length n), we come to the following conclusion:
