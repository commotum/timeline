                                        5.9.   RANDOMNESS  WITH RESPECT TO DIFFERENT MEASURES                                                            189
                           However, some statement that would be a corollary of this “criterion” if it were 
                    true (which is not the case),6 is still true [86,  58]):
                           Theorem 126.  Let a be an arbitrary sequence of zeros and ones.  Then there 
                     exist  a sequence иj  that is ML-random with respect to  the uniform measure and a 
                     computable mapping f: E —> E such that f(uj) = a.
                           Using the terminology of recursion theory, this statement guarantees that every 
                    sequence of zeros and ones is Turing-reducible to some ML-random sequence with 
                    respect to the uniform measure.  (We have already mentioned this result on p. 180.)
                           Proof.  We prove a bit stronger statement and construct a computable con­
                    tinuous mapping / (the same for all a) such that the image f(R)  (where R is the 
                    set of all ML-random sequences with respect to the uniform measure) equals fl.
                           Moreover, for any effectively open set U (i.e., the union of an enumerable family 
                    of intervals) of sufficiently small measure we will construct a computable mapping / 
                    such that f(Q\U) covers the entire fb  Applying this construction to an effectively 
                    open set of small measure that covers the complement of R, we get the result.
                           Here is the idea of the construction.  First,  we split the sequences into blocks 
                    of length ко, ki,..., and in this way we represent the Cantor space as the space of 
                    paths in a tree with branching factors 2k°, 2kl,... (instead of the binary tree).  The 
                    numbers ki grow fast enough as i increases  (see below).  We choose some binary 
                    subtree in this tree and declare that / maps it onto a full binary tree in a natural 
                    way.  In other words, we select two strings so and si  of length ко that are mapped 
                    by /  to 0 and 1, respectively, then select extensions soo, soi  (°f so) and sio, sn  (of 
                    si), mapping them to 00, 01, 10, 11, respectively, etc.
                           At the same time, we enumerate the intervals of the effectively open set U.  If 
                    none of them covers any path in the chosen binary subtree,  we have nothing to 
                    worry about:  f(Q\U) will cover Q.  If an interval covers some vertex in the chosen 
                    binary subtree,  we replace this vertex by another one  (that  is  not  yet  covered), 
                    and extend / to this vertex (and the entire subtree rooted at this new vertex).  To 
                    prevent this, the adversary needs to make unusable all 2k° sons of the root except 
                    one;  to  make  each of them unusable one needs to  make unusable  all of its sons 
                    except one, etc.  We conclude that the set U must be of size at least
                                                       / 2*0-14  f 2kl — l\  /2*2-l\
                    (*'                               I     2fc°      )    V     2fci      J     V    2*2       )'•••’
                    and we can choose  ко, ki,...  growing fast  enough  to  make  this  product  strictly 
                    positive (or even close to 1).
                           Now let us explain the details.  For a given (computable) sequence ko,k\,k2 ,..., 
                    we consider strings of length ко (as 2k° sons of the root), then strings of length ко + 
                    ki, ко + k\ + k2 , etc., as vertices of the tree T (with branching factors 2k°, 2kl,...). 
                    We call them T-vertices (to distinguish from the vertices of the binary tree).
                           First, we choose (in some computable way) a binary subtree in T and map its 
                    vertices to the vertices of the binary tree in a natural way.  Then we enumerate 
                    the intervals that form the effectively open set  U.  Without loss of generality we 
                    may assume that all these intervals are formed by T-vertices.  When a new interval 
                    appears, we do the following:
                           6To  derive  this  statement  from  the  “criterion”,  one  can  take  a  mapping  /   whose  output 
                    distribution is the continuous a priori probability.
