             410                           13.  INFORMATION  AND  LOGIC
                  Consider  arbitrary  strings              where  к  ^  2,  and  two  arbitrary  non­
             empty disjoint sets I.J c {1,..., к}.  Then consider the problem
                                              ((X -t Y)      Y)    Z,
             where X is the conjunction of singletons {uj} for i e I (i.e., the /с-tuple), Y is the 
             disjunction of all Uj for i € J, and Z is the disjunction of all singletons их,..., Uk- 
             For example, for к = 2, I = {1}, J = {2}, we get the problem ((щ                  щ) —>
             (ui V щ) considered above.  In another example we use different letters for the sake 
             of readability:
                            {{xi A x2 -»• yi V y2) -»■ У\ V y2) -»• xx V x2 V yi V y2 V z.
                  Theorem 243.  The complexity of the problem ((X —> Y) —> Y) —> Z is lower 
             bounded  (with 0(1)-precision)  by the minimal conditional complexity of щ  given 
             all other strings u i,...,
                  Proof.  This theorem generalizes Theorem 242,  and its proof is also similar. 
             We construct a tuple of к algorithms that has the following property.  For every 
             program p that solves  ((X  —ï Y ) —> Y)—ïZ, there exists rn such that the mth 
             algorithm, given p, reconstructs um from all other щ.
                  As  before,  the  mth  algorithm  uses  all  other  щ  (with  t  ф  m)  to  construct 
             solutions to  (X —y Y) —>• Y;  then p is applied to these solutions.  Note that if we 
             know all ut except um, we either know all strings in X (and can construct a solution 
             to X) or all strings in Y (and can construct a solution to T; in fact, we get several 
             solutions for Y, since Y is a disjunction of singletons, but this is not important).  It 
             may even happen that we can find solutions to both X and Y (e.g., if the missing 
             string appears neither in X nor in Y).  Having a solution to X or 7, we may (as 
             before) construct a solution to  (X —> Y)  —> Y and apply p to it.  If we are lucky 
             enough to get pair [£, ut\ with t — m as the output of p (recall that m is the number 
             of the missing string we want to reconstruct), we know urn.  (A technical note:  we 
             assume that solutions to Y and Z are pairs of the form [t,ut]; it is not exactly the 
             case since we have not defined disjunction of many problems and should consider 
             (■их V (112 V (• • • {uk- 1 V Uk) •••))) instead, but this is inessential.)
                 The only problem is to ensure that  (for some m)  this will indeed work,  i.e., 
             that we will obtain a pair [t, щ\ with t — m.  This is done again using computability 
             theory.  Instead of computably inseparable sets,  we now use a more general con­
             struction, a computable diagonal function d.  A function d from the set of natural 
             numbers to its subset S is called diagonal if for every partial computable function 
             и of the same type there exists i such that d(i)  ~ u(i).  (Here a ~ b means that 
             either both a and b are undefined or both are defined and a = b.)  A computable 
             diagonal function can be constructed as follows:  Let d{i)  be the value of the zth 
             computable function on i.
                 For S = {0,1}, i.e., for Boolean-valued functions, such a function is determined 
             by  two  disjoint  enumerable  sets  (preimages  of 0  and  1);  the  diagonal  property 
             implies that no total Boolean function can be different from d everywhere, so these 
             enumerable sets are inseparable.
                 In the proof, we will use a computable diagonal function from the set of natural 
             numbers to the set S = {1,..., A:}.  More specifically, for every к strings vx,..., Vk 
             and for every natural number i, we will construct a program qi(vx, • ■ ■ ,Vk) that has 
             the following properties:
