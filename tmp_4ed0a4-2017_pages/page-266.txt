                                                                   8.5.    FORBIDDEN  SUBSTRINGS                                                            253
                            How large can be t to make the LL applicable?  Since all the clauses have the 
                     same size,  it  is natural to use the same value of e for all of them.  This e should 
                     satisfy the inequality
                                                                             2“m
                     (the left-hand side is the probability that a given clause is false).  The right-hand 
                     side is maximal when e — l/(i + 1), but to simplify the computation we let e — 1ft 
                     instead.  Then the right-hand side is (1 — l/t)1 ft, which is almost If et.  So we need 
                     (approximately) t ^ 2m/e to apply the LL. In the constructive proof we use a bit 
                    stronger requirement, namely, t ^ 2m/8.
                            Theorem  163.  There exists a probabilistic algorithm that founds a satisfying 
                     assignment for a given CNF with n variables and N clauses of size m where each 
                     clause has at most 2m/8 neighbors,  in time polynomial inn + N and with success 
                    probability at least If2.
                            (As usual, the bound for success probability can be amplified easily:  Repeating 
                    the  algorithm  s  times,  we  find  a satisfying  assignment  with  probability  at  least 
                     1- 2“s.)
                           P r o o f.  Our algorithm uses the recursive procedure Fix(d)  (where d is some 
                    clause) and works as follows:
                                                               for all clauses d of a given CNF : 
                                                                   if d is false:  Fix(d)
                    All the clauses of a given CNF are processed in some order.  The processing of a 
                    clause d is simple:  If d is not satisfied yet, is is  “fixed”  by calling Fixfd).  To prove 
                    the correctness of the algorithm, we need the following property of the procedure 
                    Fix(d):  It makes clause d true and keeps true all clauses that were true before the 
                    call.  (Some clauses that were false before the call may become true;  this is even 
                    better for us since it saves some future work.)
                           The procedure Fix(d) is simple, too:
                                               resample all variables in d using fresh random bits; 
                                               for all clauses d' that are neighbors of d: 
                                                   if d' is false:  Fix{d')
                           Note that it may happen (with small probability) that the new random values 
                    are in fact the same as before, so the resampling does not make d true.  It would be 
                    natural to perform the resampling again until we get new values, but it is easier to 
                    postpone this and just consider d as its own neighbor (so that the resampling will 
                    be performed later as part of the loop, if it would still be necessary at that time).
                           The correctness of this procedure (assuming that the recursive calls work cor­
                    rectly)  is  obvious:  During the resampling only the clauses that  are neighbors of 
                    d  may  become false,  and they all will be fixed in  the  loop  (including d itself,  if 
                    necessary).  The only problem is to prove that  the process terminates with high 
                    probability in polynomial time.  For that let us analyze how this process uses ran­
                    dom bits.  (We assume that random bits are produced in advance and used when 
                    needed.)
                           First of all, we use n random bits as initial values of the variables.  Then each 
                    call  Fix(d)  uses the next m random bits to resample variables in d.  (Recall that 
                    we do not resample d twice even if the resampling gives the same bad values;  it 
                    simplifies our analysis.)  The following is a crucial observation:  At every step
