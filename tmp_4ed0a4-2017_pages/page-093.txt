                          4.  A  PRIORI  PROBABILITY  AND  PREFIX  COMPLEXITY
            78
            times.  The algorithm enumerating all the pairs  (r, i)  with r < pi works in steps. 
            On step n compare r and p(i, n) where (r, i) is the nth pair in the chosen sequence. 
           If r  < p(i,n),  then output the pair  (r,i),  otherwise proceed to the next step.  By 
           definition, r < limnp(i,n) if and only if there exists n such that r < p(i,n).  Thus 
           we will output all the pairs in the set, and no other pairs.
               Conversely,  assume that the property r  < Pi  is enumerable,  and let A be an 
           algorithm  enumerating  all  such  pairs  (r,i).  To  compute p(i,n),  we  simulate  n 
           steps of the computation performed by A.  Consider all the pairs that  appeared 
           within n steps and have i as the second component.  Let p(i,n)  be equal to the 
           largest  first  component  of such  pairs.  If there  are  no  such  pairs,  let  p(i,n)  = 
            —oo.  As n increases,  new pairs may appear and p(i. n)  may increase.  The limit 
           limnp(2,n) is equal to pi, since all the rational numbers less than pi will appear in 
           the enumeration.                                                            □
               We are now able to characterize probability distributions generated by proba­
           bilistic machines.
               Theorem 46.  (a) Let M be a probabilistic machine without input that outputs 
           natural numbers.  Let pi  denote  the probability  that  the  machine  outputs  i.  The 
           sequence of pi  is lower semicomputable and YliPi ^ 1-
               (b) Letpo,p\,...  be a lower semicomputable sequence of non-negative real num­
           bers such that J2iPi ^ 1-  There is a probabilistic machine M that outputs every i 
           with probability exactly Pi.
               PROOF.  The proof of item (a) is similar to the proof of corresponding statement 
           in the previous theorem.  We let p(i,n) be the probability that M outputs i within 
           n steps.
               The proof of item (b) is also similar to the proof of corresponding assertion in 
           the previous theorem.  This time we assign to each natural i a subset of [0,1] and the 
           machine outputs i if the real number ß = 0.bç,b\b2 ■..  belongs to the set assigned 
           to i.  The sets assigned to different values of i do not overlap.  They may not cover 
           the entire segment  [0,1].  The set assigned to every i is a finite or countable union 
           of half-open intervals [a, b) of total length pi.  When an approximation for some pi 
           increases,  we add a new interval for this i  (its length is the increase) just on the 
           right  of intervals  allocated  earlier.  (So  at  each  moment  the used part  of [0,1]  is 
           [0, s) for some s.)
               In parallel,  we toss a coin and obtain digits of the random number ß.  When 
           we are sure that ß gets into the set assigned to some natural number, we output 
           that number.
               Here is a formal argument.  Let p(i, n) be the function of two variables from the 
           definition of lower semicomputability.  Without loss of generality we may assume 
           that p(i, n) ^ 0 for all г, n.  Indeed, we can replace all negative values by zeros.  We 
           may assume also that for all n only finitely many values p(i,n)  are positive  (let 
           p(i,n)  = 0 for all i  ^  n).  The probabilistic  algorithm that we construct  runs in 
           steps.  On each step we allocate some space inside [0,1].  Our goal is that after the 
           nth step the total length of intervals allocated to i is equal to p(i, n) (for all i).  This 
           requirement is easy to keep:  going from left to right, on step n we allocate for each 
           i  (such that p(i, n) > p(i, n — 1)) a new interval of length p(i, n) — p(i, n — 1).  We 
           need to do this only for finitely many i, as for i ^ n we have p(i, n) = p(i, n — 1) = 0.
