              206                      6.  GENERAL  SCHEME  FOR COMPLEXITIES
                   Consider some point (n, x).  Let us try to add a horizontal ray that goes on the 
              right from this point to our set  (i.e.,  add all pairs  (m,x)  for all m ^ n).  The set 
              may remain thin or not,  and these two cases can be distinguished by a (У-oracle. 
              Indeed, the negation of being thin is an enumerable property (there exists a section 
              that has at least 2k different elements including the added one).
                   Let us perform these attempts (to add the horizontal ray starting from some 
              pair  (n,x))  sequentially  for  all  pairs  in  some  order.  (If some  ray  is  added  suc­
              cessfully,  then  its  elements  are  taken  into  account  for  all  subsequent  attempts.) 
              This process is (У-computable and therefore the ordinates of all added rays form a 
              (У-enumerable set.
                   This set has fewer than 2k elements (since we add rays only if the resulting set 
              is  still  thin)  and contains every x such that lim sup C(x \ n) < k.  Indeed,  for such 
              an x there is some ray that lies entirely in the initial set, and this ray can be added 
              at any time.                                                                                  □
                   (This proof is a simplified version of the proof given in  [196].  See also similar 
              arguments in [16].)
                   We can also obtain the results for prefix complexity that are similar to The­
              orems 131 and 132.  However, the definition of conditional prefix complexity with 
              respect  to  a set  is  quite subtle,  so  we postpone  its  discussion  and start with the 
              second theorem.
                   Theorem 133.
                                           limsupK(x\n) = K° (x) + 0(1).
                                            n—J-OO
                   Proof.  Using a priori probabilities (conditional and unconditional), we rewrite 
              the statement as follows:
                                                lim inf m(x \ n) = m° (x)
                                                 n —» oo
              (the equality is understood up to a bounded factor in both directions).
                   Let  us  show  first  that  the  left-hand  side  is  greater  than  the  right-hand  side 
              (up to  an O(l)-factor).  Indeed,  consider a (У-oracle probabilistic machine whose 
              output has distribution m° .  Then for any integer n we may run this machine with 
              a changed oracle:  instead of the entire oracle we use its approximation obtained 
              after n steps.  This, of course, changes the output distribution, however, the lim inf 
              of the probabilities to get some x using n-approximation to the oracle (as n —> oo) 
              is  greater  than  or  equal  to  the  probability  of getting  x  with  the  entire  oracle. 
              Indeed, the latter probability is the measure of an open set of all bit sequences that 
              are mapped to x using a (У-oracle.  This open set is a union of intervals,  and for 
              each interval the computation depends only on some finite part of the oracle, and 
              therefore the same random bits will give the same output x if the approximation 
              to  the oracle is good enough  (i.e.,  n is sufficiently large).  (Note that  lim inf can 
              be bigger than the probability of getting x with the final oracle, since approximate 
              oracles can force output x for combinations of random bits that do not generate x 
              with the final oracle.)
                   Now let  us  prove  the  reverse  inequality.  This  proof resembles  the  proof of 
              Theorem 132.  We have a lower semicomputable family of semimeasures:  for each n 
              the function x h-> m(x\n)  is a semimeasure (i.e.,  J2xm (x \n)  ^  1  for each n).  It
