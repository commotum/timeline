                                                                  5.5.   MONOTONE COMPLEXITY                                                              137
                           Let  us now try to combine two strategies with the same amplification factor 
                     k.  Our goal is to keep this amplification but increase the size of the request  and 
                    of the gray area.  Consider a tree where the root  has two sons with subtrees T\ 
                    and T2.  Assume that Client has a winning strategy for Ту, aq, ßy, e, and a winning 
                    strategy for T2, 0:2, /З2, £■  Let Client use these two strategies sequentially:  the first 
                    strategy  is  used  for  Tb  and  when  it  wins  (the  gray  area  is  large  enough),  the 
                    second strategy is used for T2.  (One can  assume without  loss of generality that 
                    during Ti-game nothing is allocated for the vertices in T2, since these allocations 
                    can be postponed.)  The total size of requests is then bounded by on + a2.  But we 
                    cannot claim the additivity for gray areas:  it is quite possible that the size of the 
                    e-neighborhood of the union is smaller than the sum of the sizes of ^-neighborhoods 
                    of the parts.  For example,  in the second game Server can use some space left as 
                    reserve in the first game.
                           To  avoid  this  problem,  we  use  different  values  E\  and  £2  for  the  strategies. 
                    Assume that E\  <C £2  and the second strategy uses only requests of size at least 
                    £\.  Then  Server cannot  use  the gray  area of the first  game  for the  second  one. 
                    Informally, we accumulate reserves “on different levels”, first on a micro level, then 
                    on a macro level.  However, we cannot say that the gray areas are added.  While the 
                    space allocated for T2 does not intersect the £j -neighborhood for Ту, the opposite 
                    is  possible:  space allocated for Ту  may well intersect the ^-neighborhood for T2. 
                    To deal with this problem, we again consider a more general setting and agree that 
                    some set A C Q is fixed before the game starts; we say that A is unavailable to the 
                    server, and count only the new gray intervals.  Let us explain in detail what all this 
                    means.
                           The final version of the game has the following parameters:
                                •  a tree T;
                                •  a subset A C Q ( “space unavailable to Server” ) ;
                                •  8 (shows how the neighborhood of the unavailable space is measured);
                                •  £ (shows how the neighborhood of the allocated space is measured);
                                •  the maximal allowed request a for the root;
                                •  the required size of gray area /3;
                                •  the required amplification factor k.
                           We assume that £ and 8 are both (negative) powers of 2, and £ ^ 8.
                           Here  are  the  rules  of the  game.  Client  increases  requests  for  vertices  of T 
                    (the request of a vertex should be at least the sum of requests for its sons).  The 
                    minimal request is 5,  and the root request should not exceed a.  Server allocates 
                    space for vertices of T, fulfilling the requests, and should use only intervals that do 
                    not intersect A.  Client wins if the size of the new gray area  (e-neighborhood of the 
                    allocated space minus 8-neighborhood of A)  is at least ß  and is at least к  times the 
                    request for the root.  As before, adding vertices to the tree or increasing e, we make 
                    Client’s task easier.  This happens also if we decrease 5, /3, or k.  One may assume 
                    without loss of generality that A is made of intervals of size at least 8 (since only 
                    the Æ-neighborhood of A matters).
                    at least e.  But this rounding effect cannot be scaled recursively, so we will ignore it.  Also we can 
                    use the sons only  (not the grandsons), first asking e/2 for each of them and then increasing the 
                    requests for the vertices where Server provides  no reserve.  However,  the version with grandsons 
                    is  closer to the strategy in the general case (see the proof of Composition Lemma,  page 138),  so 
                    we have chosen this version.
