                                                                 5.5.   MONOTONE COMPLEXITY                                                              135
                    such that the request for x at some moment exceeds 2” KM(X).  On the other hand, 
                    during the game,  Client  (using her computable strategy against the computable 
                    Server)  enumerates  from  below  some  semimeasure  jic  on  the  tree:  its  value  at 
                    vertex x is equal to the limit (=supremum) of all requests for x.  Since Client wins, 
                    for some x we have KM(x) > — logßc(x).  The weighted sum of semimeasures /ic 
                    with weights 2c/c2 is a lower semicomputable semimeasure on the infinite binary 
                    tree and is bounded by the continuous a priori probability (up to an O(l)-factor). 
                    So the a priori probability is at least £цс(х)2с/с2 for some fixed e > 0 and for all 
                    c, x.  We conclude that for every c there exists a string x of length at most 2°^c2 ) 
                    such that
                                                         KM(x) > KA (x) + c — 2loge — 0(1).
                    Let n be the length of x; then c is at least log log n — O(logloglogn) and therefore 
                                                  KM(x) > К A (x) + log log n — О (log log log n).
                           Note that our argument constructs a string x of length n with this property for 
                    infinitely many n, but not for all (sufficiently large) n.
                            138  Prove that  for  infinitely  many  n  the  following  is  true:  for  all  strings 
                    of length n the difference KM(x) — К A (x)  is bounded by log log log n.  Here the 
                    iterated logarithm can be replaced by an arbitrary non-decreasing unbounded com­
                    putable function.
                           (Hint:  If some rare lengths are declared as very important, we can allocate the 
                    space for strings of each rare length in a special area reserved for this length, thus 
                    making the overhead rather small compared to length.)
                           P r o o f.  Let  us  start  the  proof of Theorem  88  with  an  informal  discussion. 
                    What is the source of difficulties for Server?  Imagine that Client requests a very 
                    small amount of space for some vertex.  Server then has a choice:  either allocate 
                    a part of the free zone (neighbor intervals are not allocated for any other vertex) 
                    keeping in mind the possible increase of the request,  or  do not  think about  this 
                    possible increase and allocate some (maybe) non-extendable space.
                           The danger in the first case is that this reserved space will never be used,  if 
                    Client will not increase the request or will increase it so much that this reserved 
                    space cannot  be used  (as  it  is  too  small  anyway).  In the  second  case,  if Server 
                    allocates neighbor intervals to other vertices, and then Client increases the request, 
                    the originally allocated interval is lost, since only contiguous intervals matter.
                           The winning strategy for Client exploits this dilemma.  To keep track of the 
                    process, we look at ^-neighborhoods of different vertices.  Let e < 1 be a negative 
                    power of 2.  By £-neighborhood of some set X in the Cantor space we mean the 
                    union of all intervals of length £ that have non-empty intersection with X.  The 
                    interim goals of Client are formulated as follows:  the ratio
                                           the size of e-neighborhood of the space allocated for x 
                                                                              request for x
                    is at least some k.  For large k, if the requested space is more than 1 /к, Server loses.
                           Following this plan, we construct strategies for Client achieving that at some 
                    moment
                                •  the request for the root is at most a;
                                •  the e-neighborhood of the space allocated for the root, is at least ß.
