                         1.  PLAIN  KOLMOGOROV COMPLEXITY
         22
            In  general  the  notion  of  Kolmogorov  complexity  has  a  number  of  connec­
         tions with computability theory.  Recently, many interesting facts were discovered; 
         see  [147,  49].  We consider here only two basic examples  (a simple set of simple 
         strings and the complexity of large numbers).
            1.2.1.  Simple strings and simple sets.  In this section, the word  “simple” 
         has  two  unrelated  meanings.  First,  when  applied  to  strings,  it  means  that  the 
         Kolmogorov  complexity  of the  string  is  small.  Second,  it  is  applied  to  sets  of 
         strings.  The notion of a simple set was introduced by the American logician Emil 
         Post and has no relation to Kolmogorov complexity.
           Definition.  An enumerable set A is simple (according to Post) if its comple­
         ment is infinite but has no infinite enumerable subset.
           Call a string x simple if C(x) < l(x)/2.
           Theorem 10.  The set of all simple strings is simple in the sense of Post.
           Proof.  That set S of all simple strings is enumerable.  Indeed,  the function 
         C is upper semicomputable, and if C(x) is less than  |x|/2, this can be seen while 
         approximating C(x) from above.
           The number of strings of complexity less than n/2 does not exceed 2n/2.  There­
         fore the fraction of simple strings among strings of length n is negligible, and the 
         complement of S is infinite.
           Assume now that the complement of S has an infinite enumerable subset U.  We 
         can use U to obtain a computable unbounded lower bound of C.  To find a string of 
         complexity greater than t, we can generate elements of U until we find a string щ of 
         length greater than 21.  As U is infinite, there is such a string.  The complexity of щ 
         is greater than t; otherwise, ut is simple.  Without loss of generality we can assume 
        that  the strings щ, t =  1,2,...  are pairwise different.  Thus the function щ  i-> t 
         is  a  computable  unbounded  lower  bound for  C.  This  contradicts to  Theorem 6 
         (page 9).                                              □
           Note that the choice of the threshold Z(x)/2 in the definition of a simple string 
        was not essential.  The proof of Theorem 10 would work as well with l(x) — 1 or 
        log log/(x) in place of Z(x)/2.
           1.2.2.  Complexity of large numbers.  Let us identify a natural number m 
        with the binary string having index m in the standard enumeration of binary strings. 
        In this way C becomes a function of a natural argument.  The function C(m) goes 
        to  infinity  as  m —>  oo.  Indeed,  for  all n  there  are only  finitely  many  integers of 
        complexity less than n.  However, the convergence is not effective.  That is, there is 
        no algorithm that, for every given n, finds a number N such that the complexity 
        of N and of all larger numbers is bigger than n.  Indeed, such an algorithm would 
        provide an effective way to describe the number N, whose complexity is at least n, 
        by logn + 0(1) bits.  We have seen this in the proof of Theorem 6 (p. 9).
           In  this  section,  we  study  in  detail  the  rate  of convergence  of C  to  infinity. 
        Following Chaitin  [31],  we consider for every natural n the largest number В in) 
        whose complexity is at most n:
                         В (n) = max{m G N | C(m) + n}.
        The function п\-л B (n) may be called the modulus of the convergence of C(m) to 
        infinity (see Figure 1).  Indeed, C(x) > n for all x > B (n) (and B (n) is the minimal
