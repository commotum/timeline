                                       5.5.  MONOTONE COMPLEXITY                           129
                5.4.3.  Computable mappings can be enumerated.  The definition of com­
            putability based on robust machines seems to be more natural than the abstract 
            one.  However, it has the same drawback as in the case of prefix-stable programs: 
            there is no (algorithmic) way to find out whether a given program is robust.  So the 
            class of robust programs is not a syntactically defined class.
                Nevertheless, there exists an algorithmic transformation of programs that con­
            verts every program into a robust one (and does not change the mapping computed 
            by it if it was robust).  This transformation goes back and forth between mappings 
            and corresponding enumerable sets:  we transform a program into an enumerable 
            set of pairs (i.e.,  into an algorithm enumerating this set), then we trim this set of 
            pairs and transform it back into a program.
                We do not describe this process in detail, since robust programs are more a mo­
            tivation for the definition of a computable mapping than a technical tool.  Instead, 
            we prove that the set of computable mappings is enumerable in the following sense:
                Theorem 83.  There exists an enumerable set U  of triples (n,x,y)  (here n is 
            a natural number while x  and y  are binary strings)  such that:
                (a)  for every n  the set Un  —  {(x,y)  |  (n,x,y)  €  U}  is  a lower graph of some 
            computable  mapping un :  E  —>  E  (i.e.,  it  satisfies  requirements  (l)-(3)  of Theo­
            rem 81);
                (b)  every computable mapping of the set E into itself is equal to un for some n.
                Proof.  Consider the universal enumerable set W of triples:  every enumerable 
            set of pairs appears among Wn.  Then we trim W to enforce requirements (l)-(3) for 
            all  Wn  and leave unchanged the sets Wn that already satisfy these requirements. 
            After that  all  Wn  are  lower  graphs  for some  computable  mappings  wn  and  any 
            computable mapping appears among wn.
                The trimming is made in two steps:  first we delete inconsistencies and then we 
            fill  the gaps.  The inconsistency appears when two pairs  (x\,y\)  and  (£2,2/2)  are 
            found such that x\  is compatible with £2 but y\  is not compatible with 2/2 •  (It is 
            easy to see that two pairs with this property cannot both appear in the lower graph 
            of a continuous mapping.)  To eliminate it, we delete the pair that appeared later 
            in the enumeration.  Then we fill the gaps by adding all pairs (x, Л) and adding for 
            each pair (x,y)  all the pairs  (x',y')  with x1 )p x and y' =4 y.  It is easy to see that 
            the set remains enumerable and is the one we need.                             □
                Theorem 83 is used in the next section to prove that an (optimal)  monotone 
            complexity function exists.
                                     5.5.  Monotone complexity
                To define monotone complexity, we use computable mappings of type E —> E 
            as  decompressors  (description modes).  For a fixed decompressor D:  E  —>  E  the 
            monotone complexity of a string x  (with respect to D)  is defined as the minimal 
            length  of a  string  у  such  that  x  =<;  D(y).  Monotone  complexity  is  denoted  by 
            KM D(x).
                (This definition can be applied to infinite sequences x without any changes, but 
            we follow the tradition and consider KMd(x) only for finite x unless the opposite 
            is said explicitly.)
