                                                                      4.3.   PREFIX  MACHINES                                                            81
                    happen that the fcth program does not define any lower semicomputable semimea­
                    sure.  (It may compute a function which is not total or a function that sometimes 
                    decreases in the second argument or a function whose sum is greater than 1.)
                           The bug can be fixed using the following:
                           Lemma.  Every program P computing a function of two natural arguments and 
                    taking  rational  values  (and possibly  the  value  — oo)  can  be  algorithmically  trans­
                    formed into a program P' having the following properties.  The program P'  defines 
                    a lower semicomputable semimeasure.  If the program P itself defines a lower semi­
                    computable semimeasure,  then P'  defines the same semimeasure.
                           PROOF.  Let P be any program satisfying the condition of the lemma.  (We do 
                    not assume that P is total.)  First we let P'{i,n) be equal to the maximal number 
                    output within the first n steps in the computations of Р(г,0),... ,P(i,n).  If none 
                    of these computations terminate within n steps or all the results are negative, we 
                    let  P'{i,n)  =  0.  This  definition  guarantees  that  P'(i,n)  is  non-negative  and  is 
                    non-decreasing in n.  For every г, if P(i,n) is defined for all n and is non-negative 
                    and non-decreasing in n, then limn P'(i,n) = limn P(i,n).
                          It remains to ensure that ^p'i ^ 1 where p\ — limnP'(i,n).  To this end first 
                    let  P'(i,n)  = 0 for all n                   i.  This transformation does not change the limit and 
                    preserves monotonicity in n.  The advantage is that now the sum of P'(i,n) over 
                    all  i  is  finite  and  can be computed for every n.  We need that this sum does not 
                    exceed 1.  To enforce this, we do not increase P' if we see that this would violate 
                    our restriction.  We first trim the value P'(i,n) for n = 0, then for n = 1, etc.  The 
                    lemma is proven.
                          Using  the  transformation  described  in  the  lemma,  we  arrange  all  the  lower 
                    semicomputable semimeasures into a computable sequence.  The weighted sum of 
                    all  its  terms  is  a  maximal  lower  semicomputable  semimeasure.  Thus  we  obtain 
                    another proof of Theorem 47.
                          Fix any maximal lower semicomputable semimeasure on the natural numbers. 
                    We will use the notation m(i) or mi for the probability of i and the letter m for the 
                    semimeasure itself.  The value m(i) is called the a priori probability of i.  (Another 
                    name for m is the  universal semimeasure on N.)  Here is an explanation of this 
                    term.  Assume that we are given a device  (a black box)  that  after being turned 
                    on produces a natural number.  For each i we want to get an upper bound for the 
                    probability that the black box outputs i.  If the device is a probabilistic machine, 
                    then a priori  (without  any other knowledge about  the box)  we can estimate the 
                    probability of i as m{i).  This estimate can be much greater than the  (unknown) 
                   true probability, but only 0(1) times less than it.
                          The  a priori  probability  of  a  number  i  is  closely  related  to  its  complexity. 
                    Roughly speaking, the less the complexity is, the larger the a priori probability is. 
                   More specifically, we will show that a slightly modified version of complexity (the 
                   so-called prefix complexity) of i is equal to — logm(i).
                                                                    4.3.  Prefix machines
                          The difference between prefix complexity and plain complexity can be explained 
                   as follows.  Defining prefix complexity, we consider only self-delimiting descriptions. 
                   This means that the decoding machine does not know where the description ends
