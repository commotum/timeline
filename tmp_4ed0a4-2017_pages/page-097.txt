                           4.  A  PRIORI  PROBABILITY  AND  PREFIX  COMPLEXITY
            82
            and has to find this information itself.  One can clarify this idea in several non­
            equivalent ways.  We will discuss all of them further in detail.
                Let us start with a following definition.  Let /  be a function whose arguments 
            and values are binary strings.  We say that /  is prefix stable, if the following holds 
            for all strings X, y.
               (f(x) is defined) and (x is a prefix of у) =*> f(y) is defined and f(y) = f(x).
                Theorem 48.  There exists an optimal prefix-stable decompressor (for the fam­
            ily of all prefix-stable decompressors).
                Proof.  Recall that a decompressor (description mode) is a computable func­
            tion mapping strings to strings.  (All strings are binary.)  The plain complexity is 
            defined using an optimal function in the class of all such functions.  Now we restrict 
            the class of decompressors to computable prefix-stable functions.  We assign to each 
            prefix-stable function D the complexity function Kd, which is as defined earlier: 
            Kp(x) is the length of a shortest description of x with respect to D (i.e., minimal 
            l(y)  among all у such that D(y) — x).  So the definition of Кр(х) coincides with 
            that of Cd(x);  we write К instead of C just to stress that we consider now only 
            prefix-stable decompressors.
                We have to show that there exists an optimal prefix-stable decompressor D (for 
            the class of all prefix-stable decompressors).  The latter means that for any other 
            prefix-stable decompressor the inequality Kd(x) ^ Kd<(x) + c holds for some c and' 
            all x.
                Recall that  for the plain  complexity we have constructed an optimal decom­
            pressor D by letting
                                             D(py) =p(y).
            Here p is  a self-delimiting description  of p,  say,  p = pOl  where p stands  for the 
            string p with all bits doubled.  The notation p(y) refers to the output of the pro­
            gram p given input у (more precisely, the string p is interpreted as a program in a 
            universal programming language).
               Is  this  decompressor  a prefix-stable  one?  Certainly  not.  Indeed,  there  is  a 
            program p computing a function that is not prefix stable, say, p(0) = a and p(00) = b 
           where a ^ b.  Then D(p0) — a and D(p00) = b.
               To construct an optimal prefix-stable decompressor, we modify the definition of 
            D as follows.  We enforce prefix-stability of programs by converting every program 
           p to another program \p\ that works as follows:
                (1)  Apply p to all  inputs in parallel.  If the computation of p on an input у 
           halts with output 2, we write down the pair (y, z).  Let {yi^zf) denote the resulting 
           sequence of pairs (enumerating the graph of p:  Zi = p(yi)).
                (2) We delete some terms of the sequence (p*, zf).  Let us call strings у and y' 
            compatible if one of them is a prefix of the other one (an equivalent definition:  both 
           strings are prefixes of some third string).  We say that a pair  {yi,Zi)  contradicts a 
           pair  (yj,Zj)  if yi  is compatible with pj,  but Zi ^ Zj.  We delete a pair  (yi,Zi)  if it 
           contradicts some other pair (pj, zf) with j < i.  (The argument would work as well 
           if we delete a pair only when it contradicts a поп-deleted previous pair.)
                (3)  Computing the sequence  (yi,Zi)  and  filtering out  some of its  terms  is  a 
           process that does not depend on the input for the program [p].  The input string у 
           is taken into account as follows.  We wait until a (non-deleted) pair (yi, zf) appears
