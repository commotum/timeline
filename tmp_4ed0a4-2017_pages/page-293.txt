        280     9.  FREQUENCY AND GAME APPROACHES TO RANDOMNESS
           (d)  Not every Mises-Church random sequence is computably random.
          Proof,  (a) We know from Theorem 181 that even lower semicomputable mar­
        tingales (not only computable ones) cannot win on an ML-random sequence.
           (b) We have already mentioned that for every martingale there exists a sequence 
        on  which  this  martingale  is  bounded  (we  should  go  in  the  direction  where  the 
        martingale does not increase).
          If a martingale is computable, one can find a computable sequence on which 
        this  martingale  is  bounded.  It  is  a bit  more  difficult—now  we  cannot  find  the 
        minimal value among m(x0) and m(x 1) since we can compute these numbers only 
        with some precision.  But this  is  in fact  not  needed.  It  is  enough  to  choose  an 
        extension where the martingale increases at most by  l/2n  (and this can be done 
        easily if the approximation errors on step n are small compared to l/2n).
          (An immediate corollary is  that the largest  computable  martingale does not 
        exist.  This is one of the main reasons to consider lower semicomputable martingales 
        and supermartingales.)
          But we need to continue the proof of (b).  The next step is to consider two com­
        putable martingales and find a computable sequence where both are bounded.  It is 
        easy to achieve.  Take a weighted sum (e.g., the average) of these two martingales; 
        it is a computable martingale, so we know already that there exists a computable 
        sequence where the  average martingale  is  bounded.  Then both martingales are 
        bounded (with twice bigger bound—recall that martingales are non-negative func­
        tions).
          A similar argument can be used to deal with a computable sequence of com­
        putable martingales (i.e., of programs for them).  Then we may mix all the martin­
        gales in a weighted sum with weight 2“! for 2th martingale.
          The problem is that there is no computable sequence that would include all 
        computable martingales (otherwise there would be a computable sequence on which 
        all  computable  martingales  are  bounded,  which  is  evidently  not  the  case—it  is 
        easy to win on a computable sequence).  So to construct a sequence ш such that 
        no computable martingale wins on it requires some non-algorithmic steps.  There 
        is  additional  information  that  allows  us  to  perform  this  construction:  For  each 
        program we should be informed whether this program computes a martingale, so 
        we require one bit of information per program.  To get a sequence with logarithmic 
        complexity,  we  should  use  this  information  in  a very economic way,  taking into 
        account the information about 2th program only after a long prefix of the sequence 
        (say, of length 2г, or even more) is constructed.
          Let us describe the construction in more detail.  At every step we have some 
        bit string X  (the bits already fixed) and some linear combination
                       mi (x) + £2m2(x) H------(- ekmk(x)
        with positive coefficients.  Here m*  is a martingale computed by 2th program  (or 
        some replacement martingale, or just zero, if the 2th program does not compute a 
        martingale according to the advice we got).  We maintain the invariant relation: this 
        combination is strictly less than 2.  (Initially, x = A, we have only one martingale 
        mi, and the combination is equal to 1.)
          As we already discussed, the string x can always be extended by one bit in such 
        a way that the expression remains less than 1  (and this can be done effectively as 
        we know the programs for martingales).  So we can extend x while keeping к (the
