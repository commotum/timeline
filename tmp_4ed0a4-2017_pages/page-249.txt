             236                             8.  SOME  APPLICATIONS
             the second term is small compared to the first one for large n (we may then formally 
             extend the result to every n by decreasing the coefficient e).                       □
                 Is Kolmogorov complexity essential in this proof?  The skeptical observer may 
             say again that we in fact just counted the number of different strings that can be 
             copied in a limited time  (using the fact that different  strings should have differ­
             ent  crossing sequences,  otherwise the behavior of the machine at the right of the 
             boundary would be identical).  Indeed,  the original proof follows this scheme  (in 
             fact,  it  deals with palindrome recognition,  not the duplication,  but the technique 
             is the same).  Does the language of complexity make the proof more intuitive and 
             easy to understand?  Probably this is a matter of taste.
                 Many bounds in computational complexity theory can be proven in the same 
             way, using the string of maximal complexity as the worst case and proving that the 
             violation of the bound would imply this string is compressible.  Many applications 
             of this type  (and further references)  are given in the classical textbook  [103];  its 
             authors,  Ming Li and Paul Vitânyi,  played an important role in development of 
             this approach,  called the incompressibility method.  Note that in several cases the 
             historically first proof was obtained using Kolmogorov complexity.
                 In the next section we consider one more application of the incompressibility 
             method, then we switch to other applications.  The most interesting thing in these 
             applications is not the statements in themselves but the various methods that allow 
             us to apply Kolmogorov complexity to prove statements that do not mention it»
                                8.3.  Finite automata with several heads
                 A finite  automaton  with  к  heads  is  similar  to  the  ordinary  one  (we  assume 
             that  the reader  is  acquainted with  basic  notions  related to  finite  automata;  see, 
             e.g.,  [185]),  but  it  has к one-way read-only heads.  Here  one-way means that the 
             head can only move from left to right.
                 Initially all к heads observe the leftmost character of the input string.  At each 
             step the behavior of the automaton is determined by its state and the к symbols 
             it  observes  (under к heads):  the automaton changes the state and instructs some 
             heads (at least one) to move to the right.  Then the automaton performs the next 
             step, etc.
                 The input string is followed by a special marker; the automaton terminates if all 
             the heads observe this marker.  (We assume that the head that sees the marker does 
             not move to the right.)  Automaton  accepts the string if it gets into an  accepting 
             state after processing this string.  We say that the automaton recognizes the set of 
             all accepted strings.
                 Example.  Consider the language (=set of strings) x#x where x is any binary 
             string.  It  is  well  known  that  this  language  cannot  be  recognized by  a standard 
             (one-head) automaton.  However, it is easily recognized by a two-head automaton. 
             Indeed, we should send one head to look for the separator #, when the separator is 
             found, two heads move synchronously and check that they read the same symbol.
                 So two heads are better than one (more languages can be recognized).  It turns 
             out that the same is true for more heads:  к + 1 heads are (strictly) better than к 
             heads.
                 Theorem 154.  For every к there exists a language that can be recognized by a 
             (k + 1 )-head automaton but not by a к-head one.
