                                     CHAPTER 2
            Complexity of pairs and conditional complexity
                               2.1.  Complexity of pairs
             As we have discussed, we can define complexity of any constructive object using 
          (computable) encodings by strings.  In this section we deal with pairs of strings.  A 
          pair x,y can be encoded, e.g.,  by a string [x,y] — xOly;  here x stands for x with 
          doubled bits.  Any other computable encoding i,!/4  [x,y\ could be used (of course, 
          we need that  [x,y\ ф [x',y']  if x ф x' or у ф у').  Any two encodings of this type 
          are equivalent  (there are translation algorithms in both directions), so Theorem 3 
          (p. 5) guarantees that complexities of the different encodings of the same pair differ 
          by 0(1).
             Let  us  fix some encoding  [x,y\.  The  Kolmogorov complexity of a pair x,y is 
          defined as C([x,y]) and is denoted by C(x,y).  Here are some evident properties:
               •  C(x,x) — C(x) + 0(1);
               •  C(x, y) = C(y. x) + 0(1);
               .   C(x) ^ C(x, y) + 0(1); C(y) ^ C(x, у) + 0(1).
             The following theorem gives an upper bound for the complexity of a pair in 
          terms of complexities of its components:
             Theorem 16.
             C(x,y) < C(x) + 21og C(x) + C(y) + 0(1);
             C{x,y) ^ C(x) + logC(x) + 2 log log C{x) + C{y) + 0(1);
             C(x, y) ^ C{x) + log C(x) + log log C(x) + 2 log log log C(x) + C(y) + 0(1);
             (We can continue this sequence of inequalities indefinitely.  Also,  one can ex­
          change x and y.)
             PROOF.  This proof (for the first inequality) was already explained in the in­
          troduction (Theorem 4, p. 6).  The only difference is that we considered the con­
          catenation xy instead of a pair.  Let us repeat the argument for pairs.
             A computable mapping x i-+  x  (here x and x  are binary strings)  is called a 
          prefix-free  encoding,  if for  any two different  strings x  and у the string x is not  a 
          prefix of the string y.  (In particular, x ф у if x ф у.)  This guarantees that both и 
          and v can be uniquely reconstructed from ûv.
             An example of a prefix-free encoding is ж и  xOl,  where x stands for x with 
          doubled bits.  Here the block 01 is used as a delimiter.  However, this encoding is 
          not the most space-efficient one,  since it doubles the length.  A better prefix-free 
          encoding is
                                 x i  ^ x — bin(/(x)) Olx,
                                          31
