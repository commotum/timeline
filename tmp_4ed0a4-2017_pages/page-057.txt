                        2.  COMPLEXITY  OF  PAIRS  AND  CONDITIONAL  COMPLEXITY
            42
                ___Prove that for some constant c for any string x and for every number n,
                 46
            there exists a string y of length n such that
                                        C(xy) ^ C(x I n) + n — c.
                (.Hint :  For a given n the number of strings x, such that C(xy) < к for any у of 
            length n. does not exceed 2A’/2n, and this property is enumerable.  So we can apply 
            Theorem 19 (p. 36).)
                 47  Let /  be a function with natural arguments and values.  Assume that
                                f(n) + eh ^ /(n + h) < /(n) + (1 -  e)h
            for some e > 0 and for all n and h.  Prove that there exist an infinite bit sequence 
            Ш whose n-bit prefix has complexity f(n) + 0(1) for every n.
                (Hint:  Let us add blocks of length h where h is large enough.  Each new block 
            being added to an n-bit prefix increases complexity by more than f(n + h) — /(n) 
            or by less than f(n + h) — f(n),  depending on the current situation  (whether we 
            are below or above the boundary).  To find a block with a big complexity increase, 
            we may use the previous problem; for a block with a small increase, we can use a 
            block of zeros.  Note that  (large enough)  h is fixed,  so it is enough to control the 
            complexity on the blocks’ boundaries.)
                48  Prove that an infinite sequence xqX\X2 • • •  of zeros and ones is computable 
            if and only if the values C(xо • ■ • xn_\ | n) (the complexities of its prefixes conditional 
            to their lengths) remain bounded by a constant.
                (Hint:  Consider an infinite binary tree.  Let S be the enumerable set of vertices 
            (binary  strings)  that  have  conditional  complexity  (w.r.t.  their  length)  less  than 
            some constant c.  The horizontal sections of S have cardinality 0(1).  We need to 
            derive from this that each infinite path that lies entirely inside S is computable. 
            We may assume that S is a subtree (only the strings whose prefixes are in S remain 
            in S).
                Let u) be an infinite path that goes through S only.  At each level n we count 
            vertices in S on the left of oj  (ln vertices) and on the right of oj  (rn vertices).  Let 
            L = lim sup ln and R = lim sup rn.  Let N be the level such that L and R are never 
            exceeded after this level.  Knowing L, R, and N, we can compute arbitrarily large 
            prefixes of oj.  We should look for a path tt in a tree such that at some level above 
            N there are at least L elements of S on the left of тг and at some (possibly other) 
            level above N there are at least R elements on the right of 7Г.  When such a path tt 
            is found, we can be sure that its initial segment (up to the first of those two levels) 
            coincides with oj.  This result was published in [108]  (attributed to A.R. Meyer).)
                49  Prove  that  in  the  previous  problem  a  weaker  assumption  is  sufficient: 
            instead of C{xо ■ • • xn-\ |n) = 0(1), we can require that C(xо • • • xn_i) < logn + c 
            for some c and for all n.
                (Hint:  In this case we get an enumerable set S of strings (=tree vertices) with 
            the following property:  the number of vertices below level N is 0(N).  This means 
            that the average number of vertices per level is bounded by a constant.  To use the 
            previous problem, we need a bound for all levels and not for the average value.  We 
            can achieve this if we consider only vertices x G S that have an extension of length 
            2l(x) that goes entirely inside S.  This result was published in [33].)
               Following Problem 48,  we can suggest  different definitions of the complexity 
            notion for computable bit sequences:
