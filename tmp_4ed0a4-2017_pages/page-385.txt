                                    12.5.  A  DIGRESSION:  ON-LINE  MATCHING                    375
             exceed clog(a + b) + loge (since c is a power of 2, the complexity of c that appears 
             in the upper bound for C(A\B, X) is much smaller than loge).
                 So we have shown that the combinatorial statement of Theorem 230 is indeed 
             equivalent to its complexity counterpart, Theorem 229 (and is true, since we proved 
             the latter).
                 In fact, the combinatorial translation is possible not only for the statement of 
             Theorem 229, but also for its proof.  During the game, M does not exercise her right 
             to declare new Л-simple strings during the game; she declares all the neighbors of 
                (according to the expander graph) at once.  Then a string A is declared simple 
             A
             given X, В if (1)  A is a neighbor of X,  (2)  A has been declared simple given В 
             by A,  (3) at the moment of this declaration the number of neighbors of X among 
             the strings that  are already declared simple given В  is small.  In this way M  is 
             able to serve,  for each B,  most of the strings that are declared simple for this B. 
             The remaining strings  (a small fraction of all strings declared simple for  В)  are 
             forwarded to the next level of service where the same strategy is used, but for m 
             that is smaller by 1, and so on.  Finally the number of strings declared simple for 
             A is bounded by a sum of a sequence where each term is twice smaller than the 
             previous one, so the number of simple strings is multiplied by 2 (not a problem).
                 The ability to declare all the strings at once also has some algorithmic conse­
             quences:
                  320       Prove that for every string A of length n there exists a string X of length 
             C(A), such that C(A\ X) = O(logn), and total conditional complexity of X given 
             A (i.e., the minimal complexity of a total program that maps A to X) is O(logn). 
             Show that one cannot replace both the complexities C(A | X) and C(X \ A) by total 
             conditional complexities.
                 (Hint:  To prove the second part, one may use the existence of non-stochastic 
             strings; see Chapter 14 about algorithmic statistics.)
                 This problem shows that Muchnik’s argument gives us something non-trivial 
             even for empty B.  For non-empty В we can get a version of Muchnik’s theorem 
             where C(X\A) is replaced by total conditional complexity (and other conditional 
             complexities are understood in the usual way);  one needs to assume additionally 
             that the length of A (not only its complexity) does not exceed n.
                                 12.5.  A digression:  On-line matching
                 In  this  section  we  modify  the  combinatorial  proof of Theorem  229  to  get  a 
             stronger (and simpler) combinatorial statement.
                 Consider some bipartite graph E С A x В with left part A and right part B. 
             Given a subset A'  c  A,  one can look for a matching that selects for each vertex 
             a £ A1 some 5-neighbor in such a way that no vertices in В are selected twice.  In 
             other words, one can try to find a bijection defined on A', and this bijection should 
             be a subset of E.  One can consider an on-line version of the same task.  Assume 
             that the vertices in A are given one by one, and we need to select a neighbor for 
             the next vertex not knowing which vertices follow.
                 More formally, we say that the graph E С A x В allows on-line matching of size 
             к if there is a strategy that selects distinct neighbors for к vertices in A provided 
             sequentially by the adversary.  (The game consists of к moves:  at each move the 
             adversary select a vertex in A not used before.  In response, we have to select some 
             5-neighbor of this vertex.  We win if all the selected neighbors are different.)
