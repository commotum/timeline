                   such a ranking is inspired by Occam’s razor, which        based methodology (§II-B) [14], then the reduction of the
                   states that a smaller and simpler explanation is usu-     synthesis problem to solving of SAT/SMT constraints can
                   ally the correct one. The ranking scheme should be        be performed for a larger variety of programs.
                   consistent with the underlying version-space algebra in
                   order to retain efﬁciency, i.e., it should be based on                          IV. ARTIFACTS
                   features that are invariant of the underlying version-       There is a huge variety of artifacts that can be synthesized
                   space. The ranking can also be a function of the user-    from examples. We start out with an application in the
                   provided examples [23]; in addition, it can also take     traditional domain of algorithm synthesis (bitvector algo-
                   into account any test inputs provided by the user (i.e.,  rithms §IV-A). Then, we discuss some useful applications in
                   new additional inputs on which the user may execute a     the domain of end-user programming (spreadsheet macros
                   synthesized program).                                     §IV-B). We also discuss some surprising applications in
                Version-space algebras were pioneered by Mitchell for        the domain of intelligent tutoring systems ranging from
              reﬁnement-based learning of Boolean functions [24], while      solution generation (geometry constructions §IV-C) to prob-
              Lau et.al. [25] extended the concept to learning more          lem generation (algebraic proof problems §IV-D) to content
              complex functions in a Programming By Demonstration            entry (intellisense for drawings §IV-F and mathematical
              (PBD) setting [11], [12]. We have lifted the concepts of       expressions §IV-E).
              version-space algebra to the PBE setting for fairly expressive
              DSLs(involving conditionals and loops) for spreadsheet data    A. Bitvector Algorithms
              manipulation including syntactic string transformations [26],     Bitvector algorithms are typically straight-line sequence
              semantic string transformations [27], number transforma-       of instructions that use both arithmetic and logical bitwise
              tions [28], and table transformations [29].                    operators.1 Such programs can be quite unintuitive and
              B. Brute Force Search                                          extremely difﬁcult for average, or sometimes even expert,
                The general idea here is to systematically explore the en-   programmers to discover methodically.
              tire state space of artifacts and check the correctness of each   Consider the task of masking the right-most signiﬁcant 1-
              candidate against the given examples. This approach works      bit in an input bitvector, (e.g., converting 01100 into 01000).
              relatively well when the speciﬁcation consists of examples     A simple method to accomplish this would be to iterate
              (as opposed to a formal relational speciﬁcation) since check-  over the input bitvector starting from the rightmost end
              ing the correctness of a candidate solution against examples   until a 1 bit is found and then set it to 0. However, this
              can be done much faster than validating the correctness        algorithm is worst-case linear in the number of bits in the
              against a formal relational speciﬁcation. However, this is     input bitvector. Furthermore, it uses undesirable branching
              easier said than done and often requires innovative non-       code inside a loop. There is a non-intuitive, but quite elegant,
              trivial optimizations. Following are some instances of such    way to achieving the desired functionality in constant time
              optimizations have been inspired by paradigms from various     by using a tricky composition of the standard subtraction
              communities: goal-directed search [18] (AI community),         operator and the bitwise logical & operator, which are
              branch and bound [20], clues based on textual features of      supported by almost every architecture. In particular, the
              examples [23] (Machine Learning community), and common         desired functionality can be achieved using the following
              subexpression evaluation [19] (PL community).                  composition: x & (x − 1). Fig. 1 describes an algorithm
                                                                             for a more sophisticated problem of masking the right-
              C. Constraint Solving                                          most contiguous sequence of 1-bits. As yet another example,
                Thegeneral idea here is to reduce the synthesis problem to   consider the task of computing (the ﬂoor of) the average of
              that of solving a SAT/SMT formula and let an off-the-shelf     two 32-bit integers x and y. Note that computing average
              SAT/SMT solver efﬁciently explore the search space. This       using the expression (x+y)/2 is inherently ﬂawed and vul-
              exploits the recent advances made in the Satisﬁability (SAT)   nerable since it can overﬂow. However, using some bitwise
              and Satisﬁability Modulo Theory (SMT) solving technology       tricks, the average can be computed without overﬂowing and
              to efﬁciently explore the search space of programs.            without using conditionals; one such way to compute it is:
                This approach has been applied to synthesis from com-        (x&y)+((x⊕y)>>1)).
              plete formal speciﬁcations, but its applicability has been        [14] describes a constraint solving based (§III-C) induc-
              limited to synthesizing restricted forms of artifacts such     tive synthesizer for such bitvector programs. These programs
              as switching logics [6], program inverses [10], or pro-          1These algorithms “typically describe some plausible yet unusual op-
              grams whose correctness proof involves a given set of          eration on integers or bit strings that could easily be programmed using
              templates [3]. On the other hand, if the speciﬁcation is in    either a longish ﬁxed sequence of machine instructions or a loop, but the
              the form of examples, possibly generated using a CEGIS         same thing can be done much more cleverly using just four or three or two
                                                                             carefully chosen instructions whose interactions are not at all obvious until
              loop (§II-D) [4], [5], [20], [21] or distinguishing-input      explained or fathomed” [30].
