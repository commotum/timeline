                            control ﬂows (e.g., branching and loop) and low-level operations (e.g., which variable is the target of
                            assignment). Moreover, unlike DSLs (e.g., Karel) for which it is feasible to implement a per-line
                            interpreter, C programs need compilation and a partial C program cannot execute. On the other
                            hand, some recent works investigate natural language descriptions as the auxiliary information of the
                            programspeciﬁcation,andtheyevaluateneuralprogramsynthesismodelsonconstrainedorsimpliﬁed
                            competitive programming problems [27, 3, 23, 11, 4]. Although some of these works demonstrate
                            promising results for synthesizing Python or C code, they require manual annotations of natural
                            language speciﬁcations [27] or large-scale pre-training on human-written programs [11, 4], and the
                            performance signiﬁcantly degrades when only input-output examples are fed into the synthesizer [3].
                            Tosynthesize C programs from input-output examples only, we propose LaSynth, which generates
                            the programinarecurrentandtoken-by-tokenmanner. Astheﬁrstcontributiononmodelarchitectures
                            for program synthesis, we propose to use two latent parallel representations in the recurrent model.
                            Onerepresentationislearnedfromregularrecurrentmodelsasinautoregressivelanguagemodels[24],
                            with the double attention mechanism over IO pairs proposed in RobustFill [17] and an operation
                            predictor that models the arithmetic relationship between the program input and output. The second
                            representation, named Latent Execution Trace (LaET), models the hypothetical input signal for the
                            remaining partial program to execute to get to the desired output. Motivated by the line of work
                            on execution-guided program synthesis [47, 18, 57, 12], we learn a latent representation for C
                            programs which are not executed via interpreters, and train the model given only IO pairs without the
                            intermediate program execution states. The two parallel representations are trained end-to-end.
                            Asthesecondcontribution on dataset construction, we demonstrate that it is possible to automatically
                            construct a C codebase that is of high quality, controllable and concise through our proposed program
                            synthesis procedure. Speciﬁcally, starting from randomly generated C programs that might contain
                            a lot of redundant statements, we show that via iterative retraining, the subsequent generated code
                            from our learned model becomes more concise and similar to human-written ones. Moreover,
                            learning directly from the generated code leads to better performance given the same amount of
                            samples, and improves the sample efﬁciency. We observe similar results when applying our iterative
                            retraining technique to Karel [9], another programmingbyexamplebenchmarkconsistingofrandomly
                            generated programs. Although the initial Karel dataset includes a large proportion of complicated
                            programs with different control ﬂow constructs, we demonstrate that nearly half of the problems can
                            be solved by straight-line programs, which again conﬁrms that randomly generated programs tend
                            to be unnecessarily complicated. We envision that the iterative retraining procedure could greatly
                            reduce laborious efforts in human codebase collection in future research.
                            Asthe third contribution, we show for the ﬁrst time that short C code in a restricted domain (tens
                            of tokens, no library call) with sequential, branching, loop and simple arithmetic operations can be
                            effectively synthesized from IO pairs only. In particular, while LaSynth tends to generate more
                            concise programs (and does not have exact token match with random generated ground truth code),
                            whenmeasuringwhethertheprogramexecutionoutputsmatchtheIOpairs,LaSynthachieves55.2%
                            accuracy, and outperforms existing neural program synthesis models by around 20%. These results
                            demonstrate the effectiveness of learning latent execution traces.
                            2   Neural ProgramSynthesis from Input-Output Examples
                            In programming by example tasks, the program speciﬁcation is a set of input-output examples [17, 9].
                            Speciﬁcally, we provide the synthesizer with a set of K input-output pairs {(I(k),O(k))}K   ({IO}K
                                                                                                                   k=1
                            in short). These input-output pairs are annotated with a ground truth program P?, so that P?(I(k)) =
                            O(k) for any k ∈ {1,2,...,K}. To measure the program correctness, we include another set of held-
                            out test cases {IO}Ktest that differs from {IO}K. The goal of the program synthesizer is to predict
                                                test
                                                     K                    ?                                K          K
                            a program P from {IO} , so that P(I) = P (I) = O for any (I,O) ∈ {IO}             +{IO} test.
                                                                                                                      test
                            CProgramSynthesis. In this work, we make the ﬁrst attempt of synthesizing C code in a restricted
                            domain from input-output examples only, and we focus on programs for list processing. List
                            processing tasks have been studied in some prior works on input-output program synthesis, but
                            they synthesize programs in restricted domain-speciﬁc languages instead of full-ﬂedged popular
                            programming languages [6, 39, 38].
                            OurCcodesynthesisproblembrings new challenges for programming by example. Compared to
                            domain-speciﬁc languages, the syntax and semantics of C are much more complicated, which signiﬁ-
                            cantly enlarges the program search space. Meanwhile, learning good representations for partially
                                                                             2
