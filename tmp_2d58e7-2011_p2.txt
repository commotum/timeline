                                             User                                                  Synthesizer
                                       Input → Output        Program 1                Program 2                              Distinguishing Input ?
                                       01011 → 01000         (x+1)&(x−1)              (x+1)&x                                00000 ?
                                       00000 → 00000         −(¬x)&x                  (((x&−x)| −(x−1))&x)⊕x                 00101 ?
                                       00101 → 00100         (x+1)&x                  · · ·                                  01111 ?
                                       01111 → 00000         · · ·                    · · ·                                  00110 ?
                                       00110 → 00000         · · ·                    · · ·                                  01100 ?
                                       01100 → 00000         · · ·                    · · ·                                  01010 ?
                                       01010 → 01000         (((x −1)|x)+1)&x         None                                   Program is
                                                                                                                             (((x −1)|x)+1)&x
                                                                                                                             ((((((xx −− 1)1)||xx)) ++ 1)&1)&xx
                 Figure 1.   An illustration of the synthesizer driven interaction model [14] for synthesis of a bitvector algorithm (§IV-A) from input-output examples (for
                 the task of turning off the righmost contiguous sequence of 1 bits). Program 1 and Program 2 are two semantically different programs generated by the
                 synthesizer that are consistent with the past set of input-output pairs (in previous rows) provided by the user. The synthesizer also produces a distinguishing
                 input on which the two programs yield different results, and asks the user for the output corresponding to the distinguishing input. The process is repeated
                 until the synthesizer can ﬁnd at most one program.
                 ple input. Instead the synthesizer generates a new input in                     Guided Inductive Synthesis (CEGIS) methodology, wherein
                 each round and prompts the user for output on that input.                       examples are iteratively generated from counterexamples
                    Given a set of input-output examples, the synthesizer                        that exhibit deviation between the candidate solution and
                 searches for programs in the underlying DSL that map each                       the formal speciﬁcation. The counterexamples are generated
                 input in the given set of examples to the corresponding                         automatically using SAT/SMT based constraint solvers. This
                 output. The number of such programs may either be 0,                            methodology has been used for synthesizing a large variety
                 1, or more than 1. If the synthesizer is unable to ﬁnd                          of programs including bitvector algorithms [4], graph algo-
                 any such program over the search space, the synthesizer                         rithms [5], and vectorized code fragments [20]. It also forms
                 declares failure. If the synthesizer ﬁnds exactly 1 program,                    the basis for program synthesis by sketching [21].
                 the synthesizer declares success and presents the program to                                             III. ALGORITHMS
                 the user. If the synthesizer ﬁnds at least two (semantically
                 distinct) programs P and P , both of which map each input                          The key technical challenge in synthesis from examples
                                          1         2
                 in the given set to the corresponding output, the synthesizer                   is to map the examples to artifact(s) in the underlying DSL.
                 declares the user speciﬁcation to be partial. It then generates                 This is essentially a search problem, and can beneﬁt from
                 a distinguishing input, an input on which the two programs                      techniques developed in various communities. We present
                 P and P yield different results, and asks the user to                           below certain classes of techniques that have been frequently
                   1          2
                 provide the output corresponding to the distinguishing input.                   used in recent work on synthesis.
                 The synthesis process is then repeated after adding this                        A. Version Space Algebras
                 new input-output pair to the previous set of input-output
                 examples. This interaction model is described in [14] and is                       One class of techniques is based on the concept of
                 illustrated in Fig. 1.                                                          version-space algebras, where the key idea is to design data-
                                                                                                 structures and algorithms to succinctly represent and manip-
                 C. Randomly Selected Examples                                                   ulate the set of all artifacts that are consistent with a given
                    In certain domains, if the examples are selected uniformly                   example(s) [22]. In particular, the following ingredients are
                 at random from among the space of all valid examples, and                       required:
                 if an artifact is consistent with those selected examples, then                    • Data structure for representing consistent artifacts: The
                 the artifact is the intended artifact with high probability (over                     number of artifacts in the underlying DSL that are
                 the choice of the examples). A well-known instance of such                            consistent with a given set of examples is often huge.
                 a domain is that of polynomials and the probabilistic result                          Weneed a data structure to succinctly represent a large
                 follows from the classical result on polynomial identity                              set of such artifacts.
                 testing [15]. We have extended the identity testing result                         • Algorithm for synthesizing consistent artifacts: It in-
                 to restricted forms of linear programs [16], [17], geometric                          volves two key procedures: (i) A procedure to learn
                 constructions [18], and algebraic identities [19]. The latter                         the set of all artifacts, represented using the above
                 results have led to inductive synthesizers for respective                             data structure, that are consistent with a given single
                 domains [18], [19].                                                                   example. (ii) A procedure to intersect these sets (each
                 D. Counterexample Guided Synthesis                                                    corresponding to a different example).
                                                                                                    • Ranking:Thenumberofexamplesrequiredtoidentifya
                    Even when a complete formal speciﬁcation is available, it                          unique artifact can often be large. Hence, it is desirable
                 is often best to reduce the synthesis problem to synthesizing                         to use some form of ranking to guess the desired artifact
                 from examples. This is done by using a Counterexample                                 from a small number of examples. The effectiveness of
