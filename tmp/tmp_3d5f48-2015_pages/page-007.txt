              Table 3: Number of successful runs out of 100 for                   than either tournament selection or IFS. Additionally, there
              each setting, where“Tourn”is size 7 tournament se-                  were 8 problems where lexicase selection achieved a signiﬁ-
              lection, “IFS” is implicit ﬁtness sharing with size 7               cantly higher number of successful runs than the other two,
              tournaments, and “Lex” is lexicase selection. For                   where IFS showed signiﬁcant improvement on just one prob-
              each problem, underline indicates signiﬁcant im-                    lem and tournament selection none. These results strongly
              provement over the other two selection methods at                   indicate the utility of lexicase selection for general program
              p < 0.05 based on a pairwise chi-square test with                   synthesis problems.
              Holm correction [13], or a pairwise Fisher’s exact                    The data in Table 3 only reﬂect solutions that generalize
              test with Holm correction if any number of successes                by achieving zero error on the unseen test set. Some prob-
              is below 5 [12].      The “Size” column indicates the               lems seem to lend themselves to generalization more than
              smallest size of any simpliﬁed solution program.                    others; for example, PushGP using lexicase selection found
                                                                                  14 programs with zero error on the training set for the Su-
                Problem                         Tourn    IFS   Lex    Size        per Anagrams problem, none of which generalized to the
                Number IO                           68    72     98      5        test set. For lexicase selection, ﬁve problems resulted in 20
                Small Or Large                       3     3      5     27        or more runs that passed the training set that did not gener-
                For Loop Index                       0     0      1     21        alize (Small Or Large, Compare String Lengths, Last Index
                Compare String Lengths               3     6      7     11        of Zero, Negative To Zero, and Median), and ﬁve problems
                Double Letters                       0     0      6     20        had between 10 and 20 runs that did not generalize (String
                Collatz Numbers                      0     0      0               Lengths Backwards, Mirror Image, Digits, Smallest, and Su-
                Replace Space with Newline           8    16     51      9        per Anagrams). These 10 problems show an important area
                String Diﬀerences                    0     0      0               for future study: how to evolve programs that generalize to
                Even Squares                         0     0      2     37        unseendataforgeneralprogramsynthesisproblems. Among
                Wallis Pi                            0     0      0               these problems are the only ﬁve in the suite that give a cor-
                String Lengths Backwards             7    10     66      9        rect/incorrect binary error as ﬁtness in our implementation:
                Last Index of Zero                   8     4     21      5        Compare String Lengths, Mirror Image, Super Anagrams,
                Vector Average                      14    13     16      7        Median, and Smallest. This shows the diﬃculty of evolving
                Count Odds                           0     0      8      7        general programs based entirely on correctness of output,
                Mirror Image                        46    64     78      4        and suggests that these problems might be better tackled if
                Super Anagrams                       0     0      0               they can be transformed into problems with more informa-
                Sum of Squares                       2     0      6      7        tive error functions.
                Vectors Summed                       0     0      1     11          Withregards to the problems themselves, this experiment
                X-Word Lines                         0     0      8     15        illustrates the ability of this benchmark suite to provide use-
                Pig Latin                            0     0      0               ful comparisons between multiple systems or parameter set-
                Negative To Zero                    10     8     45      8        tings. By looking at the number of problems solved by each
                Scrabble Score                       0     0      2     14        technique, and how often each technique showed signiﬁcant
                Word Stats                           0     0      0               improvements over the others, we can clearly see that lex-
                Checksum                             0     0      0               icase selection increases PushGP’s ability to solve general
                Digits                               0     1      7     20        program synthesis problems compared to tournament selec-
                Grade                                0     0      4     52        tion and IFS. The main goal of a benchmark suite is to sup-
                Median                               7    43     45     10        port this type of experiment. Additionally, some problems
                Smallest                            75    98     81      8        in the suite were solved frequently by each system, whereas
                Syllables                            1     7     18     14        others were solved infrequently or not at all. This range
                                                                                  of diﬃculties permits the suite to be useful for a variety of
                Problems Solved                     13    13     22               experiments, and allows it to remain relevant as program
                                                                                  synthesis systems improve.
                                                                                    Of the seven problems on which PushGP found no gener-
              fraction of the population, and gives less reward for solving       alizing solution, most are not surprising in that they involve
              cases that are solved by more of the population. Most of the        extensive use of multiple programming constructs, the link-
              problems here produce non-binary error values, for which we         ing of many distinct steps, or a deceptive ﬁtness space where
              use the non-binary adaptation of IFS found in [8]. As re-           ﬁtness improvements do not lead toward perfect programs.
              quired by this method, we normalize error values to [0,1]           Wehave written solutions to each of the unsolved problems
              by dividing each error by a maximum allowed error value,            by hand to ensure that each problem is solvable within the
              which diﬀers per problem based on the ﬁtness function.              constraints we put on the system and instruction set.
                 Lexicase selection [5], unlike tournament selection and            The last column in Table 3 gives the size (in instructions)
              IFS, does not base selection on a single ﬁtness value. In-          of the smallest simpliﬁed solution program. Here, we’ve used
              stead, it uses a random ordering of the training set to select      post-run simpliﬁcation to automatically reduce the sizes of
              individuals that perform as well as possible on a subset of         solution programs without changing their semantics on the
              the cases even if they exhibit poor performance on other            training data [14]. While this hill-climbing simpliﬁcation is
              cases.  Lexicase selection has been shown to improve the            not guaranteed to ﬁnd the smallest semantically equivalent
              performance of a GP system on a variety of problems [5, 3].         program, it reliably removes excess code, leaving the core
                 Table 3 gives the results of our parent selection experi-        functionality of the program [14]. The simpliﬁed program
              ment. Overthe29problems, PushGPwithlexicaseselection                sizes present a reasonable proxy for the smallest solution pro-
              produced at least one successful run on nine more problems          gram for each problem (using our instruction sets). While
