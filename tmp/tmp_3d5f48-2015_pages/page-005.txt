              two integers and returns a boolean would be included if the      X-Word Lines problem when using Levenshtein distance as
              problemcouldpotentiallymakeuseofintegersandbooleans.             the only ﬁtness function, but found solutions when adding
              By specifying only the data type requirements for a prob-        additional ﬁtness functions for the number of newline char-
              lem, we can limit the number of instructions without cherry      acters and summed errors of diﬀerences in number of words
              picking.                                                         compared. When using multiple ﬁtness values for a single
                                                                               training case, we treat each ﬁtness value separately when the
              6.   SYSTEM-SPECIFCPARAMETERS                                    parent selection method requires it; in tournament selection,
                                                                               we simply sum all ﬁtness values.
                WhereasSection5gavetechnique-independentrecommen-                As discussed in Section 5, we have chosen to specify the
              dations for specifying the benchmark problems for a syn-         data types relevant to each problem, and then include all
              thesis system, this section will give more detail about the      instructions that use those data types in each problem’s in-
              system-speciﬁc parameters and decisions that must be made        struction set. Table 2 presents the Push data types we chose
              in order to implement these problems in a given program          for each problem. The “exec” column signiﬁes instructions
              synthesis system. Here we will focus on our implementation       that use Push’s exec stack, which typically perform control
              in the PushGP genetic programming system, but we empha-          ﬂow manipulations such as conditionals, iteration, and sub-
              size that this is just one possible approach and one possible    functions deﬁned through tagging [15]. The “print” column
              implementation, and that the problems here could be used         includes instructions that print data to standard output, and
              in any system that meets the requirements in Section 3.          “ﬁle input”includes a small set of ﬁle reading instructions.
                PushGP evolves programs in Push, a stack-based pro-              Table 2 also gives the terminals used for each problem,
              gramming language designed speciﬁcally for GP [16]. The          whichencompassconstantsandephemeralrandomconstants
              reference implementation of our problems in PushGP can           (ERCs). ERCs allow for the creation of random constants
                                   3
              be found on GitHub . In the rest of this section, we will        in randomly generated code during initialization and muta-
              describe some of the major decisions necessary for imple-        tion. We used problem-speciﬁc ERC ranges, which can be
              menting these benchmark problems in this environment. As         found in the technical report [4].
              we do not have space to discuss every parameter and imple-         WekeepmostofourPushGPsystemparametersconstant
              mentation choice, the technical report accompanying this         across all problems, with speciﬁc details in [4]. The only sig-
              paper supplements the information presented here [4].            niﬁcant parameters that we vary per problem are the max-
                Whengenerating training and testing data, we use a com-        imum program size, the maximum number of instruction
              bination of hand-picked edge cases that remain constant          evaluations that a program may use per execution, and the
              across runs and randomly generated inputs that vary across       maximum number of generations per run. We used a maxi-
              runs. For each problem, we specify one or more “data do-         mumof 300 generations for every problem besides Number
              mains” [3], which consist of either a set of hard-coded in-      IO, Median, and Smallest, for which we used 200 genera-
              puts or a random input generator, as well as the number of       tions. Maximum program sizes varied from 200 to 1000 in-
              training and test cases that should come from each domain.       structions depending on anticipated problem diﬃculty. We
              Details on using data domains can be found in [3], and our       limited instruction executions to approximately 2 to 5 times
              technical report gives our choices for data domains for each     the maximum program size, though for some problems that
              problem [4].                                                     require many loops we increased this limit. By specifying
                When using this benchmark suite with GP, we not only           the maximum generations, the population size (1000 for all
              need the input/output cases, but also a method of measur-        of our runs), and the size of the training set (see Table 1),
              ing how well a particular program performs on each case—         we also specify the program evaluation budget, which is the
              the ﬁtness function. Many of the problems in this suite print    product of those values. In our implementation, this budget
              results to standard output, and we generally treat these out-    falls between 5 and 60 million program evaluations per run
              puts as strings and use Levenshtein distance (a measure of       for every problem.
              string edit distance) as the ﬁtness function. Other prob-
              lems produce numeric outputs, either returned or printed;        7.   EXPERIMENTALRESULTS
              for these problems we use absolute error for ﬁtness, pars-
              ing printed numbers when necessary and possible. Some              Whereastherelevance of a benchmark suite is determined
              problems produce boolean values, or are best measured by         by how well its problems reﬂect potential applications of the
              a simple binary right or wrong; here, we use a ﬁtness of 0       test systems, its utility is based on how well it diﬀerentiates
              for right and 1 for wrong. Finally, some problems require        between diﬀerent approaches. We aim to include problems
              problem-tailored ﬁtness functions, such as vector edit dis-      with a large range of diﬃculties, from those that can be
              tance or string formatting requirements. We give the details     solved reliably to those that extend beyond the abilities of
              of each ﬁtness function in [4].                                  current program synthesis systems. More importantly, we
                For some problems we found it appropriate to use multi-        hope to include problems that are solved more often with
              ple ﬁtness functions per test case. For example, the Replace     some systems or settings than others, allowing us to com-
              Space With Newline problem requires both a printed string        pare their performances on these problems. In this section
              and a returned integer. For problems like this, we produce       we present a simple experiment showing the utility of the
              multiple ﬁtness values for a single case. Additionally, we       benchmark suite presented here. This experiment compares
              ﬁnd that PushGP performs better on some problems when            three parent selection algorithms: tournament selection, im-
              we use more than one ﬁtness value per case, even where not       plicit ﬁtness sharing, and lexicase selection.
              strictly necessary. For example, we found no solutions to the      Implicit ﬁtness sharing (IFS) is a modiﬁcation of tourna-
                                                                               ment selection designed to encourage diversity preservation
              3http://thelmuth.github.io/GECCO 2015 Benchmarks                 in the population [10]. IFS selection greatly rewards indi-
              Materials/                                                       viduals for solving training cases that are solved by a small
