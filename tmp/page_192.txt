Symbolic Processing for Intelligence = 179

not having a state in which an operator applies, and not having a
generalized operator instantiated to the present situation—all
should lead to no-change impasses on the operator. On the other
hand, a no-change impasse on the state produces subgoals to find or
construct an operator, because no operator at all was proposed.
And so it goes. Any lack of knowledge that prohibits the situation
from moving forward leads to some kind of an impasse and hence a
subgoal to resolve that impasse.

The internal subgoals determine what Soar will do once it starts
to pursue something. It then has an end, and any lack of knowledge
in attaining that end leads (via impasses) to attempts to obtain that
knowledge. But this decision cycle doesn't account for why Soar
wants to stack blocks in the first place, or play chess, or whatever.
Further, it does not account for how Soar represents to itself such
wants. In Soar, deliberate goals take the form of operators, which
are defined by whatever combination of partial procedural and end-
state specification is available at the time the operator is created.
Thus, the goal to stack the blocks in a particular configuration is, in
the first instance, an operator to stack them. Such an incompletely
determined operator produces a no-change impasse, which gener-
ates the subgoal that leads to selecting a problem space in which to
solve the problem. Indeed, whether stacking the blocks is in fact a
problem or is something that Soar can just do (an immediately
performable operator) is not intrinsic to the task to be accom-
plished, but is determined in terms of what is known right at the
moment of the attempt to stack the blocks.®

Some additional insight into the Soar architecture can be gained
by contrasting Soar with standard computers. Impasses also occur
in standard computers. For instance, dividing by zero produces an
impasse. However, if division by zero occurs, who knows what’s
wrong? There is no way that the architecture can respond to this
impasse, other than to produce an error message and then abandon
ship. That is because a computer architecture has no relationship to
what is being computed. Its operation-operand structure relates it

6. Al systems have typically made a basic structural distinction between operators
and goals, which has long needed clarification. Pragmatically. it has simply been the
designer's decision to cast some aspects as given and some as to-be-sought. But this is
clearly unsatisfactory. The solution offered by Soar seems fundamentally satisfying
Operators and deliberate goals are the same thing: operationally, goals arise from a lack
of knowledge at the moment when that knowledge is needed.

ge
