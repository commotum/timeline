                         4.4.  A  DIGRESSION:  MACHINES  WITH  SELF-DELIMITING  INPUT          89
                 Assume that  f(x) — y and  all the bits of x are entered  (with some delays). 
             We have to prove that r outputs y and halts whatever the delays are.  Indeed, at a 
             certain time, r knows that f(x) = y and all the bits of x have been entered.  At that 
             time the program outputs y and halts unless it has been halted earlier.  The latter 
             indeed can happen:  the program can halt earlier with the result f(x') where x' is 
             some string compatible with x.  However, since /  is assumed to be prefix stable, we 
             have f(x') — y and the output is the same.
                 If f(x) is undefined and /  is prefix stable, then f(x') is undefined for all prefixes 
             x' of x, and hence the program does not terminate.                                □
                 This theorem provides a motivation for the notion of a prefix-stable function. 
                  96 Construct an algorithm transforming every program p that uses NextBit
             and NextExists calls into a robust program p1  that computes the same function 
             as p does, if p is robust  (and computes some prefix-stable function if p is not). 
                 (Hint:  Use the construction from the proof of Theorem 51 back and forth.)
                  97 (Continued)  Prove that  there exists no  algorithm that  for  a given pro-
            gram p decides whether p is robust or not.
                 (Hint:  This can be done in a standard way, by reducing the halting problem. 
             See, e.g.,  [184].)
                 4.4.3.      Continuous  computable  mappings.  There  is  another,  more  ab­
            stract,  motivation  for  the  notion  of a  prefix-stable  function.  It  goes  back  to  a 
            general theory of computable functionals of higher type, but we restrict our atten­
            tion to a special case we are interested in.  (See [176] for a more general approach.)
                 Let E denote the set of all finite and infinite binary sequences:  E = Sufi.  For 
            a finite string x let Ex denote the set of all finite and infinite extensions of x.  We 
            will consider E as a partially ordered set:  x ^ y if x is a prefix of y.
                 Consider a topology on E whose base consists of all sets of the form E^.  This 
            means that a set is open if it is a union of some sets of this form.  It is easy to verify 
            that we indeed get a topology.  (Note that the resulting topological space does not 
            satisfy the separation axiom.)
                 The following statement is almost obvious:
                 Theorem  52.  A  set A  С  E  is  open  if and  only  if it  satisfies  the following 
             conditions:
                 (1)  if a finite  string x  is  in A.  then  all finite  and infinite  extensions  of x  are 
             in A;
                 (2)  if an infinite sequence is in A,  then some of its finite prefixes are in A.
                 Proof.  Every union of base sets satisfies the conditions  (1)  and  (2).  Con­
            versely, if a set A satisfies both conditions, then it is equal to the union of E^ over 
            all finite strings x in A.                                                         □
                 Add to the natural numbers a new element _L (“undefined”), and let Nj_ denote 
            the resulting set.  Consider the following partial order on this set:  the element _L is 
            less than all natural numbers, and all the natural numbers are pairwise incompa­
            rable (Figure 11).
                 Consider the following topology on the set N U {_!_}.  A set is open if it either 
            does not include the element _L or it coincides with N U {_L}.  It is easy to verify 
            that we get a topological space (that does not satisfy the separation axiom either).
