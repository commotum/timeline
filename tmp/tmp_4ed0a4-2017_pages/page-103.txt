                                        4.  A  PRIORI  PROBABILITY  AND  PREFIX  COMPLEXITY
                 88
                       To be more specific, we assume that the program may use the instruction
                                                                b := NextExists
                 to find out whether the queue is non-empty.  To read a new input bit the program 
                 invokes the instruction
                                                                  b := NextBit.
                 This instruction removes the first (the oldest) bit from the queue and assigns it to 
                 the variable b.
                       One should specify what happens if the instruction NextBit is performed when 
                 the queue is empty.  We may agree that this causes a crash, or that the computation 
                 is delayed until the next bit arrives.  It is not essential which of these two options 
                 is chosen, since we may guard the input statement by a waiting loop: 
                        while not NextExists do {nothing}; 
                        b     NextBit
                       The advantage of a non-blocking read operation is that we can do some useful 
                 work while waiting for the next input bit.  On the other hand, it is not clear now 
                 how to define a function computed by a program, since the output of the program 
                 may depend not only on the input string, but also on timing.
                       We call a program robust if this is not the case (i.e., if the output is determined 
                 by the input string and does not depend on timing).  If the program is robust, for 
                 any input string x there are two possibilities:  (1)  the program does not produce 
                 output for  any delays  between the consecutive bits  of x;  or  (2)  for some y,  the 
                 program outputs y whatever delays happen between the consecutive bits of x.
                       In  this  way  every  robust  program  computes  a function  /   such  that  /(x)  is 
                 undefined in the first case and equals y in the second case.
                       Theorem  51.  (a)  The function  computed  by  a  robust program, is  both  com­
                 putable and prefix stable.
                       (b)         For every  computable prefix-stable function  there  exists  a robust program 
                 that computes it.
                       Proof,  (a)  The computability of /  is straightforward:  to compute /(x),  we 
                 start our robust program and enter all the bits of x (with arbitrary delays).  Then 
                 we wait until the program outputs a result, which by assumption is equal to /(x) 
                 if /  is defined on x and does not exist otherwise.
                       Let us prove that /  is prefix stable.  We have to show (recall the definition from 
                 Section 4.3) that if a robust program produces y for some input x, then it produces 
                 y on every input x' that is an extension of x.  Start the program and enter all the 
                 bits of x  (with arbitrary delays).  By assumption the program produces y and then 
                 halts.  After that, input all the remaining bits of x'  (the difference between x' and 
                 x)  with  arbitrary delays.  Obviously,  these extra bits do not  affect the output of 
                 the program.  Thus the program produces output y for input x' at least for some 
                 timing.  Being robust, it does the same for arbitrary timing.
                       (b) Let /  be a computable prefix-stable function /.  The robust program r that 
                 computes / works as follows:
                       Using a (non-robust) algorithm that computes /, program r computes in par­
                 allel /(x) for all inputs x.  At the same time r reads all available input bits.  Doing 
                 this,  r  looks for strings x and y such that f(x) = y and x is a prefix of the input 
                 sequence.  Once such a pair (x, y)  is found, program r outputs y and halts.
