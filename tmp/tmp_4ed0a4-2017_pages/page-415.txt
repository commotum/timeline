            406                        13.  INFORMATION  AND  LOGIC
            program lT that computes r.  We say that a pair (u,v) £ S x S is compatible with 
            p if \р]{1т) = и for all t: S' —> S such that t(u) — v.  By assumption, the pair (x, y) 
            is compatible with p.  Given p and n, we can enumerate all pairs compatible with 
            p.  We claim that the first component и of the first (in fact, every) compatible pair 
            (u,v)  is  equal to x.  (So we can find x given p and n,  as we promised.)  Indeed, 
            assume that u/i.  There exists a function т such that т(х) = у and t(u) — v. 
            Then p should produce both и and x for the input lT, a contradiction.           □
                A careful reader might notice that this argument is not entirely complete.  We 
            have used  implicitly  that  for  any  given  finite  function  т  (presented  as  the  table 
            of its  values)  one  may  effectively  find  its  program  lT.  This  is  a corollary of our 
            assumption about programming language (the list of values can be considered as a 
            program in some other language, and that program can be effectively translated to 
            our language).
                Note also that we could restrict ourselves to a smaller class of functions (e.g., 
            linear functions ax + b if S is enriched with a field structure).  We only need that 
            for every two different points, and for every two prescribed values in these points, 
            there is a function in the class that has the required values in those points.
                 341 Prove that  in  the  statement  of the  previous  theorem  we  can  replace
            O(logn) by 0(\ogk), where к — max(C (x), С (y)).
                (Hint:  Consider the shortest programs for x and у instead of x and у them­
            selves.  Then S can be replaced by the set of all strings of length at most k.  The 
            program lT works as follows:  for input и it searches for the first program p of length 
            at most к that produces u, applies т to p, and then decompresses the result.)
                This theorem, together with the inequality
                               C(Y) < C(X) + C(X —► Y) + 0(logC(X)),
            implies that C(x) < C((x —> y) —> x) + O(logn) for all strings x and у of length at 
            most n (and hence, C((x —> y) —> x) — C(x) + O(logn), as the reverse inequality 
            is trivial).
                It  is worth noting that there exist formulas A(p,q)  and B(p,q) such that the 
            complexity of B(x,y) never exceeds significantly the complexity of A(x,y)  (for all 
            strings x and y), but the implication A(x, y) —> B(x, y) has rather high complexity.
                An example of this kind is a pair of formulas  (x —> у)  —> у and x V y.  (By 
            the way,  they are classically equivalent.)  As we will show,  their complexities can 
            differ  at  most  by  O(logn)  for  n-bit  strings,  but  the  complexity  of the  problem 
            ((x —У у) —У у) —ï {x V y) could be as high as n.
                To show this, consider first the problem (x —> y) —> y.
                Theorem  240.  The complexity of the problem (x —>• y)  —»■  y  is equal to the 
            complexity of the problem х\/ y (up to О (log n)-additive terms, for strings x and у 
            of length at most n).
                (Recall that the complexity of x V у is min(C'(a:), C(y)) + 0(1).)
                Proof.  To prove this, we present  (1)  an algorithm that transforms every so­
            lution to ж V у into some solution to (x —> у) —> у, and (2) an algorithm that gets a 
            solution to (x —> у) —> у and O(logn)  bits of additional information and produces 
            some solution to x V y.
