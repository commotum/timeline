                  80                      4.  A  PRIORI  PROBABILITY  AND  PREFIX  COMPLEXITY
                        Theorem 47.  There exists a maximal lower semicomputable semimeasure on N.|
                        Proof.  We have to construct a probabilistic machine M with the following 
                  property.  The machine M should output every number i with a probability that is 
                  at most a constant times less than the similar probability for each other machine 
                  M' (the constant may depend on M' but not on i).
                        This is easy to achieve:  consider a machine M that picks at random a proba­
                  bilistic machine M' and then simulates M'.  The probability of picking each machine 
                  M' should be positive.  If a machine M' is chosen with probability p, then M will 
                 output some i with probability at least p • (the probability that M' outputs i).  Thus 
                 one can let c = l/p.
                        It  remains to explain how to implement the random choice of a probabilistic 
                 machine.  Enumerate all probabilistic machines in a natural way; let Mo, M\, М2,... 
                 be the resulting sequence.  We toss a coin until the first 1 appears.  Then we simulate 
                 the machine Mj where i is the number of zeros preceding the first 1.                                                         □
                        It  is  instructive to prove this theorem once more using the language of lower 
                 semicomputable sequences instead of probabilistic algorithms.  Basically, we need to 
                 show that there exists a convergent lower semicomputable series that upper-bounds 
                 all other lower semicomputable convergent series (up to a multiplicative constant). 
                 More formally, we should consider only series with the sum at most 1, but this is 
                 not essential since we ignore constant factors.
                        To find such a series, we sum up with certain weights all the lower semicom­
                 putable series with sum at  most  1.  The weights  form  a computable converging 
                 series.  This implies that the resulting series (infinite linear combination) converges. 
                 By construction it will be maximal (up to a multiplicative constant).  There is only 
                 one problem left:  How do we guarantee that the resulting series is lower semicom­
                 putable?
                       The lower semicomputability of a semimeasure is witnessed by a computable 
                 function p :  (i,n)  ^  p(i,n).  There are only countably many such functions, since 
                 there are only countably many algorithms.  Enumerating all those functions, we get 
                 a sequence p^°\p^\p^2\ ...; then we may consider the function
                                                                              71
                                                              p{i,n) = ^ A fcp(fc)(i,n), 
                                                                            k=0
                 where  A*,  is  a  computable  sequence  of rational  numbers  with  ^2k\k  ^  1,  say, 
                 Afc  = 2~k~l.  The resulting function p is non-decreasing in n for every i.  Indeed, as 
                 n increases, the number of terms in the sum defining p increases and the value of 
                 every term increases, too.  And for all i we have
                                                       lim  p(i,n) = V  Afc  lim  p^k\i,n).
                                                     Tl—ïOO                Z —V      71—>00
                                                                             к
                 That is, the constructed semimeasure is indeed equal to the sum of all lower semi­
                 computable semimeasures with weights \ k.
                       However, there is a fault in this argument:  the function p(i, n) should be com­
                 putable,  and thus we cannot use arbitrary enumeration of lower semicomputable 
                 functions  in  our  construction.  We  need  to  arrange  them  so  that  the  function 
                 p  :  (k,i,n)  i—^  p(k^(i,n)  is  computable  as  a  function  of all  its  three  arguments. 
                 Note that we cannot just let p ^  be the function computed by /eth program:  it may
