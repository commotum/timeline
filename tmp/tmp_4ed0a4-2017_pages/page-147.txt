                                                                  5.5.   MONOTONE COMPLEXITY                                                              133
                           Theorem 86.  The difference between C(x) and KM(x) is bounded by O(logn) 
                    for strings  of length n  and may be  both positive  and negative  with  absolute  value 
                    logn — 0 (1) for n-bit strings for infinitely many n.
                           We return to the comparison of different versions of complexity in Chapter 6. 
                    Now we provide only one statement of this type:
                           Theorem 87.  The difference KM(x)—KA (x) is not bounded from above; more­
                    over, for infinitely many n there exists an n-bit string x for which this difference is 
                    at least log logn — О (log log logn).
                           This theorem (proved by Day [48]) strengthens an old result by Gåcs [57] that 
                    established a weaker lower bound for the difference KM(x) — К A (x).  Both papers 
                    use a reduction to a game, for which a strategy for one of the players is constructed.
                           Recall  that  in  both  definitions  (of  KM(x)  and  К A (x))  we  use  computable 
                    continuous  mapping  /:  E  —>■  E  and  consider  the  preimage  of the  set  Ex  of all 
                    sequences starting with x.  Defining К A, we are interested in the measure of this 
                    preimage, while for KM we are looking for the largest interval of type Ey which is 
                    a subset of this preimage.  This shows that К A                                      KMf, and the difference can be
                    large, if the preimage is sparse (if it consists of large number of small intervals).  The 
                    question is how large this difference could be for an optimal computable mapping.
                           We have seen a similar situation before.  Recall our metaphor of space alloca­
                    tion (we allocate subsets of [0,1] for countably many clients) used in the proofs of 
                    Theorem 46 (p. 78) and Theorem 58 (p. 93).  The difference between prefix com­
                    plexity and the logarithm of the a priori probability on N has the same nature (the 
                    difference between the total measure and the maximal contiguous interval).  How­
                    ever, in that case we were able to perform some kind of consolidation by modifying 
                    the description mode, and the price was just a constant factor.
                           Now we have a more delicate task since our clients form a hierarchy.  This makes 
                    reorganization  more  difficult  and  consolidation  leads  to  more  than  the  constant 
                    factor overhead.
                           5.5.1.  The proof of Gåcs—Day theorem.  This is probably the most diffi­
                    cult argument in the entire book (though we tried hard to simplify the arguments 
                    from original papers of Gåcs and Day), and it is not used in the rest of the book, 
                    so feel free to skip it if it looks too difficult.
                           We start  by describing some  game.  The  two  players  are  called  Client  and 
                    Server.  The game has two parameters:  a rooted tree and some rational  d  ^  1. 
                    At each moment of the game the vertices of the tree are labeled by non-negative 
                    rational numbers;  the label of vertex x is called the request of this vertex (at the 
                    given moment).  The request of each vertex is at least the sum of requests of its 
                    sons, and the request of the tree root is at most 1 jd.
                           Requests are chosen by Client.  Server tries to serve these requests by allocating 
                    space in Cl.  At each moment of the game Server allocates some subset of Cl for each 
                    vertex.  This subset should be a union of finitely many intervals (=sets Г2Х).  A set 
                    allocated for each vertex x should contain the sets allocated to the sons of x, and 
                    the sets allocated to brothers should be disjoint.  This implies that sets allocated 
                    to incomparable vertices (one is not a descendant of the other) are disjoint.
                           The players  alternate.  Initially the requests  of all  vertices  are  zeros  and  all 
                    the allocated subsets are empty.  At every move,  Client may increase requests for 
                    some (or all) vertices but should not violate the restrictions stated above (otherwise
