                             13.3.  SOME  FORMULAS  AND THEIR COMPLEXITY              407
               The first algorithm gets [0, x] or [1 ,y\ and should produce a program that maps 
            every solution to (x —>■ y) to y.  If the input is [1, y], we generate the program that 
            outputs y (without even reading its input).  If the input is  [0,x], we produce the 
            following program:  apply the solution to (x —>■ y) (given as input) to x, and output 
            the result y.
               The second algorithm is more interesting.  Given a solution to  (x —> y)  —>■ y, 
            a number n  (an upper bound for lengths of x and y),  and one additional bit of 
            information (see below), the algorithm outputs some solution to x V y.
               Let p be a given solution to (x —> y) -A y.  Let S stand for the set of all strings 
            of length at most n.  For every function r : S —> S, we can effectively find a program 
            Ij-  that computes r.  This time we say that a pair (u,v) £ S x S is compatible with 
           p if \p](lT) = v for all r such that t(u) = v.
               By definition, the pair (x, y) is compatible with p.  However, other pairs could 
            be compatible with p also.  The main point is that for every two compatible pairs 
            {u'jv')  and  (u,,,v"),  we  have  either  u'  =  u"  or  v'  —  v".  Indeed,  assume  that 
           и' Ф u".  Then there exists a function r such that t{u') = v' and r(u") — v".  By 
           definition p(lT) should be equal both to v' and v".  So v' = v" unless u' — u".
               Knowing p and n, we can enumerate all pairs compatible with p.  Consider the 
           first pair in this enumeration.  As we have shown, either и = x or v — y, but we do 
           not know which of these two cases happens.  This is why we need an additional bit: 
           we output и or v depending on the value of that bit.                        □
               This argument can be generalized to prove the following statement:
               Theorem 241.  The complexity of the problem (x —»• y)  -a  z  (with O(logn)- 
           precision for strings x, y, z of length at most n) coincides with the complexity of the 
           problem z V (x Л (y —> z)).
               As we have seen in Problem 335, the complexity of the latter problem is equal 
           to min(C(,z), C(x) + C(z |x, y)).
               PROOF.  It is enough to provide two algorithms.  The first one converts every 
           solution  for  the  second  problem  into  a solution  for  the  first  problem.  The  sec­
           ond algorithm gets a solution to the first problem  and additional 0(\ogn)-bits of 
           information, and it produces a solution to the second problem.
               We start with the first algorithm.  By definition a solution to the first problem 
           is  a  program  that  maps  every  solution  for  x  —>  у  to  z.  And  a solution  for  the 
           second problem, which is given to the algorithm, is either z or a pair (x, program 
           that converts у to z).  If it is z, we produce a program that maps everything to z. 
           And if it is x and a program p that converts у to z, then we output the following 
           program that is a solution to the first problem:  apply the given solution for x —> у 
           to x and get у; then apply p to у and get z; output z.
               The second algorithm gets a solution to the first problem, the number n and 
           one auxiliary bit of advice, and produces a solution to the second problem.
               Let p denote the given solution to  (x -A y) —> z.  Let  S stand for the set of 
           strings of length at most n.  For every function r : S —>■ S, we fix some program lT 
           that computes that function.  We say that a triple (u,v,w) £ Sx S xS is compatible 
           with p if \p](lT) = w for all r such that t(u) = v.
               By definition the triple  (x, y, z)  is compatible with p.  Given p and n, we can 
           enumerate all compatible triples; let (u,v,w) be the first triple in the order of this 
           enumeration.
