         254                 8.  SOME  APPLICATIONS
               the values  of used random bits can be reconstructed if we know 
               (1)  the  current  values  of all  the  variables  of the  CNF;  (2)  the 
               list  of clauses for which the procedure Fix (d)  was  called,  in the 
               order of calls.
           Indeed, the call Fix(d) is performed only when d is false, and this determines 
        the values of variables in d before the call.  And their values after the call are just 
        the next random bits.  Unrolling the execution backwards, we can reconstruct the 
        values of variables between the calls and finally n initial values, so we know all the 
        random bits used.
           Now the idea of the proof can be explained as follows.  If the algorithm makes a 
        lot of calls, then we can compress the values of random bits used by the algorithm, 
        because the list of clauses for which Fix was called has a shorter description.  To 
        finalize the proof,  we should estimate the complexity of this list.  Here it is very 
        important that Fix(d) calls Fix(d') only for those d! that are neighbors of d, and 
        these d'  can be specified by their ordinal number in the list of neighbors.2  (Here 
        we use the bound for the number of neighbors.)
           Now let us compare the number of random bits used and the number of bits 
        needed to describe them  (as explained in the previous paragraph).  Consider the 
        situation after к calls of Fix.  At that time the algorithm has used n + km random 
        bits.  To reconstruct them, we need to know the following:
             •  the current values of the variables;
             •  for which clauses the procedure Fix was called in the main loop;
             •  which recursive calls of Fix were made during each of those calls.
           Current  values are n bits;  the list  of clauses called  in  the  main  loop can be
        described by N bits (for each clause we say whether it was processed or not;  the 
        order  of clauses  is  fixed,  so  N  bits  are  enough).  To  estimate  the  complexity  of 
        the third component, let us consider trees of recursive calls.  For example, the tree 
        illustrated  in  Figure  26  starts with a call  Fix (a).  This  call generates three calls 
        for  b, c, d;  the  call  for  b generates calls for e, f, g,  the call for  c does not  generate 
        anything, and the call for d generates only one call for h.  The chronological order 
        of all the calls is a, b, e, f, g, c, d, h  (the left to right ordering of the sons of a vertex 
        corresponds to the order of calls).  Indeed, we call c only after we return from 6-call 
        (that  generated  calls  for  e,f,g),  and  then  make  d-call  that  generates  /г-call.  In 
        other words, the order of calls can be described as follows:  imagine that our picture 
        is a bird’s view of a wall; we start walking around it from a and always touch the 
        wall by the right hand.  The we visit the vertices in the order
                         a-b-e-b-f-b-g-b-a-c--a-d~h~d-a,
        and this corresponds to the control flow during the execution.  New random bits 
        are used when we come to some vertex for the first time (from below).
           So to specify the processed clauses  (and the order of processing)  it is enough 
        to  encode  the  tree  walk.  It  consists  of steps  up  and  down.  For  a step  up,  we 
        need to specify not only the fact that we are going up but also the number of the 
        neighbor where we are going.  In total we use 1 + logt bits (one for the direction, 
        and one for the number).  Here t is the upper bound for the number of neighbors,
           2So (as we have mentioned)  it is a bit surprising that the result is true for other rules that 
        select the next clause for resampling.  (We want to stress that the argument we provide depends 
        on the choice of the rule, though the result does not.)
