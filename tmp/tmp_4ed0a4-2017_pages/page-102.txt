                         4.4.  A  DIGRESSION:  MACHINES  WITH  SELF-DELIMITING  INPUT          87
             computing / in the usual sense.  We simulate in parallel its computations on all 
             possible inputs.  Sometimes we will interrupt the simulation and scan a new symbol 
             from  the  input  tape.  More  specifically,  when  a  new  pair  (x,y)  with  f(x)  =  y 
             appears, we compare x with the already scanned part r of the input tape.  If r is 
             not a prefix of x,  then we do nothing and wait until the next pair (x, y)  appears. 
             If r coincides with x, we output y and halt.  Otherwise r is a proper prefix of x.  In 
             this case we read the input tape until we find the first bit where x differs from the 
             contents of the input tape, or we find out that the input tape starts with x.  In the 
             latter case we output y and halt.  In the former case we return to the simulation 
             process and continue it until the next pair (x, y)  appears.
                 How does M start its work?  Initially the scanned part of the input tape is 
             empty.  Once the first pair (x, y)  appears, we look at whether x is empty or not.  If 
             x is empty, we print y and halt.  Otherwise we scan the input tape until we read x 
             or find the first bit where x differs from the contents of the input tape (finding out 
             that x  is not  a prefix of the input).  In the first case we print y and halt.  In the 
            second case we wait for the next pair (x,y).
                 Formally speaking, we maintain the following invariant relation:  after process­
             ing each pair, if r is the scanned part of the input tape, then either:
                 (1)  f(r)  is defined and the machine halts with the output f(r); or
                 (2) r is not a prefix of x for all pairs (x, y) that have appeared so far, but every 
            proper prefix r' of r is a proper prefix of one of such x’s.
                 (A proper prefix of a string is its prefix that is different from the string itself.)
                 It  is  easy to verify that this invariant relation implies that /  = 7m-  We skip 
            this verification and explain informally the main idea of the construction:  if the 
            scanned part r of the input is a proper prefix of a string in the domain of /, then 
            f ( r )   is undefined,  and we can safely read the next bit of the input.         □
                 An equivalent model can be defined in more “practical” terms.  Consider com­
            puter programs that have instructions of the form
                                                b := NextBit.
            Executing this instruction, the program shows on the screen a prompt like  “Enter 
            the next bit”  and waits until the user hits one of the keys  “0”  or  “1”.  After she 
            does this, the input bit is recorded in b and the computation resumes.
                 One can assign a computable function /  to every program of this type.  Namely, 
            f(x)  equals  to  y  if the  program  prints  y  provided  the  user  enters  the  bits  of x 
            successively in response to the program’s prompts.  If the program prints the result 
            before the user enters all the bits of x or if it asks for a new bit after all the bits of 
            x are entered, then f(x) is undefined.
                 It  is easy to modify the arguments above to prove that programs of this type 
            compute all the prefix-free functions and no others.  (Moving the input head to the 
            right is just reading the next input bit.)
                4.4.2.      Prefix-stable functions.  In the previous section we considered block­
            ing  read primitive:  program stops and waits until the next bit  arrives.  There is 
            another possibility:  bits arrive asynchronously and are placed in the input queue; 
            the program may ask whether the queue is empty or not, and continue the execu­
            tion.  Also,  if the queue is not empty, the program may get the next bit from the 
            queue.
