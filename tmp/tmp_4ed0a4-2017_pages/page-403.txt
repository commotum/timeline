                                     12.12.  MINIMAL  SUFFICIENT  STATISTICS                    393
                 Proof.  As in many other cases, we will prove this result using a game.1  First 
             we describe the game, then show the winning strategy, and finally we explain how 
             this  implies the statement of the theorem.
                 The game has parameter n.  We (being one of the players) may, for each 2n-bit 
             string B,  choose at most 2n strings of length 2n,  calling them  “simple given B”. 
             Our adversary, on the other hand, for each triple (p, q, r)  (taken from some set M 
             of admissible triples, see below) may do the following:
                    •  for every string В of length 2n, choose at most 2r strings of length q and 
                       call them  “r-simple given В” ;
                    •  for every string B' of length q, choose at most 2P strings of length 2n and 
                       call them  “p-simple given В   .
             This is done independently for each triple (p, q, r)  from M.  Imagine that we play 
             against  a  team.  For  each  (p, q, r)  there  is  a  team  member  who  makes  his  own 
             announcements (obeying his own cardinality restrictions,  as described),  but they 
             play as a team against us.
                 The adversary team includes two more members.  The first one may choose up 
             to 22'1“1  strings of length 2n  (i.e., not more than half) and call them  “bad”.  The 
             second one may for every string В of length 2n choose up to 2n-2 strings of length 
             2n (in a different way for each В) and call them “bad for this FT’.
                 Later we will play with the adversary who marks as “bad” all 2n-bit strings of 
             complexity less than 2n — 1, and for each В marks as “bad for В”  all 2n-bit strings 
             A such that C(A\B) < n — 2.  But the game rules do not say anything about this 
             specific choice of bad strings.  Note that we use threshold n — 2 (and not, say, n — 1) 
             since we need some reserve; see below.
                 Both we and the adversary make the declarations gradually—at any moment 
             each player may extend the lists of simple/bad strings (if the cardinality restrictions 
             are not violated by this extension).  The declarations cannot be retracted.  Since the 
             total number of positions is finite,  the game  (though being formally infinite)  has 
             some limit position,  but the players do not declare whether they will make more 
             moves or not.
                 The winner in the game is determined by the limit  position.  The adversary 
             wins if for every pair of 2n-bit strings A and B, where A is n-simple given B, and 
             A  and В  are not bad,  and A is not bad for B,  there exists  an admissible triple 
             (p, q, r)  and a q-bit string B' such that
                    •  B' is r-simple given B\
                    •  A is p-simple given B'.
                 According to our plan, we first show a simple computable strategy that wins this 
             game (for some set of admissible triples (p, q,r)), and we then derive the statement 
             of the theorem.  This strategy replies to each move of the adversary (made by some 
             team member who declares a new  “bad”  or a new  “simple”  string)  by one move. 
             We add (for some string В of length 2n) one n-simple string A of length 2n that 
             prevents the adversary from winning, if no new moves are made.  To achieve this, 
             we need the following:
                    •  the chosen strings A and В are not yet declared bad;
                    •  A is not yet declared bad for B\
                 1We have  already seen  several  game arguments;  for a survey  of game  techniques  for  Kol­
             mogorov complexity see [198,  136].
