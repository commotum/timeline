                     4.7.  CONDITIONAL PREFIX  COMPLEXITY AND  COMPLEXITY OF PAIRS              103
                 Now we consider only decompressors that are prefix stable with respect to the 
             first argument.  This smaller class of decompressors contains an optimal decompres­
             sor (for this class).  The proof of this statement is similar to the proof of Theorem 48 
             (p.  82)  where an optimal unconditional prefix-stable decompressor is constructed. 
             We modify this proof by adding the parameter г in all formulas.  More specifically, 
             let
                                             D'(py,z) = \p](y,z).
             Here  [p]  stands  for  the  program  obtained  from p  via  “prefix  stabilization  with 
             respect to у for each z”.  This means that for all p, z, the function у    \p]{y, z)  is 
             prefix stable, and if the function у   p(y, z) itself is prefix stable for some 2, then 
             it  coincides with the function у    \p](y,z).  It is easy to verify that this is indeed 
             possible and that D' is an optimal prefix-stable (with respect to the first argument) 
             decompressor.
                 Fix an optimal conditional prefix-stable decompressor, and denote the resulting 
             complexity by K(x\z), the prefix complexity of x with condition z.
                 If we consider prefix-free decompressors (instead of prefix-stable ones), we ob­
             tain an alternative definition of conditional prefix complexity.  The existence of an 
             optimal function in this class of decompressors is proved in a similar way.  The re­
             sulting complexity could be denoted by K'(x\z).  Like their unconditional versions, 
             functions K(x\z) and K'(x\z) differ by at most an additive constant, which does 
             not depend on x and г:
                                          K'(x\z) = K(x\z) + 0(l).
                 As in the case of unconditional complexities, this is proved using the conditional 
             a  priori  probability  m,(x\z).  It  can  be  defined  in  two  ways  (using  probabilistic 
             machines and lower semicomputable semimeasures).
                 Let M be a probabilistic machine with an input.  Let рм{х \ z) denote the prob­
             ability that  M outputs the string x for input  г.  The function  (x,z)  i-> pm(x\z) 
             is  lower  semicomputable,  and  for  all  г  the sum  Y1xPm(x\z)  does  not  exceed  1. 
             Conversely,  for  every  lower  semicomputable  function  (x, z)  ^  p(x \ z)  that  takes 
             non-negative real values such that  YhxP{x\z)  ^  1  f°r all z->  there exists a proba­
             bilistic machine M with рм = P-
                 The class of all functions рм has an optimal function, that is, the greatest one 
             up to a constant  factor.  Fixing an optimal function in this class,  we obtain the 
             conditional a priori probability m.(x\z)  of the string x with condition z.
                 The inequality K(x\z) ^ K'(x \ z) + 0(1) is easy (as in the unconditional case). 
             To show that all three quantities K(x\z), K'(x\z)  and — \ogm(x\z)  coincide up 
             to an additive constant, we need to show that — \ogm(x\z) ^ K(x\z) + 0(1) and 
             K' (x\ z)  ^  — \ogm,(x\z) + 0(1).  We  omit  those  proofs  since  they  repeat  their 
             unconditional versions.
                 One could say that these inequalities and their proofs are “relativizations” of the 
             respective unconditional inequalities and proofs.  The relativization is understood 
             here in  a non-standard way.  In the theory of computation,  relativization means 
             that  the  class  of computable  functions  is  replaced  by  the  class  of A-computable 
             functions, i.e., the class of functions computable with a given oracle A.  (Here A is 
             an arbitrary set of binary strings.  A function is computable with oracle A if it is 
             computed by an algorithm that is allowed to make queries of the form  “x G AT'. 
             That is,  the algorithm calls  an external procedure that on input x returns true
