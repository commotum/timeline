                GECCO’21,July10–14,2021, Lille, France                                                                              ThomasHelmuthandPeterKelly
                the problems in PSB2 require a wide range of programming tech-                General program synthesis requires the manipulation of multi-
                niques, data types, and control ﬂow structures to solve. However,          ple data types; stack-based GP systems have handled this require-
                theyaremarkedlyhardertosolvethanproblemsinPSB1,withour                     ment well, but so have other GP systems that handle strong typ-
                initial results solving 13 of the 25 problems for an average success       ing of programs. In particular, grammar-based approaches such as
                rate of 10/100. These more diﬃcult problems will drive program             grammar guided GP (G3P) [6–9] and grammatical evolution (GE)
                synthesis research toward solving more realistic program synthe-           [22, 27, 39, 50] have made goodprogress at solving theproblemsin
                sis tasks.                                                                 PSB1. Many of these use the type-based grammar design patterns
                   The purpose of benchmark problems is to allow us to empiri-             introducedtoﬂexiblyhandleproblemswithdiﬀerent typerequire-
                cally show what changes to a system produce improvements that              ments [6]. Another use of these grammars trains a sequence-to-
                may transfer to real-world problems. To achieve this goal, they            sequence variational autoencoder to embed programs in a contin-
                must be suﬃciently diﬃcult, unlike toy problems that have been             uous space and then uses an evolutionary algorithm to optimize
                used as benchmarks in the past. They must also be representative           programs in this space [32]. Finally, a linear GP system with tag-
                of the types of tasks we want our system to perform. However, we           based memoryhas also been explored using PSB1 [5, 23, 29].
                also want benchmarks to be easier and faster to run than an ac-               Asfor non-GP systems, an approach using delayed-acceptance
                tual real-world problem in order to aid reasonable testing of a sys-       hillclimbing for inductive synthesis proved competitive with GP
                tem.Giventhatautomaticprogramsynthesisisstillinitsﬂedgling                 on PSB1, including producing the only known solutions to the
                stages, we see the problems in PSB2 as a stepping stone toward             Collatz Numbers problem [44]. A comparison was made between
                solving more realistic problems.                                           FlashFill [11], MagicHaskeller [26], PushGP, and G3P, ﬁnding that
                   PSB2 also addresses calls from the GP community to produce              the non-GP methods fared much worse but ran much faster than
                andadoptrealisticbenchmarks.GPcommunitydiscussionscalling                  the GP methods[41].Finally, Monte Carlo tree search was used to
                for better benchmarks [34, 59, 60] inspired the creation of PSB1;          generate Java bytecode programs using a few of the problems in
                these calls also highlighted the need to periodically update and           PSB1[31].
                replace benchmark problems in order to keep advancing the ﬁeld
                withoutover-optimizingtoasinglesetofproblems.Morerecently,
                acalltorefocustheeﬀortsofGPonautomaticprogrammingstated,                   3 LESSONSLEARNED
                “We are in no doubt of the need for the further principled devel-          While PSB1 has been successfully used in a variety of research, it
                opment of additional benchmarks that can be used in a targeted             wasaﬁrstattemptatageneral-purpose programsynthesis bench-
                manner to push the boundaries along diﬀerent dimensions such               marksuite.Theresearchcommunityhasgrownfromusingit,both
                as scalability, generalisation, and adaptation, and to facilitate com-     intermsofimprovingprogramsynthesismethodsaswellaslessons
                parison across a range of very diﬀerent approaches to automatic            learned about how to best deﬁne program synthesis benchmarks.
                programming” [40]. The creation of PSB2 aims to push the bound-            Here, we discuss some issues of the latter type and how they have
                aries of program synthesis research and give synthesis systems a           inﬂuenced our creation of PSB2.
                fresh set of problems to explore. Of course, there is no need to en-          One major issue with PSB1 is that every system that uses it
                tirely throw out the problems of PSB1; we could imagine some of            needs to implement all of the problems from scratch. This hurdle
                the harder problems continuing to provide useful data, and newer           likely decreased wider adoption. Additionally, there may be incon-
                systems mayneedtostartontheeasier problems as a jumping oﬀ                 sistencies between implementations in diﬀerent systems, leading
                point.                                                                     to less comparable results; one known such inconsistency is that
                   Theremainderofthispaperisstructuredasfollows:inthenext                  some systems use new randomized data for each run, while oth-
                section, we discuss research that has used PSB1. In Section 3, we          ers use the same dataset for every run. Four years after its initial
                highlight lessons learned about program synthesis benchmarking             release, the authors of PSB1 created large datasets of the inputs
                from PSB1. Sections 4 and 5 describe the sources of PSB2’s prob-           and correct outputs for each problem [12]. These datasets can be
                lems and describe the problems in detail. We then give general             sampledforeachprogramsynthesisrun,meaningthereisnoneed
                guidance on benchmarking with PSB2, and give details of the pa-            for each system to implement each problem. We have copied this
                rameters we used in our experiments in Sections 6 and 7. Finally,          model, and provide datasets for each problem in PSB2 (see Sec-
                Section 8 presents initial results using PushGP.                           tion 6).
                                                                                              AhandfuloftheproblemsinPSB1requireprogramstoproduce
                                                                                           Boolean outputs, as such functions are common in programming
                2 PASTRESEARCHUSINGPSB1                                                    exercises. A trend noted across completely diﬀerent program rep-
                PSB1hasbeenusedinavarietyofresearch projectson automatic                   resentations is that solutions to these Boolean-outputproblems of-
                programsynthesis,manyofthemusingGPasthesynthesissystem.                    tendonotgeneralize tounseen data.Asimpleexplanationforthis
                The paper that introduced PSB1 [17] used PushGP, a GP system               phenomenon is that it is relatively easy for a solution program to
                basedonthestack-basedPushprogramminglanguage;avarietyof                    producethecorrectanswersforthewrongreasonswhenthereare
                papers using PushGP have made use of PSB1 since [14–16, 18, 21,            only two possible answers, thus overﬁtting to the training data. It
                46, 47]. Code-building GP is a stack-based GP system borrowing             is muchhardertoperfectlyanswertrainingdataforthewrongrea-
                some inspirations from Push that constructs programs in a host             sonswhentheoutputisanintegerorstring,forexample.Because
                language; it solved some ofthe PSB1problems,producingsolution              of this issue, we have selected fewer Boolean-output problems for
                programs in Python [42].                                                   PSB2, including only one representative problem.
