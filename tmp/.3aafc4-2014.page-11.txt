                string x, the OSCR algorithm produces a two-part code. The ﬁrst part is a codebook, which maps
                symbols chosen from the original input string to new symbols in the encoded string. The second
                part of the code is the input string, encoded using the symbols in this codebook. The goal of OSCR
                is to select which symbols to put in the codebook such that the total size of the output—codebook
                size plus encoded string size—is minimized.    The optimal codebook size for x is an estimate of
                K(S), the sophistication of x.   The optimal total size of the output for x is called the minimum
                description length (MDL) of the string, and is an estimate of K (x).
                   The OSCR approach seems promising because of its direct relationship to the functions we are
                interested in approximating. However, we implemented a version of this algorithm, and we found
                that our implementation does not perform well in compressing the automaton data. The output of
                the algorithm is noisy, and there is no obvious trend in either the entropy or complexity estimates.
                Weconjecture that the noise is present because this compression method, unlike others we consider,
                does not take into account the two-dimensionality of the automaton state.
                   An alternative metric adopts the idea of coarse-graining. Here we aim to describe a system’s
                state on a macroscopic scale—for example, the coﬀee cup as it would be seen by a human observer
                from a few feet away—by smoothing the state, averaging nearby values together. Conceptually, for
                an automaton state represented by a string x, its coarse-grained version is analogous to a typical
                set S which contains x. The coarse-grained state describes the high-level, “non-random” features
                of x—features which it has in common with all other states from which the same coarse-grained
                representation could be derived.    Thus, the descriptive size of the coarse-grained state can be
                used as an estimate for the state’s sophistication, K (S).  To estimate the descriptive size of the
                coarse-grained state, we compress it using a general ﬁle compression program, such as gzip or bzip.
                Shalizi [11] objects to the use of such compression programs, claiming that they do not provide
                consistently accurate entropy estimates and that they are too slow. In our experiments, we have
                not seen either of these problems; our simulations run in a reasonable amount of time and produce
                quite consistent entropy estimates (see, for instance, Figure 5). We therefore use such compression
                programs throughout, though we consider alternative approaches in Section 7.
                   Having deﬁned the notion of coarse-graining, we can then deﬁne a two-part code based on it.
                If the ﬁrst part of the code—the typical set—is the coarse-grained state, then the second part
                is K(x|S), the information needed to reconstruct the ﬁne-grained state given the coarse-grained
                version.  The total compressed size of both parts of the code is an estimate of the Kolmogorov
                complexity of the state, K (x).
                   Weattempted to implement such a two-part code, in which the second part was a diﬀ between
                the ﬁne-grained and coarse-grained states.    The ﬁne-grained state, x, could be uniquely recon-
                structed from the coarse-grained array and the diﬀ. In our implementation of this two-part code,
                our estimate of K (x|S) suﬀered from artifacts due to the way the diﬀ was represented. However,
                deﬁning a two-part code based on coarse-graining is possible in general.
                   In light of the artifacts produced by our implementation of the two-part code, we chose to
                pursue a more direct approach using coarse-graining. We continued to use the compressed size of
                the coarse-grained state as an approximation of K (S). However, instead of approximating K (x|S)
                and using K(S)+K(x|S) as an estimate of K(x), we approximated K(x) directly, by measuring
                the compressed size of the ﬁne-grained array. This approach avoided the artifacts of the diﬀ-based
                code, and was used to generate the results reported here.
                                                                11
