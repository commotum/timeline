                                                                Automating String Processing in
                                                Spreadsheets Using Input-Output Examples
                                                                                                 Sumit Gulwani
                                                                                  Microsoft Research, Redmond, WA, USA
                                                                                              sumitg@microsoft.com
                    Abstract                                                                                     their task [9]. More signiÔ¨Åcantly, programming is still required to
                    We describe the design of a string programming/expression lan-                               perform tedious and repetitive tasks such as transforming entities
                    guage that supports restricted forms of regular expressions, condi-                          like names/phone-numbers/dates from one format to another, data
                    tionals and loops. The language is expressive enough to represent                            cleansing, extracting data from several text Ô¨Åles or web pages into
                    a wide variety of string manipulation tasks that end-users struggle                          a single document, etc. Spreadsheet systems like Microsoft Excel
                    with. We describe an algorithm based on several novel concepts for                           allow users to write macros using a rich inbuilt library of string and
                    synthesizing a desired program in this language from input-output                            numerical functions, or to write arbitrary scripts using a variety of
                    examples.ThesynthesisalgorithmisveryefÔ¨Åcienttakingafraction                                  programminglanguageslikeVisualBasic, or .Net. Since end-users
                    of a second for various benchmark examples. The synthesis algo-                              are not proÔ¨Åcient in programming, they Ô¨Ånd it too difÔ¨Åcult to write
                    rithm is interactive and has several desirable features: it can rank                         desired macros or scripts.
                    multiple solutions and has fast convergence, it can detect noise in                               Wehaveperformedanextensivecasestudyofspreadsheet help
                    the user input, and it supports an active interaction model wherein                          forums and identiÔ¨Åed that string processing is one of the most
                    the user is prompted to provide outputs on inputs that may have                              common class of programming problems that end-users struggle
                    multiple computational interpretations.                                                      with. This is not surprising given that languages like Perl, Awk,
                        Thealgorithmhasbeenimplementedasaninteractiveadd-infor                                   Python came into existence to support string/text processing, and
                    MicrosoftExcelspreadsheetsystem.Theprototypetoolhasmetthe                                    that new languages like Java/C# provide a rich support for string
                    golden test - it has synthesized part of itself, and has been used to                        processing. During our study of help forums, we also carefully
                    solve problems beyond author‚Äôs imagination.                                                  studied how these users were describing the speciÔ¨Åcation of the
                                                                                                                 desired program to the experts on the other side of the help forums.
                    Categories and Subject Descriptors                D.1.2 [Programming Tech-                   It turns out that the most common form of speciÔ¨Åcation was input-
                    niques]: Automatic Programming; I.2.2 [ArtiÔ¨Åcial Intelligence]:                              output examples. Since input-output examples may lead to under-
                    Program Synthesis                                                                            speciÔ¨Åcation, the interaction between the user and the expert often
                    General Terms         Algorithms, Human Factors                                              involved a few rounds of communication (over multiple days).
                                                                                                                      Wedescribe a program synthesis system that is capable of syn-
                    Keywords        Program Synthesis, User Intent, Programming by Ex-                           thesizing a wide range of string processing programs in spread-
                    ample (PBE), Version Space Algebra, Spreadsheet Programming,                                 sheets from input-output examples. The synthesizer aims to replace
                    String Manipulation                                                                          the role of the forum expert, which not only removes a human from
                                                                                                                 the loop, but also enables users to solve their problems in a few
                    1.     Introduction                                                                          seconds as opposed to a few days. Our synthesis system, which
                                                                                                                 is deployment ready, has the following important usability proper-
                    More than 500 million people worldwide use spreadsheets. These                               ties.
                    business end-users have myriad diverse backgrounds and include                                 ‚àô Fully Automated: We do not require non-sophisticated end-
                    commodity traders, graphic designers, chemists, human resource                                   users to provide annotations/hints of any form.
                    managers, Ô¨Ånance pros, marketing managers, underwriters, com-                                  ‚àô Real Time: Our system takes less than 0.1 second on average
                    pliance ofÔ¨Åcers, and even mailroom clerks ‚Äì they are not profes-                                 per interactive round.
                    sional programmers, but they need to create small, often one-off,                              ‚àô Easy Interaction: Programming by examples is an interactive
                    applications to support business functions [5].                                                  process where examples are added in each round to make the
                        Unfortunately, the state of art in spreadsheet programming is                                speciÔ¨Åcation more precise. Our system helps identify the inputs
                    far from satisfactory. Spreadsheet systems come with tons of fea-                                for which the user should provide examples.
                    tures, but end-users struggle to Ô¨Ånd the correct feature or succes-                            ‚àô Fast Convergence: Our system typically takes 1-4 rounds of
                    sion of commands to use from a maze of features to accomplish                                    iteration for convergence in practice.
                                                                                                                   ‚àô Noise Handling: If the user makes a small mistake in mostly
                                                                                                                     correct speciÔ¨Åcation, our system can still compute the likely
                    Permission to make digital or hard copies of all or part of this work for personal or            solution and report the likely mistake.
                    classroom use is granted without fee provided that copies are not made or distributed        This paper makes the following contributions.
                    for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
                    on the Ô¨Årst page. To copy otherwise, to republish, to post on servers or to redistribute      1. We describe a string programming/expression language that is
                    to lists, requires prior speciÔ¨Åc permission and/or a fee. This paper is a minor revision         expressive enough to represent a wide variety of string manipu-
                    of the paper of the same name published in:
                    PoPL‚Äô11,   January 26‚Äì28, 2011, Austin, Texas, USA.                                              lation tasks found during an extensive study of Excel online help
                               c
                    Copyright ‚Éù 2011 ACM978-1-4503-0490-0/11/01...$10.00
                   forums, while at the same time also being restrictive enough to       learning. There is a tradeoff between the expressiveness of a search
                   enable efÔ¨Åcient program search over that space (Section 3).           space, and the complexity of Ô¨Ånding simple consistent hypotheses
                2. We describe an algorithm with several novel concepts that can         within that space [6, 18]. In general, the more expressive a search
                   efÔ¨Åciently synthesize a set of programs in our language that are      space, the harder the task of Ô¨Ånding consistent hypotheses within
                   consistent with a given set of input-output examples (Section 4).     that search space. However, it is also worth-mentioning that the
                3. We describe extensions to the above algorithm that enable sev-        expressiveness-complexity tradeoff is not as simple as it seems, as
                   eral usability properties (Section 5).                                an expressive language can sometimes make a simple theory Ô¨Åt the
                4. We discuss our experience with a ready-to-be-deployed proto-          data, whereas restricting the expressiveness of the language means
                   type tool (Section 6).                                                that any consistent theory must be very complex. Our string expres-
                                                                                         sion language seems to enjoy the right tradeoff. We present a core
                2.   ProblemDeÔ¨Ånition                                                    version of this language; extensions that enable easy adaptation of
                                                                                         the underlying algorithm are mentioned later in Section 4.7.1.
                We start out by describing a representative case-study, picked up           The syntax and semantics of the string expressions P is for-
                from an online Excel help forum, that illustrates a typical interac-     mally described in Figure 1 and Figure 2 respectively. We use the
                tion between a user and an expert on help forums. We then use it to      notation  to denote an empty string and ‚ä• to denote an undeÔ¨Åned
                motivate the key technical problem that we address in this paper.        value. If any of the arguments to any constructor is ‚ä•, then it re-
                EXAMPLE1. The user intends to extract the following bold sub-            turns ‚ä•. The notation s[t1 : t2] denotes the substring of s starting
                strings from the respective strings:                                     at location t1 and ending at location t2.
                                                                                            The string expressions P map an input state , which holds
                1. John DOE3Data[TS]865-000-0000--453442-0006-23-2009                    values for m string variables v1,‚ãÖ‚ãÖ,vm (denoting the multiple input
                2. A FF MARILYN30‚ÄôS865-000-00304535871-0007-07-2009                      columns in a spreadsheet), to a single output string s.
                3. A GEDA-MARY100MG865-001-0020--5941-0006-23-2009                                  P : (String√ó...√óString) ‚Üí String
                The user initially provides a few examples to the expert that are        The above formalism can also be used for string processing tasks
                similar to the Ô¨Årst example above. The expert provides a program         that require generating a tuple of n strings as an output by simply
                P that uses the logic of extracting 12 characters after the Ô¨Årst
                 1                                                                       solving n independent problems.
                occurrence of ‚Äú]‚Äù. The user runs program P1 on other inputs in              A trace expression refers to the Concatenate(f ,‚ãÖ‚ãÖ,f ) con-
                her spreadsheet and observes that it does not perform the desired                                                             1    n
                extraction for the second example above and then presents that           structor, which denotes the string obtained by concatenating the
                                                                                         strings represented by f ,f ,‚ãÖ‚ãÖ,f in that order. An atomic expres-
                to the expert. The expert then provides a program P      that uses                              1  2     n
                                                                       2                 sion refers to ConstStr (denoting a constant string), SubStr or
                the logic of Ô¨Ånding the Ô¨Årst occurrence of ‚Äú-‚Äù and extracting 3          Loopconstructors, which are explained below.
                characters on left of it and 8 characters on right of it. The user
                runs program P on her spreadsheet and observes that it does not
                               2
                performthedesiredextractionforthethirdexampleaboveandthen                3.1  Substrings
                presents that to the expert. The expert then provides a program P
                                                                                 3       The SubStr(vi,p ,p ) constructor makes use of two position ex-
                that uses the logic of Ô¨Ånding the Ô¨Årst occurrence of a pattern of the                      1  2
                                                                                         pressions p and p , each of which evaluates to an index within the
                form‚Äú???-???-????‚Äù,where?issupposedtomatchanycharacter.                             1      2
                                                                                         string v . SubStr(v ,p ,p ) denotes the substring of string v that
                The user runs program P on her spreadsheet and is satisÔ¨Åed with                 i           i   1  2                                  i
                                         3                                               starts at index speciÔ¨Åed by p and ends at index speciÔ¨Åed by p -1.
                the produced results, and the thread is closed.                                                      1                                 2
                                                                                         If either of p or p refer to an index that is outside the range of
                                                                                                      1     2
                One might wonder why did the expert not suggest a program P              string vi, then the SubStr constructor returns ‚ä•.
                                                                                 4
                which is similar to P , but ? is supposed to match any digit as op-         The position expression CPos(k) refers to the kt‚Ñé index in
                                     3
                posedtoanycharacter.Orwhydidtheexpertnotsuggestaprogram                  a given string from the left side (or right side), if the integer
                P which is similar to P , but the Ô¨Årst three occurrences of ? are        constant k is non-negative (or negative). Pos(r ,r ,c) is another
                 5                       3                                                                                               1  2
                forced to match only 865. Even though programs P , P and P               position constructor, where r and r are some regular expressions
                                                                    3    4       5                                   1      2
                are semantically different, these programs may not yield different       and integer expression c evaluates to a non-zero integer. The Pos
                outputs on the inputs the user has in her spreadsheet. Hence these       constructor evaluates to an index t in a given string s such that r
                                                                                                                                                          1
                programs are observationally equivalent over the format of the in-       matches some sufÔ¨Åx of s[0 : t-1] and r2 matches some preÔ¨Åx of
                puts present in the spreadsheet.                                                                                                   t‚Ñé
                                                                                         s[t : ‚Ñì-1], where ‚Ñì = Length(s). Furthermore, t is the c     such
                   We draw the following conclusions from this representative            match starting from the left side (or the right side) if c is positive
                case study. First, the user is communicating her intent using input-     (or negative). If not enough matches exist, then ‚ä• is returned.
                output examples. Second, the user cannot be expected to provide                                                              t‚Ñé
                                                                                            Weusenotation SubStr2(vi,r,c) to denote the c       occurrence
                representative inputs in the Ô¨Årst round. Hence, an example based         ofregularexpressionrinv ,i.e.,SubStr(v ,Pos(,r,c),Pos(r,,c)).
                                                                                                                   i               i
                synthesis system must be interactive. However, in order to remain        WeoftendenoteSubStr(vi,CPos(0),CPos(-1)) by simply vi.
                usable, the system should allow the user to interact easily and
                converge quickly (i.e., in a few rounds) to the desired intent [10].     Tokens and Regular Expressions      Atoken is either some special
                In this paper, we describe such a program synthesis system. We           token or is constructed from some character class C in two ways:
                present an algorithm for synthesizing string manipulation programs       C+denotesatokenthatmatchesasequenceofoneormorecharac-
                that are consistent with input-output examples. We also describe         ters from C. ¬¨C+ denotes a token that matches a sequence of one
                how the algorithm can be extended to enable easy interaction and         or more characters that do not belong to C. We use the following
                fast convergence.                                                        collection of character classes C: Numeric Digits (0-9), Alphabets
                3.   Expression Language for String Manipulation                         (a-zA-Z), Lowercase alphabets (a-z), Uppercase alphabets (A-Z),
                                                                                         Accented alphabets, Alphanumeric characters, Whitespace charac-
                Wehave identiÔ¨Åed a string expression language that is expressive         ters, All characters. We use the following SpecialTokens.
                enough to describe various string manipulation tasks succinctly,         ‚àô StartTok: Matches the beginning of a string.
                while at the same time concise enough to be amenable for efÔ¨Åcient        ‚àô EndTok: Matches the end of a string.
                          String expr P         :=      Switch((b ,e ),‚ãÖ‚ãÖ,(b ,e ))                                    [[Switch((b ,e ),‚ãÖ‚ãÖ,(b ,e ))]]                  = if([[b ]]) then [[e ]]
                                                                      1    1          n n                                             1    1          n n                          1               1
                                   Bool b       :=      d1 ‚à®‚ãÖ‚ãÖ‚à® dn                                                                                                                        .
                                                                                                                                                                                          .
                              Conjunct d        :=       ‚àß‚ãÖ‚ãÖ‚àß                                                                                                                           .
                                                          1             n                                                                                                   else if ([[b ]]) then [[e ]]
                             Predicate         :=      Match(v ,r,k) ‚à£ ¬¨ Match(v ,r,k)                                                                                                  n                n
                                                                   i                            i                                                                           else ‚ä•
                                    Trace expr e        :=      Concatenate(f ,‚ãÖ‚ãÖ,f )
                                                                                      1       n                                             [[d  ‚à®...‚à®d ]]            = [[d ]] ‚à®...‚à® [[d ]]
                                 Atomicexprf            :=      SubStr(v ,p ,p )                                                               1             n                   1                     n
                                                                              i   1    2                                                   [[   ‚àß...‚àß ]]            = [[ ]] ‚àß...‚àß [[ ]]
                                                          ‚à£     ConstStr(s)                                                                   1              n                   1                     n
                                                                                                                                          [[Match(v ,r,k)]]           = Match((v ),r,k)
                                                          ‚à£     Loop(w : e)                                                                           i                                     i
                                           Position p       :=      CPos(k) ‚à£ Pos(r ,r ,c)                             [[Concatenate(f ,‚ãÖ‚ãÖ,f )]]  = Concatenate([[f ]] ,‚ãÖ‚ãÖ,[[f ]] )
                                                                                            1   2                                             1      n                                      1            n
                                      Integer expr c        :=      k ‚à£ k w+k
                                                                             1         2                                 [[Loop(w : e)]]          = LoopR(w : e,1,)
                            Regular Expression r            :=      TokenSeq(T ,‚ãÖ‚ãÖ,T )
                                                                                      1       m                       LoopR(w : e,k,) = let t := [[e[k/w]]]  in
                                             Token T        :=      C+ ‚à£ [¬¨C]+                                                                          if (t = ‚ä•) then          else
                                                              ‚à£     SpecialToken                                                                        Concatenate(t,LoopR(w : e,k+1,))
                     Figure1. SyntaxofStringExpressionsP.v referstoafreestring
                                                                                i                                      [[SubStr(v ,p ,p )]]             = s[[[p ]] s : [[p ]] s],where s = (v ).
                     variable, while w refers to a bound integer variable. k denotes an                                              i    1    2                     1          2                           i
                     integer constant and s denotes a string constant.                                                        [[ConstStr(s)]]           = s
                                                                                                                                     [[CPos(k)]] s       = (k                               if k ‚â• 0
                                                                                                                                                                   Length(s)+k              otherwise
                                                                                                                      [[Pos(r ,r ,c)]] s        = tsuchthat‚àÉt ,t s.t. 0 ‚â§ t < t ‚â§ t ,
                      ‚àô A token for each special character, such as hyphen, dot, semi-                                         1   2                                    1    2             1            2
                                                                                                                                                     s[t : t-1] matches r , s[t : t ] matches r ,
                         colon, colon, comma, backslash, forwardslash, left/right paren-                                                                 1                      1           2                2
                         thesis/bracket etc.                                                                                                                           t‚Ñé
                                                                                                                                                     and t is the c       such position (in increasing/
                     Forbetterreadability, we reference tokens by representative names.                                                              decreasing order if c is positive/negative.
                     For example, AlphTok refers to a sequence of alphabetic charac-
                     ters, NumTok refers to a sequence of numeric digits, NonDigitTok                                               Figure 2. Semantics of String Expressions P.
                     refers to a sequence of characters that are not numeric digits,
                     HyphenTokmatcheswiththehyphencharacter.
                         Addition of more tokens may make the language more power-                                                     Input v                                        Output
                                                                                                                                                1
                     ful. (These tokens may be added either by the user or can be mined                                                BTRKRNLWKCORN15Z                                15Z
                     by searching for frequently occurring substrings in a given spread-                                               CAMPDRYDBLNDL3.6OZ                              3.6 OZ
                     sheet.) However, to stay true to our goal of avoiding any user anno-                                              CHOREBOYHDSCSPNG1PK                             1PK
                     tations, we aim to keep the language expressive without having to                                                 FRENCHWORCESTERSHIRE5Z                          5Z
                     depend on addition of problem-speciÔ¨Åc tokens.                                                                     OFTOMATOPASTE6OZ                                6OZ
                         Aregular expression r = TokenSeq(T ,‚ãÖ‚ãÖ,T ) is a sequence                                      The following string program identiÔ¨Åes the left position to be the
                                                                               1       n
                     of tokens T ,‚ãÖ‚ãÖ,T . We often refer to singleton token sequences                                   one before the occurrence of the Ô¨Årst number, while the right posi-
                                     1       n
                     TokenSeq(T ) simply as T . We use the notation  to denote an                                     tion to be the one at the end of the string.
                                      1                   1
                     emptysequence of tokens.  matches an empty string.                                               String Program (in our language):
                         It is worth discussing our restricted choice of regular expres-                               SubStr(v1,Pos(,NumTok,1),CPos(‚àí1))
                     sions. First, we allow for only a restricted form of the Kleene star                              EXAMPLE3 (DirectoryNameExtraction). Consider the follow-
                     operator. TheKleenestarisrestrictedtooneormoreoccurrencesas                                       ing example taken from an excel online help forum.
                     opposed to zero or more occurrences (and that too at the innermost
                     level). Second, we do not allow for the disjunction operator. These                                   Input v1                                        Output
                     restrictions (together with the token partitioning optimization de-                                   Company‚àñCode‚àñindex.html                          Company‚àñCode‚àñ
                     scribed in Section 4.2) enable us to efÔ¨Åciently enumerate regular                                     Company‚àñDocs‚àñSpec‚àñspecs.doc                      Company‚àñDocs‚àñSpec‚àñ
                     expressions that match certain parts of a string. If we allowed ar-                               String Program:
                     bitrary Kleene star and disjunction, we would lose this ability. Use                              SubStr(v ,CPos(0),Pos(SlashTok,,‚àí1))
                     of conditionals at the outer level allow us to recover some of the                                             1
                     expressiveness lost due to restricted form of regular expressions.                                3.2    Loops
                         The following two examples illustrate the expressive power of                                 The string expression Loop(w : e) refers to concatenation of
                     our substring constructor.                                                                        e ,e ,...,e , where e is obtained from e by replacing all occur-
                                                                                                                        1    2         n              i
                     EXAMPLE2. Thegoalinthisproblem,takenfromanExcelonline                                             rences of w by i. n is the smallest integer such that evaluation of
                                                                                                                       e      yields ‚ä•. It is also possible to deÔ¨Åne more interesting termi-
                     help forum, is to extract the quantity of the purchase. Observe that                               n+1
                     characterizing the substring that is being extracted is non-trivial,                              nation conditions (based on position expression, or predicates), but
                     in fact, not even possible using the character-class tokens that                                  weleave out details for lack of space.
                     our language provides. However, characterizing the (left) position                                EXAMPLE4 (GenerateAbbreviation). The goal here is to extract
                     before the substring and the (right) position after the substring is                              out all uppercase letters. This problem is taken from [21] and is
                     relatively easy and also expressible in our language.                                             presented as an example of Advanced Text Formulas.
                       Input v1                                            Output                             Input v1    Input v2     Output
                       International Business Machines                     IBM                                Alex        Asst.         Alex(Asst.)
                       Principles Of Programming Languages                 POPL                               Jim         Manager       Jim(Manager)
                       International Conference on Software Engineering    ICSE                               Ryan                     
                 String Program:                                                                                         Asst.         
                 Loop(w : Concatenate(SubStr2(v ,UpperTok,w))).
                                                          1                                    String Program:
                                                                                               Switch((b ,e ),(b ,)), where
                 EXAMPLE5 (SplitOdds). The goal in this problem, taken from                                1  1     2
                                                                                               b ‚â°Match(v ,CharTok)‚àßMatch(v ,CharTok),
                 an Excel help forum, is to place each odd in a separate cell,                  1             1                         2
                                                                                               e ‚â°Concatenate(v ,ConstStr(‚Äú(‚Äù),v ,ConstStr(‚Äú)‚Äù)),
                 while ignoring any extraneous numbers or parenthesis. We reduce                1                      1                     2
                                                                                               b ‚â°¬¨Match(v ,CharTok)‚à®¬¨Match(v ,CharTok).
                 the problem of generating multiple unbounded number of output                  2               1                          2
                 strings to that of generating one output string where the multiple            EXAMPLE8 (MixedDateParsing). The goal here is to parse
                 strings are separated by a unique symbol, say#.                               dates in multiple formats into day, month, and year. This example is
                              Input v             Output                                       taken from an internal mailing list. We show below the program for
                                      1                                                        monthextraction. (Day and year extraction are solved similarly.)
                              (6/7)(4/5)(14/1)     6/7 # 4/5 # 14/1 #                                                  Input v         Output
                              49(28/11)(14/1)      28/11 # 14/1 #                                                              1
                              () (28/11)(14/1)     28/11 # 14/1 #                                                      01/21/2001       01
                 String Program:                                                                                       22.02.2002       02
                 Loop(w : Concatenate(SubStr(v ,p ,p ),ConstStr(‚Äú#‚Äù)))                                                2003-23-03       03
                                                        1   1   2                              String Program:
                 wherep1 ‚â° Pos(LeftParenTok,TokenSeq(NumTok,SlashTok),w))                      Switch((b ,e ),(b ,e ),(b ,e )), where
                 and p ‚â° Pos(TokenSeq(SlashTok,NumTok),RightParenTok,w).                                   1  1     2   2     3  3
                       2                                                                       b ‚â°Match(v ,SlashTok), b ‚â° Match(v ,DotTok),
                                                                                                1             1               2             1
                                                                                               b ‚â°Match(v ,HyphenTok),
                 EXAMPLE6 (Removeexcessspaces). The goal in this problem,                       3             1
                                                                                               e ‚â°SubStr(v ,Pos(StartTok,,1),Pos(,SlashTok,1))
                 provided by the product team and also present in [21], is to re-               1               1
                                                                                               e ‚â°SubStr(v ,Pos(DotTok,,1),Pos(,DotTok,2))
                 moveallleadingandtrailingspacesandreplaceinternalstringsof                     2               1
                                                                                               e ‚â°SubStr(v ,Pos(HyphenTok,,2),Pos(EndTok,,1))
                 multiple spaces by a single space. Notice how the loop expression              3               1
                 prints out all but last sequence of non-whitespace characters (to             EXAMPLE9 (NameParsing). The goal in this problem, provided
                 not print any trailing whitespace in the output).                             by the product team, is to parse names that occur in multiple
                  Input v                               Output                                 formats and transform them into a uniform format.
                         1                                                                                    Input v                    Output
                     Oege      de      Moor              OegedeMoor                                                  1
                  Kathleen     Fisher     AT&TLabs       Kathleen Fisher AT&T Labs                            Dr. Eran Yahav             Yahav, E.
                                                                                                              Prof. Kathleen S. Fisher   Fisher, K.
                 String Program:                                                                              Bill Gates, Sr.            Gates, B.
                 Concatenate(Loop(w : Concatenate(SubStr(v1,p ,p )),                                         George Ciprian Necula      Necula, G.
                                                                             1  2                             KenMcMillan,II             McMillan, K.
                                                              ConstStr(‚Äú ‚Äù)),
                                 SubStr2(v1,NonSpaceTok,‚àí1))                                   String Program for extracting initial of the Ô¨Årst name:
                 where p1 ‚â° Pos(,NonSpaceTok,w), and                                          The logic used is that of extracting the initial of the Ô¨Årst word not
                 p2 ‚â° Pos(NonSpaceTok,TokenSeq(SpaceTok,NonSpaceTok),w).                       followed by a dot: SubStr(v1,p ,p ), where
                                                                                                                                 1   2
                                                                                               p ‚â°Pos(,TokenSeq(AlphTok,NonDotTok),1),and
                 3.3   Conditionals                                                             1
                                                                                               p ‚â°Pos(,TokenSeq(LowerTok,NonDotTok),1).
                                                                                                2
                 The top-level string expression P is a Switch constructor whose               String Program for extracting last name:
                 arguments are pairs of (disjoint) boolean expressions b and trace             The logic used is that of extracting the word followed by a comma,
                 expressions e. The value of P in a given input state  is the value of        or the last word (if no comma exists): Switch((b ,e ),(b ,e )),
                 the trace expression that corresponds to the boolean expression sat-                                                              1   1     2  2
                                                                                               whereb ‚â°Match(v ,CommaTok),b ‚â° ¬¨Match(v ,CommaTok),
                 isÔ¨Åedby.BooleanexpressionsbarerepresentedinDNFformand                                1             1                 2               1
                                                                                               e   ‚â° SubStr2(v ,p ,p ), e          ‚â° SubStr2(v ,AlphTok,‚àí1),
                 are boolean combinationsofpredicatesoftheformMatch(v ,r,k),                    1                  1   1   2    2                  1
                                                                                i              p ‚â°Pos(,TokenSeq(AlphTok,CommaTok),1)
                 where r is some regular expression and k is some integer constant.             1
                                                                                               and p ‚â° Pos(AlphTok,CommaTok,1)
                 Match(v ,r,k) evaluates to true iff v contains at least k matches                   2
                          i                              i                                     The above two programs can be concatenated together (after dis-
                 of regular expression r. We often denote Match(vi,r) by simply                tributing conditionals at the top-level) along with some constant
                 Match(vi,r,1).                                                                strings to yield the desired program.
                    Conditionals play a very important role in our string processing
                 language. They allow us to appropriately interpret/process data               EXAMPLE10 (PhoneNumbers). The goal here is to parse phone
                 that is in multiple formats. This is precisely the place where most           numbers that occur in multiple formats and transform them into a
                 existing (data cleansing) tools that allow string processing through          uniform format, adding a default area code of ‚Äú425‚Äù if the area
                 tons of automated pre-canned features fail since they assume that             code is missing. This example was provided by the product team.
                 the input is in a Ô¨Åxed structured format. Conditionals also allow us                             Input v           Output
                 to express transformations that are beyond the expressive power of                                      1
                 the underlying conditional-free part of our language.                                            323-708-7700       323-708-7700
                                                                                                                  (425)-706-7709     425-706-7709
                 EXAMPLE7 (ConditionalConcatenation). The goal here is to                                         510.220.5586       510-220-5586
                 concatenate the Ô¨Årst and the second strings v and v in the in-                                   235 7654           425-235-7654
                                                                   1       2                                      745-8139           425-745-8139
                 put tuple as v1(v2), only if both v1 and v2 are non-empty strings.            String Program:
                 Otherwise,theoutputshouldbeemptystring.Thisexampleistaken
                 from an Excel online help forum.                                              Switch((b ,e ),(b ,e )), where
                                                                                                           1  1     2   2
                                                                                                      Àú             Àú                                                                 Àú
                                                                                    [[Switch((b ,e ),‚ãÖ‚ãÖ,(b ,e ))]]             = {Switch((b ,e ),‚ãÖ‚ãÖ,(b ,e )) ‚à£ e ‚àà [[e ]]}
                                                                                                   1   1         n n                                 1   1         n n          i       i
                     Àú                              Àú             Àú
                     P     :=      Switch((b ,e ),‚ãÖ‚ãÖ,(b ,e ))                                              s    t
                                                 1   1         n n                                                 Àú
                                                                                               [[Dag(Àú, , ,,W)]]           = {Concatenate(f ,‚ãÖ‚ãÖ,f ) ‚à£ f ‚àà [[W( )]],
                                                                                                                                                           1      n      i            i
                      Àú                       s   t Àú
                      e    :=      Dag(Àú, , ,,W),                                                                                                  Àú                             s         t
                                                                                                                                         ,‚ãÖ‚ãÖ,     ‚ààformapathbetween and }
                                                                                                                                         1       n
                                                                   Àú
                                                            Àú       f                                                Àú                          Àú
                                             where W :  ‚Üí 2                                                       [[{f } ]]   = {f‚à£f‚àà[[f ]]}
                                                                                                                      i i                         i
                      Àú                           Àú
                      f    :=      Loop(w : e)                                                                         Àú                                        Àú
                                                                                                        [[Loop(w : e)]]       = {Loop(w:e)‚à£e‚àà[[e]]}
                                                    Àú        Àú                                                      ‚Ä≤                                                                    ‚Ä≤
                             ‚à£     SubStr(v ,{p } ,{p } )                   (1)
                                                i       j        k                                        Àú        Àú                                                      Àú             Àú
                                                                                       [[SubStr(v ,{p } ,{p } )]]              = {SubStr(v ,p ,p ) ‚à£ p ‚àà [[p ]],p ‚àà [[p ]]}
                                                     j        k                                      i     j j      k k                            i    1   2      1       j     2       k
                             ‚à£     ConstStr(s)                                                          [[ConstStr(s)]]        = {ConstStr(s)}
                      Àú
                      p    :=      CPos(k)                                                                    [[CPos(k)]]      = {CPos(k)}
                                         Àú Àú Àú
                             ‚à£     Pos(r ,r ,c)
                                          1   2                                                                Àú Àú Àú                                            Àú          Àú        Àú
                                                                                                        [[Pos(r ,r ,c)]]       = {Pos(r ,r ,c) ‚à£ r ‚àà r ,r ‚àà r ,c ‚àà c}
                                                                                                                 1   2                        1   2        1      1   2     2
                      Àú                          Àú       Àú                                                   Àú       Àú                                                      Àú               Àú
                      r    :=      TokenSeq(T1,‚ãÖ‚ãÖ,Tn)                                         [[TokenSeq(T ,‚ãÖ‚ãÖ,T )]]           = {TokenSeq(T ,‚ãÖ‚ãÖ,T ) ‚à£ T ‚àà T ,‚ãÖ‚ãÖ,T ‚àà T }
                                                                                                               1       n                               1       n       1      1       n       n
                                 Figure 3. Syntax and semantics of a language/data-structure for succinctly describing huge sets of string expressions.
                                                        s    t  Àú                      s    t  Àú                                        s    s      t   t    Àú
                           Intersect(Dag(Àú , , , ,W ),Dag(Àú , , , ,W ))                              = Dag(Àú √óÀú ,( , ),( , ),12,W12), where
                                                   1    1   1    1     1           2   2    2   2     2                    1      2     1    2      1   2
                                                                                    Àú                         ‚Ä≤   ‚Ä≤             ‚Ä≤      Àú           ‚Ä≤      Àú
                                                                                    12 = {‚ü®(1,2),(1,2)‚ü© ‚à£ ‚ü®1,1‚ü© ‚àà 1, ‚ü®2,2‚ü© ‚àà 2}, and
                                                                               ‚Ä≤   ‚Ä≤                              ‚Ä≤                      ‚Ä≤     ‚Ä≤                  ‚Ä≤
                                                                                                              Àú Àú     Àú                       Àú
                                                        W (‚ü®( , ),( , )‚ü©) = {Intersect(f,f ) ‚à£ f ‚àà W (‚ü® , ‚ü©),f ‚àà W (‚ü® , ‚ü©)}
                                                           12      1   2      1    2                                           1    1    1             2     2   2
                                                                                   ‚Ä≤    ‚Ä≤
                                                    Àú        Àú                         Àú       Àú                                                          Àú Àú
                  Intersect(SubStr(v ,{p } ,{p } ),SubStr(v ,{p } ,{p } ))                                   = SubStr(v ,{IntersectPos(p ,p )} ,
                                               i     j j      k k                 i     ‚Ñì ‚Ñì      m m                            i                          j   ‚Ñì    j,‚Ñì
                                                                                                                                                         Àú Àú                             ‚Ä≤
                                                                                                                                  {IntersectPos(p ,p )}                  )   if vi = v
                                                                                                                                                           k   m k,m                     i
                                                  Intersect(ConstStr(s ),ConstStr(s ))                       = ConstStr(s ) ifs =s
                                                                                  1                   2                             1        1      2
                                                                                Àú                    Àú                                            Àú Àú
                                                 Intersect(Loop(w : e ),Loop(w : e ))                      = Loop(w:Intersect(e ,e ))
                                                                                  1                   2                                             1   2
                                                          IntersectPos(CPos(k ),CPos(k ))                    = CPos(k ) ifk =k                                                                    (2)
                                                                                        1             2                      1         1      2
                                                                                              ‚Ä≤   ‚Ä≤    ‚Ä≤                                               ‚Ä≤                                 ‚Ä≤         ‚Ä≤
                                                                           Àú Àú Àú             Àú Àú Àú                                                Àú Àú                              Àú Àú       Àú    Àú
                                                IntersectPos(Pos(r ,r ,c),Pos(r ,r ,c ))                     = Pos(IntersectRegex(r ,r ),IntersectRegex(r ,r ),c‚à©c )
                                                                            1   2             1   2                                                1   1                             2   2
                                                              Àú       Àú                    Àú‚Ä≤      Àú‚Ä≤                             Àú      Àú‚Ä≤      Àú      Àú‚Ä≤
                       IntersectRegex(TokenSeq(T ,‚ãÖ‚ãÖ,T ),TokenSeq(T ,‚ãÖ‚ãÖ,T ))                                 = TokenSeq(T ‚à©T,‚ãÖ‚ãÖ,T ‚à©T )                             if n = m
                                                                1       n                    1       m                              1             n       m
                                       Figure 4. The Intersect function. The Intersect function returns ‚àÖ in all other cases not covered above.
                   b ‚â°Match(v ,NumTok,3),b ‚â° ¬¨Match(v ,NumTok,3),                                               bythesameconditionalinthetop-levelSwitchconstruct(andthen
                     1                1                    2                  1
                   e ‚â°Concatenate(SubStr2(v ,NumTok,1),ConstStr(‚Äú-‚Äù),                                           intersect the trace sets for inputs in the same partition). Partitioning
                     1                                       1
                                              SubStr2(v1,NumTok,2),ConstStr(‚Äú-‚Äù),                               is performed (in Line 4) using the procedure GeneratePartition
                                              SubStr2(v1,NumTok,3))                                             (explained in Section 4.5.1). Inputs in the same partition have the
                   e ‚â°Concatenate(ConstStr(‚Äú425-‚Äù),SubStr2(v ,NumTok,1),                                        property that intersection of their trace sets is non-empty. The al-
                     2                                                                 1
                                              ConstStr(‚Äú-‚Äù),SubStr2(v1,NumTok,2))                               gorithm uses a greedy heuristic to minimize the number of such
                                                                                                                partitions by starting with singleton partitions and then iteratively
                   4.     Algorithm                                                                             merging those partitions that have the highest compatibility score
                   In this section, we describe an algorithm for learning a string ex-                          (a notion deÔ¨Åned in Sec 4.5.1).
                   pression (in the language presented in Section 3) that is consis-                            Step 3:     The algorithm then constructs (in the loop at Line 7) a
                   tent with the provided input-output examples. In fact, the algorithm                         boolean classiÔ¨Åcation scheme as a function of the inputs that will
                   ends up learning a set of string expressions all of which are con-                           place them in the appropriate partition. This is done using the pro-
                   sistent with the provided input-output examples. This enables the                            cedure GenerateBoolClassifier (explained in Section 4.5.2).
                   algorithm to have several desirable properties discussed later.                              This boolean classiÔ¨Åcation forms the top-level switch construct for
                        The top-level structure of the algorithm is described in proce-                         the string program returned by the algorithm at Line 9.
                   dure GenerateStringPrograminFig7,whichweexplainbelow.                                            Steps2and3areexplainedindetailinSec4.5.TheGenerateStr
                   Step 1:      The algorithm Ô¨Årst computes (in the loop at Line 2), for                        procedureusedinStep1isexplainedinSec4.3.Itmakesuseoftwo
                   each input-output pair (,s), a set of all trace expressions that map                        key procedures GenerateSubstring and GenerateLoop, which
                   input  to output s. We refer to this set as a trace set. This is done                       are discussed in Sections 4.2 and 4.4 respectively. We start out by
                   using the procedure GenerateStr (explained in Section 4.3). The                              brieÔ¨Çy describing the key data-structure (used by these procedures)
                   set of such expressions can be huge; a key enabling technology is                            and the operations that it supports.
                   the data-structure (described in Section 4.1) for succinctly repre-                          4.1    Data-structure for Manipulating Sets of Expressions
                   senting and manipulating such a huge set of expressions.                                     Figure 3 describes our data-structure/language for succinctly rep-
                   Step 2:      If the target program does not contain any conditionals                         resenting huge sets of string expressions of various kinds and also
                   (i.e., it is expressible as a trace expression, then the algorithm can                       presents its formal semantics.
                                                                                                                     Àú Àú Àú Àú         Àú
                   simply intersect the trace sets of all input-output examples. How-                               P,e,f,p,andrdenoterespectivelyasetofstringprograms,aset
                   ever, since this is not a valid assumption, the algorithm Ô¨Årst parti-                        of trace expressions, a set of atomic expressions, a set of position
                   tions the examples so that inputs in the same partition are handled                          expressions, and a set of regular expressions. They are represented
                                                                                              space. For example, following is a small sample of various logics
                                    Àú           Àú               Àú                Àú
                Size(Switch((b ,e ),‚ãÖ‚ãÖ,(b ,e ))) = Size(e ) √ó ‚ãÖ ‚ãÖ √óSize(e )
                                  1  1        n n                1                n           for extracting ‚Äú706‚Äù from the string ‚Äú425-706-7709‚Äù (call it v ).
                                                                                                                                                               1
                    Size(Dag(Àú,s,t,W))        = size(t)                                    ‚àô Second number: SubStr2(v1,NumTok,2).
                                            X            ‚Ä≤        X             Àú              ‚àô Second last alphanumeric token:
                        where size() =         (size( )√ó                Size(f))               SubStr2(v1,AlphNumTok,‚àí2).
                                             ‚Ä≤               Àú      ‚Ä≤                         ‚àô Substring between the Ô¨Årst hyphen and the last hyphen:
                                                              f‚ààW(‚ü® ,‚ü©)                        SubStr(v ,Pos(HyphenTok,,1),Pos(,HyphenTok,‚àí1)).
                        and size(s) = 1                                                                    1
                                                                                               ‚àô First number that occurs between hyphen on both ends.
                                                        X                  X                  SubStr(v1,Pos(HyphenTok,TokenSeq(NumTok,HyphenTok),1),
                                             ‚Ä≤                                        ‚Ä≤
                                    Àú       Àú                     Àú                  Àú
                Size(SubStr(vi,{p }j,{p }k)) = (            Size(p )) √ó (      Size(p ))               Pos(TokenSeq(HyphenTok,NumTok),HyphenTok,1)).
                                     j       k                     j                  k
                                                         j                  k                  ‚àô First number that is preceded by a number-hyphen sequence.
                                           Àú                Àú                                  SubStr(v1,Pos(TokenSeq(NumTok,HyphenTok),NumTok,1),
                         Size(Loop(w : e))      = Size(e)                                               Pos(TokenSeq(NumTok,HyphenTok,NumTok),,1)).
                         Size(ConstStr(s))       = 1                                             The GenerateSubstring procedure performs this task effec-
                               Size(CPos(k))     = 1                                          tively, and is built around the following two key observations.
                                    Àú Àú Àú                   Àú           Àú           Àú
                          Size(Pos(r ,r ,c))     = Size(r )√óSize(r )√óSize(c)
                                     1   2                   1           2                    Decomposition into independent sub-problems           The substring-
                                   Àú     Àú                  Àú                 Àú
                 Size(TokenSeq(T ,‚ãÖ‚ãÖ,T ))        = Size(T )√ó‚ãÖ‚ãÖ√óSize(T )
                                    1      n                  1                n              extraction problem can be decomposed into two independent
                                                                                              position-identiÔ¨Åcation problems, each of which can be solved inde-
                Figure 5. The Size function. The equations here also illustrate               pendently. Note the two independent calls to GeneratePosition
                the huge representation savings that our data-structures provide              procedure at Lines 3 and 4 in GenerateSubstring procedure in
                compared to explicit representation.                                          Figure 7. The solutions to the substring-extraction problem can
                                                                                              also be maintained succinctly by independently representing the
                                                                                              solutions to the two position-identiÔ¨Åcation problems. Note the rep-
                                                             Àú       Àú                        resentation of the SubStr constructor in Eq. 1 in Figure 3.
                using the data-structure shown in Fig 3. T and c represent a set
                of tokens and a set of integer expressions, and are represented               Partitioning of Tokens into Indistinguishable Sets           A given
                explicitly.                                                                   string does not often distinguish between several sets of tokens.
                    The Concatenate constructor used in our string language is                Hence, for any position-identiÔ¨Åcation problem, the choice of reg-
                                                                s   t Àú
                generalized to the Dag constructor Dag(Àú, , ,,W), where Àú                ular expressions for a given string can be restricted to using only
                is a set of nodes containing two distinctly marked source and tar-            one token from each set of indistinguishable tokens. We deÔ¨Åne this
                             s       t  Àú
                get nodes  and  ,  is a set of edges over nodes in Àú that in-             moreformally below.
                                                          Àú
                duces a DAG, and W maps each  ‚àà  to a set of atomic expres-                 DEFINITION 1 (Indistinguishability). We say that a token T1 is
                sions. The set of all Concatenate expressions represented by a                indistinguishable from token T with respect to a string s if the set
                          s   t Àú                                                                                             2
                Dag(Àú, , ,,W) constructor include those whose ordered ar-                 of matches of token T in s is same as the set of matches of token
                guments belong to the corresponding edge on any path from s to                                      1
                                                                                              T instring s.
                t. The Switch, Loop, SubStr, Pos, and TokenSeq constructors                   2
                haveallbeenoverloadedtoacceptasetofvaluesofthecorrespond-                     Note that indistinguishability is an equivalence relation.
                ing type for its arguments with the expected semantics.                       DEFINITION 2 (Indistinguishability Partition). Given a string s
                    The data-structure supports the following two interesting oper-           and a set of tokens, let IParts denote the partition of tokens into
                ations, both of which are required for the partitioning procedure.                                           s
                                                                                              indistinguishable sets, and let Reps denote some set of representa-
                                                                                                                                   s
                                                                                              tive tokens, one from each partition. We use the notation IParts (T)
                IntersectionOperation       Giventwosetsofexpressionsofthesame                                                                                 s
                kind, construct a set of expressions that are common to the two               to denote the set in which token T lies.
                givensets. The intersection function is described in Fig 4. The most             We use this observation to restrict the choice of tokens used
                interesting part is the intersection of two DAGs, which is similar to         in constructing regular expressions to come from the set Reps at
                intersection of two regular automatas. The challenge, compared to                                                                               s
                                                                                              Lines 2 and 3 in procedure GeneratePosition. This signiÔ¨Åcantly
                regularautomatacase,istointersectthelabelsontheedges-incase                   reduces the number of regular expressions that get considered at
                of automata, the labels are simply a set of characters, while in our          Lines 2 and 3 without affecting the completeness of the algorithm.
                case, the labels are sets of string expressions. We intersect sets of
                string expressions using the intersection operation supported by the          4.3   Learning Traces
                data-structure used for representing those sets of string expressions.        In this section, we discuss how to learn the set of all trace expres-
                Size Operation     Givenasetofexpressionsofsomekind,estimate                  sions (i.e., Concatenate constructors) that can be used to gener-
                the size of the set. The size function is described in Figure 5.              ate a given output string from a given input state. The number of
                Observe the succinctness beneÔ¨Åts provided by the factorization                such expressions may be huge. For example, consider the prob-
                used by each set construct.                                                   lem of transforming phone numbers in Example 10. Consider the
                                                                                              second input-output example, where the input state consists of one
                4.2   Learning Substring Extraction Logics                                    string ‚Äú(425)-706-7709‚Äù and the output string is ‚Äú425-706-7709‚Äù.
                                                                                              Figure 6 shows a small sampling of different ways of generating
                In this section, we describe how to learn the set of all SubStr ex-           parts of the output string from the input string using SubStr and
                pressions in our language that can be used to extract a given sub-            ConstStr constructors. (Each substring extraction task itself can
                string from a given string. (This is an important component of the            be performed in a huge number of ways as explained in Sec 4.2).
                procedureGenerateStr.)Thenumberofsuchexpressionsmaybe                         Following are three of the trace expressions represented in the Ô¨Åg-
                huge, in which case, explicit representation and computation of all           ure, of which the second one (also shown in bold in the Ô¨Ågure),
                these expressions would be infeasible with respect to both time and           would lead to the correct answer.
                                Input  (4 2 5) ‚Äì 7 0 6 ‚Äì 7 7 0 9                                                       position to a node corresponding to any later position. Observe
                                                                                                                       that each edge here corresponds to some substring of the output.
                                                                                                                       Each such edge is annotated with the set of all atomic expressions
                                                                                                                       that can generate the corresponding substring (Lines 5 and 6 in
                                                                                                                       procedure GenerateStr). The set of all such SubStr and Loop
                                                                                                                       expressions is generated by Procedures GenerateSubstring and
                                                                                                                       GenerateLooprespectively. The following theorem holds.
                                                                                                                       THEOREM1. Procedure GenerateStr(,s) computes the set of
                               Output  4 2 5 ‚Äì 7 0 6  ‚Äì 7 7 0 9                                                        all trace expressions e with the following properties:
                                               Constant  Constant           Constant                                  A1. (Soundness) e generates the output string s from the input state
                                                                Constant                                                   , i.e., [[e]]  = s.
                     Figure 6. Small sampling of different ways of generating parts of                                A2. (Completeness Restriction) Any loop that occurs in e is non-
                     an output string from the input string.                                                               nested and executes at least twice on .
                                                                                                                       PROOF: The procedure GenerateSubstring(,s) generates the
                     1. Extract the substring ‚Äú425‚Äù. Extract the substring ‚Äú-706-7709‚Äù.                                     set of all SubStr expressions that can generate s from .
                     2. Extract the substring ‚Äú425‚Äù. Print constant ‚Äú-‚Äù. Extract the sub-                                   The procedure GenerateLoop(,s,W) extends the map-
                         string ‚Äú706‚Äù. Print constant ‚Äú-‚Äù. Extract the substring ‚Äú7709‚Äù.                                    ping W(k ,k ) with all Loop expressions that can generate
                                                                                                                                          1    4
                     3. Extract the substring ‚Äú425‚Äù. Extract the substring ‚Äú-706‚Äù. Print                                    s[k1,k4] from  and furthermore satisfy the restrictions in A2.
                         constant ‚Äú-‚Äù. Extract the substring ‚Äú7709‚Äù.                                                        Hence, the theorem follows.
                         GenerateStr procedure performs this task effectively (by us-
                     ing the DAG data-structure introduced earlier to succinctly repre-
                     sent all trace expressions). It uses the following crucial observa-                               4.4    Learning Loops
                     tions.                                                                                            In this section, we discuss how to infer the set of all Loop construc-
                     Independence of (unknown) sub-problems                         First, observe that                tors that can be used to generate some unknown part of a given
                     the logic for generating some substring of an output string is com-                               output string s from a given input state . In the process, we would
                     pletely decoupled from the logic for generating another disjoint                                  also identify the unknown part of the output string that the Loop
                     substring of the output string. Hence, the problem of generating                                  constructor can generate. Procedure GenerateLoop performs this
                     the output string can be decoupled into independent sub-problems                                  task effectively, and involves the following steps:
                     of generating different parts of the output string.                                               1. Guess three positions within the output string k , k , and k .
                                                                                                                                                                                          1    2          3
                         Inparticular, assume that we have an oracle (as in a PBD system                               2. Unify the set of trace expressions that can generate s[k                       : k ]
                     like [11]) that provides us with the decomposition of a given out-                                                                                                               1      2
                                                                                                                           with the set of trace expressions that can generate s[k                    : k ] to
                     put string into n disjoint adjacent substrings, where each disjoint                                                                                                           2      3
                                                                                                                                                                                     Àú
                                                                                                                           obtain a new set of string expressions, say e that uses the loop
                     substring gets generated by a different argument of the enclosing                                     iterator w. The uniÔ¨Åcation algorithm is explained below.
                     concatenate operator. Given such a decomposition, we can decom-                                   3. Obtain the set of substrings obtained by running the string ex-
                     pose the problem of identifying the trace expression for generating                                                Àú
                     the output string, into n independent sub-problems of generating                                      pressions e on input . If this set contains a singleton string that
                                                                                                                           matchess[k : k ]forsomek ,thenweconcludethats[k : k ]
                     each of the disjoint adjacent substrings using at atomic expression                                                   1     3                3                                    1     3
                                                                                                                                                                      Àú
                     constructor. These problems can not only be solved independently,                                     can be generated by Loop(w : e). Otherwise ignore.
                     but their solutions can also be stored independently to succinctly                                The uniÔ¨Åcation algorithm is same as the intersection algorithm
                     represent an exponential number of solutions in linear space. How-                                except with the following replacement to Eq. 2 in Figure 4.
                     ever, unfortunately, we do not apriori know the appropriate decom-                                    IntersectPos(k ,k )                = (k ‚àík )w+k ifk ‚àï=k
                     position of the output string into various parts for which we can                                                             1    2               2       1          1      1       2
                     independently seek a solution. The naive strategy of enumerating                                  Thekeyidea above is to guess a set of loop bodies by unifying the
                     all possible decompositions would not scale since the number of                                   sets of trace expressions associated with the substrings s[k                      : k ]
                                                                                                                                                                                                      1      2
                     decompositions is exponential in the size of the output string.                                   and s[k      : k ], and then test the validity of the conjectured set
                                                                                                                                 2       3
                     Number of possible sub-problems is quadratic                       Second, observe                of loops. For performance reasons, we do not recursively invoke
                     that the total number of different substrings/parts of a string is                                GenerateLoop (in the call that it makes to GenerateStr). This
                     quadratic (and not exponential) in the size of the output string. This                            allows us to discover all single loops. Nested loops may be discov-
                     leads to a succinct representation of all possible decompositions of                              ered by controlling the recursion depth.
                     a string using a DAG representation, and hence allows us to de-                                   4.5    Learning Conditionals
                     compose the problem of generating the output string (using a trace
                     expression) into a quadratic number of independent sub-problems                                   In this section, we discuss how to generate the top-level Switch
                     of generating different substrings of the output string (using some                               constructor, after having learned, for each input-output example,
                     atomic expression).                                                                               the set of all trace expressions that can generate the output string
                         With the above two observations, we are now ready to explain                                  from the input state. There are two important components that
                     the effective functioning of the procedure GenerateStr. The pro-                                  enable learning of appropriate conditionals: partitioning of input-
                                                                              s    t Àú
                     cedure GenerateStr generates a Dag(Àú, , ,,W) constructor                                      output examples into disjoint partitions, and learning classiÔ¨Åers
                     that represents the set of all trace expressions that can generate a                              based on inputs for those partitions. The classiÔ¨Åers provide the
                     given output string from a given input state. The key idea is to                                  conditionals, while the intersection of the trace sets associated with
                     construct a node corresponding to each position within the out-                                   various inputs in a partition yields the computational branch for the
                     put string and create an edge from a node corresponding to any                                    corresponding conditional.
                                                                                                                     GenerateStr(: Input state, s: Output string)
                          GenerateStringProgram(S: Set of (,s) pairs) 1 Àú:= {0,...,Length(s)};
                                                                                                                     2 s := {0};
                         1 T := ‚àÖ;                                                                                   3 t := {Length(s)};
                         2 foreach (,s) ‚àà S                                                                             Àú
                         3         T := T ‚à™({},GenerateStr(,s));                                                   4  := {‚ü®i,j‚ü© ‚à£ 0 ‚â§ i < j ‚â§ Length(s)};                                                     Àú
                         4 T‚Ä≤:= GeneratePartition(T);                                                                5 Let W be the mapping that maps edge ‚ü®i,j‚ü© ‚àà  to the set
                         5 Àú := { ‚à£ (,s) ‚àà S};                                                                            ‚Ä≤     {ConstStr(s[i : j ‚àí 1])} ‚à™ GenerateSubstring(,s[i : j ‚àí 1]);
                         6 foreach (Àú,eÀú) ‚àà T:                                                                      6 W :=GenerateLoop(,s,W);
                                                                                                            ‚Ä≤                                        s    t Àú        ‚Ä≤
                         7       let B[Àú] := GenerateBoolClassifier(Àú,Àú -Àú) 7 return Dag(Àú, , ,,W );
                         8 Let (Àú ,eÀú ),...,(Àú ,eÀú ) be the k elements in
                                         1     1               k    k
                                               T in increasing order of Size(eÀú). GenerateLoop(: Input state, s: Output string, W)
                         9 return Switch((B[Àú ],eÀú ),...,(B[Àú ],eÀú ));                                             1 W‚Ä≤ := W;
                                                                 1      1                   k      k
                                                                                                                     2 foreach 0 ‚â§ k1,k2,k3 < Length(s):
                                                                                                                     3        eÀú   := GenerateStr(,s[k : k ]); eÀú := GenerateStr(,s[k : k ]);
                                                                                                                                1                                        1      2          2                                        2      3
                          GeneratePartition(S: Set of (,s) pairs)                                                   4        eÀú := Unify(eÀú ,eÀú );
                                                                     ‚Ä≤    ‚Ä≤                                     ‚Ä≤                                   1    2
                         1 while exists (Àú,eÀú),(Àú ,eÀú ) ‚àà T s.t. Comp(eÀú,eÀú ) 5                                             if ([[Loop(w : eÀú)]] = {s[k : k ]}) for some k
                                                                                                                                                                             1      4                            4
                         2        Let (Àú ,eÀú ),(Àú ,eÀú ) ‚àà T be s.t. CS(eÀú ,eÀú )                                                       ‚Ä≤                           ‚Ä≤
                                              1     1       2     2                                    1    2        6              W(‚ü®k ,k ‚ü©) := W (‚ü®k ,k ‚ü©)‚à™{Loop(w : eÀú)};
                                                                                                                                              1     4                     1     4
                                                                                             is largest. 7 return W‚Ä≤;
                         3        T := T ‚àí{(Àú ,eÀú ),(Àú ,eÀú )}‚à™
                                                         1    1        2     2
                                                             {(Àú ‚à™Àú ,Intersect(eÀú ,eÀú ))}; GenerateSubstring(: Input state, s: String)
                                                                   1       2                        1     2
                         4 return T;                                                                                 1 result := ‚àÖ;
                                                                                                                     2 foreach (i,k) s.t. s is substring of (v ) at position k
                                                                                                                                                                                                       i
                                                                                                                     3        Y :=GeneratePosition((v ),k);
                          GenerateBoolClassifier(Àú ,Àú : Set of inputs)                                                        1                                               i
                                                                          1     2                                    4        Y :=GeneratePosition((v ),k+Length(s));
                         1 Àú‚Ä≤ := Àú ; b := false;                                                                              2                                               i
                              1          1                                                                           5        result := result‚à™{SubStr(vi,Y1,Y2)};
                         2 while (Àú‚Ä≤ ‚àï= ‚àÖ)
                                            1                                                                        6 return result;
                         3        OldÀú‚Ä≤ := Àú‚Ä≤;
                                          1          1
                         4        Àú‚Ä≤ := Àú ; Àú‚Ä≤‚Ä≤ := Àú‚Ä≤; d := true;
                                    2          2       1          1                                                  GeneratePosition(s: String, k: int)
                         5        while (Àú‚Ä≤ ‚àï= ‚àÖ)                                                                   1 result := {CPos(k),CPos(-(Length(s)-k)};
                                                  2
                         6              OldÀú‚Ä≤ := Àú‚Ä≤;                                                               2 foreach r =TokenSeq(T ,‚ãÖ‚ãÖ,T ) matching s[k : k-1] for some k :
                                                2          2                                                                              1                        1         n                            1                                  1
                         7              Preds := {Match(v ,r,c),¬¨Match(v ,r,c) ‚à£                                                                                       ‚Ä≤         ‚Ä≤
                                                                        i                           i                3      foreach r =TokenSeq(T ,‚ãÖ‚ãÖ,T ) matching s[k : k ] for some k :
                                                                                                                                              2                        1         m                                  2                        2
                                                          [[Match(v ,r,c)]], ‚àà Àú ‚à™ Àú };                                                                                      ‚Ä≤        ‚Ä≤
                                                                          i                        1       2         4            r     := TokenSeq(T ,‚ãÖ‚ãÖ,T ,T ,‚ãÖ‚ãÖ,T );
                                                                                                  ‚Ä≤‚Ä≤    ‚Ä≤                           12                           1         n     1        m
                         8              Let  ‚àà Preds be s.t. CSP(,Àú ,Àú )                                                                                                                   t‚Ñé
                                                                                                  1     2            5            Let c be s.t. s[k : k ] is the c                                  match for r                 in s.
                                                                                                                                                                   1      2                                               12
                                                                                          is largest.                6            Let c‚Ä≤ be the total number of matches for r                                                in s.
                         9              d := d ‚àß ;                                                                                                                                                                     12
                                                                                                                     7            rÀú   := generateRegex(r ,s);
                       10               Àú‚Ä≤‚Ä≤ := Àú‚Ä≤‚Ä≤ ‚àí {          ‚à£  ‚àà Àú‚Ä≤‚Ä≤,¬¨[[]] };                                            1                                     1
                                          1          1           1      1        1             1                     8            rÀú   := generateRegex(r ,s);
                                           ‚Ä≤         ‚Ä≤                          ‚Ä≤                                                   2                                     2
                       11               Àú   := Àú ‚àí{ ‚à£  ‚àà Àú ,¬¨[[]] };                                                                                                                         ‚Ä≤
                                          2          2          2      2        2             2                      9            result := result‚à™{Pos(rÀú ,rÀú ,{c,-(c -c+1)})};
                                                        ‚Ä≤         ‚Ä≤                                                                                                              1    2
                       12               if (OldÀú = Àú ) then FAIL.
                                                        2        2                                                 10 return result;
                       13         Àú‚Ä≤ := Àú‚Ä≤ ‚àí Àú‚Ä≤‚Ä≤; b := b ‚à® d;
                                    1          1        1
                       14         if (OldÀú‚Ä≤ = Àú‚Ä≤) then FAIL.                                                      generateRegex(r: Regular Expression, s: String)
                                                  1        1
                       15 return b;                                                                                   let r be of the form TokenSeq(T ,‚ãÖ‚ãÖ,T ).
                                                                                                                                                                                     1        n
                                                                                                                      return TokenSeq(IParts (T ),‚ãÖ‚ãÖ,IParts (T ));
                                                                                                                                                                  s     1                    s    n
                                            Figure 7. Algorithm for learning string programs that are consistent with a given set S of input-output examples.
                        4.5.1      Learning Partitions                                                                                        It would be computationally expensive to try out all possible
                        In this section, we discuss how to appropriately classify the input-                                             partitioning choices and select the one that contains smallest num-
                        output examplesintodifferent partitions - the idea being that exam-                                              ber of partitions. We present a partitioning algorithm (based on
                        ples that end up in the same partition are those that require similar                                            greedy algorithmic design pattern) that is not only efÔ¨Åcient, but in
                        computational processing. We attempt to achieve this by requiring                                                practice, yields the smallest number of partitions.
                        the partitioning to satisfy the following two properties.                                                             The algorithm for learning partitions is described in procedure
                         ‚àô Utility: For each partition, there is at least one trace expression                                           GeneratePartition in Figure 7. We start with singleton parti-
                             e that is consistent with all examples in that partition.                                                   tions that contain one input each, along with associated trace sets.
                         ‚àô Minimality:Numberofpartitionsshouldbeassmallaspossible.                                                       Wethenmergetwopartitionsonlyiftheirassociatedtracesetshave
                                                                                                                                         at least one trace expression in common.(Thiscriterionleadstosat-
                        Observe that the utility requirement can be satisÔ¨Åed trivially on                                                isfaction of the utility requirement). We refer to such trace sets as
                        its own by placing each example in its own partition, but then it                                                being compatible with each other.
                        would not lead to any generalization, which in turn would not lead
                                                                                                                                                                                                                           Àú          Àú
                                                                                                                                         DEFINITION 3 (Compatible). We say that trace sets e and e are
                        to any convergence. The minimality requirement can be satisÔ¨Åed                                                                                                                                      1           2
                                                                                                                                                                                                            Àú Àú
                                                                                                                                         compatible with each other, denoted Comp(e ,e ), if
                        trivially on its own by placing all examples in the same partition,                                                                                                                   1    2
                        but it may lead to failure because there might not be any trace                                                                                         def
                                                                                                                                                                  Àú Àú                                        Àú Àú
                                                                                                                                                       Comp(e ,e )               = Intersect(e ,e ) ‚àï= ‚àÖ
                        expression that can express the transformation for all the examples.                                                                        1    2                                     1    2
                        It is the combination of these two requirements that leads to faster                                             Often there are multiple choices of pairs of partitions that can
                        successful convergence.                                                                                          be merged with each other. We select a pair that has the highest
                         compatibilityscore.Thecompatibilityscoreisdesignedtofacilitate                                                        d, but several inputs in Àú‚Ä≤ do. Àú‚Ä≤ is that monotonically decreasing
                                                                                                                                                                                        1           1
                         partitioning decisions that, at least in practice, lead to the smallest                                               subset of inputs from Àú that are not yet covered by the disjunctive
                                                                                                                                                                                     1
                         number of partitions. The compatibility score has two components                                                      booleanformulablearnedsofar.Theloopinline2isrepeateduntil
                         CS andCS .                                                                                                            Àú‚Ä≤ becomes empty (or it does not change).
                             1             2                                                                                                      1
                              CS1 measures agreement of two partitions with respect to the                                                           The loop in line 5 identiÔ¨Åes a new predicate  in each iteration
                         compatibility of their trace sets and their intersection with all other                                               with the property that several inputs in Àú‚Ä≤‚Ä≤ satisfy , but several
                                                                                                                                                                 ‚Ä≤                                                  1                                    ‚Ä≤‚Ä≤
                                                                                            Àú           Àú
                         trace sets. In particular, if two trace sets e                          and e are both com-                           inputs in Àú         donotsatisfy , and then adds it to the conjunct d. Àú
                                                                                              1           2                                                      2                                                                                       1
                                             Àú                                        Àú Àú                                                      and Àú‚Ä≤ are both those monotonically decreasing subsets of Àú‚Ä≤ and
                         patible with e , and so is Intersect(e ,e ), then we bump up the
                                               3                                        1     2                                                          2                                                                                        1
                                                              Àú           Àú                                          Àú           Àú
                         compatibility score of e and e . Also, if two trace sets e and e                                                      Àú    respectively that satisfy the conjunct d built so far. Àú                                  is used
                                                                1           2                                          1           2              2                                                                                          2
                                                                         Àú
                         are both not compatible with e3, then we bump up the compatibil-                                                      to decide whether or not the loop in line 5 needs to be iterated any
                                            Àú           Àú                                                                                                                 ‚Ä≤‚Ä≤                                  ‚Ä≤
                         ity score of e and e . Note that in either of above-mentioned two                                                     further, while Àú             is used to update Àú , which is required for the
                                              1           2                                                                                                               1                                   1
                                                              Àú         Àú                            Àú
                         cases, the potential of e                 or e to merge with e is unchanged as                                        loop in line 2. Hence, the following theorem holds.
                                                                1         2                            3
                                                                         Àú           Àú
                         a result of the intersection of e and e . The idea is to select those
                                                                           1          2                                                         THEOREM2. IfGenerateBoolClassifier(Àú ,Àú )doesnotfail
                         partitions for merging that keep alive merging potential with other                                                                                                                                 1     2
                                                                                                                                               and returns a boolean condition b, then all inputs in Àú                                       satisfy b
                         partitions in a later step, resulting in a smaller number of overall                                                                                                                                             1
                                                                                                                                               and none of the inputs in Àú satisfy b.
                         partitions.                                                                                                                                                       2
                              CS2 is used to produce a Ô¨Åner score in case there are ties on                                                    To ensure learning of small boolean formulas, we ensure that the
                         the CS score. It gives preference to those pairs of trace sets whose
                                   1                                                                                                           predicate  that is chosen at Line 8 is such that
                         relative size after intersection is largest. The idea is that a larger                                                  ‚àô several inputs in Àú‚Ä≤ do not satisfy . This keeps Àú‚Ä≤ smaller,
                         trace set is more likely to merge with other trace sets in a later step,                                                                                   2                                                      2
                         resulting in a smaller number of overall partitions.                                                                        which helps to terminate the inner loop at Line 5 faster, which
                                                                                                                                                     leads to conjuncts d containing small number of predicates.
                                                                                               Àú           Àú                                     ‚àô several inputs in Àú‚Ä≤‚Ä≤ satisfy . This keeps Àú‚Ä≤‚Ä≤ larger, which helps
                         DEFINITION 4 (Compatibility score). Let e and e be two com-
                                                                                                1            2                                                       ‚Ä≤            1                                       1
                                                                                           Àú                 Àú                                       to keep Àú         smaller, which in turn helps to terminate the outer
                         patible trace sets drawn from a set T = {e                                 , . . . , e      }oftrace                                       1
                                                                                             (1)              (n)                                  loop in Line 2 faster, which leads to fewer number of conjuncts.
                                                                                            Àú           Àú
                         sets. We deÔ¨Åne the compatibility score of e and e with respect to
                                                                                              1           2
                                                      Àú Àú
                         T, denoted by CS(e ,e ,T) as:
                                                        1     2                                                                                To enable a selection that satisÔ¨Åes above-mentioned criterion, we
                                           Àú Àú                 def                Àú Àú                       Àú Àú                                choose a predicate with highest classiÔ¨Åcation score (as deÔ¨Åned
                                     CS(e ,e ,T)                = (CS (e ,e ,T),CS (e ,e ))                                                                                                         ‚Ä≤‚Ä≤           ‚Ä≤
                                             1     2                           1    1     2             2     1    2                           below) with respect to the sets Àú                      and Àú .
                                                                                                                                                                                                    1           2
                         where CS and CS are deÔ¨Åned as follows:
                                        1             2                                                                                         DEFINITION 5 (ClassiÔ¨Åcation Score of a Predicate). Giventwosets
                                                def           X                                                                                of inputs Àú        andÀú , and a unary predicate  over inputs, we deÔ¨Åne
                                Àú Àú                                              Àú Àú Àú                                                                           1           2
                        CS (e ,e ,T) =                                       z(e ,e ,e )
                            1     1    2                                           1    2     k                                                the classiÔ¨Åcation score of , denoted by CSP(,Àú ,Àú ), as:
                                                      Àú                                                                                                                                                                        1      2
                                                      ek‚ààT,k‚àï=1,k‚àï=2                                                                                                        def
                                                    ‚éß                                                                                           CSP(,Àú ,Àú )               = Size({ ‚à£ ‚ààÀú ,[[]] })√ó
                                                    Ô£¥                            Àú Àú                        Àú Àú                                               1     2                              1      1         1           1
                                                       1 if (Comp(e ,e ) = Comp(e ,e )
                                                    ‚é®                              1    k                     2     k                                                                                    Size({ ‚à£  ‚àà Àú ,¬¨[[]] })
                             Àú Àú Àú                                                                                                                                                                                    2       2        2              2
                          z(e ,e ,e ) ‚â°                                                                       Àú Àú Àú
                               1     2    k                               =Comp(Intersect(e ,e ),e ))
                                                    Ô£¥                                                           1     2      k
                                                    ‚é©                                                                                          4.6       Correctness
                                                       0 otherwise
                                                                                                                                               If procedure GenerateBoolClassifierdoesnotfail,thesynthe-
                                                                                                       Àú Àú
                                                                def        Size(Intersect(e ,e ))
                                                 Àú Àú                                                     1     2                               sis algorithm succeeds. In that case, the following theorem holds.
                                         CS (e ,e )              =
                                             2     1    2                                   Àú               Àú
                                                                           Max{Size(e ),Size(e )}
                                                                                              1               2                                                                                              Àú
                                                                                                                                                THEOREM3 (Soundness). The set P of string expressions re-
                              Comparison on compatibility scores (x,y), which are pairs of                                                     turned by GenerateStringProgram({( ,s )} ) are all consis-
                         numbers, is deÔ¨Åned using lexicographic ordering, i.e.,                                                                                                                                      i    i    i
                                                                                                                                               tent with each input-output pair ( ,s ), i.e.,
                                                                                                                                                                                                        i    i
                                                             def                                                                                                                        Àú
                         (x ,y ) > (x ,y )                    = (x >x ) ‚à® (x =x ‚àß y >y )                                                                                     ‚àÄP ‚ààP ‚àÄi: ([[P]] ) = s
                             1     1            2    2                     1         2             1         2          1        2                                                                                i         i
                              Werepeat the merging process one by one until no more parti-                                                     The proof of theorem 3 follows from similar soundness properties
                         tions can be merged.                                                                                                  of the involved procedures, of which the most interesting one has
                                                                                                                                               been stated in Theorem 2.
                         4.5.2       Learning ClassiÔ¨Åers for Partitions                                                                         CONJECTURE 1 (Completeness). If there exists a string expres-
                         In this section, we discuss how to generate classiÔ¨Åers for the vari-                                                  sion in our language that is consistent with the given set of input-
                         ous partitions generated using the algorithm GeneratePartition                                                        output pairs, the algorithm produces one.
                         described above. A classiÔ¨Åer for a partition is a boolean condition                                                   The above conjecture is true at the level of traces, i.e., if there ex-
                         (over the set of predicates in our language) that returns true for all                                                ists a consistent trace expression (satisfying the restriction A2 in
                         inputs in the partition and returns false for all inputs not in that                                                  Theorem 1), then the algorithm generates it. However, the above
                         partition. We attempt to learn not just any classiÔ¨Åer, but a simple                                                   conjecture may not be true in general. In practice though, we have
                         (small-sized) one.                                                                                                    observed our partitioning and classiÔ¨Åcation procedures to always
                              Given a set of predicates, one simple approach can be to enu-                                                    work, and it appears that there are some interesting theoretical
                         merate boolean formulas of increasingly large sizes and check if it                                                   properties of these procedures that might pave the way for proving
                         can act as a classiÔ¨Åer for some partition. However, this approach                                                     the above conjecture under some general conditionals. This inves-
                         would be computationally expensive. We present a classiÔ¨Åer learn-                                                     tigation is left for future work.
                         ing algorithm (based on greedy algorithmic design pattern) that is
                         not only efÔ¨Åcient, but in practice, yields smallest classiÔ¨Åers.                                                       4.7       Discussion
                              The algorithm for learning classiÔ¨Åers is described in procedure                                                  4.7.1        Adaptability to Language Extensions
                         GenerateBoolClassifier in Figure 7. We learn a boolean clas-
                         siÔ¨Åer in DNF form. The loop in line 2 learns a new conjunct d in                                                      Thealgorithmcanbeeasilyadaptedtodealwiththefollowinglan-
                         eachiteration with the property that none of the inputs in Àú satisfy                                                 guage extensions. The choice of tokens/predicates can be enriched
                                                                                                                       2
                arbitrarily as long as they can be efÔ¨Åciently enumerated. The choice       gorithm classiÔ¨Åes an input-output example as a potentially-noisy if
                of regular expressions is inextensible for reasons mentioned earlier.      the input belongs to a singleton partition, but the boolean classiÔ¨Åca-
                Thesubstring construct can be extended further to allow for a con-         tion scheme fails to generate a boolean classiÔ¨Åer for that singleton
                stant index offset into the current choice of substrings. The loop         partition. For each potentially-noisy example,thealgorithmignores
                construct can be enriched to allow for termination conditions based        the corresponding partition, and re-learns the boolean classiÔ¨Åcation
                onposition logic or conjunctions of predicates.                            scheme for other partitions. If it succeeds, it classiÔ¨Åes the example
                   It may be possible to nest conditionals inside loops. The key           as noisy and presents that to the user for validation, and can even
                algorithmic idea would be to recursively perform partitioning and          suggest a Ô¨Åx by running the learned program on the input corre-
                classiÔ¨Åcation, as is done at the top-level, instead of a simple uniÔ¨Å-      sponding to the noisy example.
                cation. However, performance may be a concern.
                4.7.2   General Principles                                                 EXAMPLE11. Consider the following set of examples provided to
                Here, we summarize some key general principles of our learn-               our tool in one of the scenarios, in which the user failed to spell
                ing algorithm. The algorithm Ô¨Årst learn traces and then infer              Kimberly correctly in the output column.
                loops/conditionals. This is unlike recent work on more-general                            Input v      Input v    Output
                program synthesis techniques (e.g., [19]) that attempt to learn ev-                              1            2
                erything at the same time, often leading to unscalablility.                               Otis         Daniels     Otis, D.
                   For learning conditionals, the algorithm uses a greedy strat-                          Kimberly     Jones       Kimberley, J.
                egy based on scoring functions to Ô¨Årst infer partitioning and then                        Mary         Leslie      Mary, L.
                boolean classiÔ¨Åcation. The standard way to learn conditionals in
                recent program synthesis work is to phrase this as a combinatorial         The GeneratePartition algorithm groups the Ô¨Årst and third ex-
                search problem (using SAT/SMT solvers), which leads to solutions           ample in one partition, while the second example belongs to a
                that may not scale in real-time settings like ours.                        singleton partition. The GenerateBoolClassifier algorithm
                   Forlearningtraces,thealgorithmusesDAGbaseddata-structures               fails to generate a boolean classiÔ¨Åcation scheme that distin-
                that canrepresentandmanipulate(intersection,evaluation,size/rank           guishes the two partitions. Ignoring the singleton partition enables
                computation) huge sets of programs. This approach would work in            GenerateBoolClassifier algorithm to succeed trivially (since
                general for any term algebra. The DAG based data-structure can be          there is only one partition). The algorithm declares the second
                likened to BDDs, which can succinctly represent and manipulate             example to be noisy and asks the user to investigate if she really
                (conjunction, disjunction, negation) huge sets of program states,          meant ‚ÄúKimberly, J.‚Äù (which it generates by running the learned
                and are popular in the veriÔ¨Åcation community.                              program on the noisy input).
                5.   Usability Extensions                                                  5.3   RankingofMultipleSolutions (for faster convergence)
                5.1   Active Interaction Model (for easier interaction)
                A simple interaction model can be to ask the user to investigate           Selecting an expressive language for inductive program synthesis
                the results of a synthesized program on other inputs in the spread-        systems raises an interesting dilemma. While it makes users who
                sheet and to report any discrepancy. However, this may be cum-             wanttoprogramsophisticatedtaskshappy,itmayadverselyimpact
                bersome in case of large spread-sheets. To enable easier interac-          users who want to program simple tasks but now may require
                tion, we exploit the fact that our synthesis algorithm returns a set       to provide more bits for disambiguation of their intent (which
                              Àú                                  Àú                         manifests in the need to provide more examples and more rounds
                of programs P. The synthesis system can run P on every input              of interaction). The Occam‚Äôs razor principle, which states that the
                in the spreadsheet to generate a set of corresponding outputs sÀú, i.e.,    simplest explanation is usually the correct one, comes to our rescue
                                    Àú
                sÀú = {[[P]] ‚à£ P ‚àà P}. The set sÀúcan be computed directly without          here. We deÔ¨Åne a comparison scheme between different string
                                                          Àú
                explicitly enumerating all programs in P. (This requires exploit-          expressions by deÔ¨Åning a partial order between them. Some of
                ing the structural decomposition of the underlying data-structures         these choices are subjective, but have been observed to work well.
                as is done in Intersect and Size methods - we leave out details            (There is also a fascinating prospect of personalizing this partial
                for lack of space.) The synthesis system can then highlight any in-        order based on the user intent observed during last few scenarios).
                put (for user inspection) whose corresponding output set contains              A Concatenate constructor is simpler than another one if it
                at least two strings. We refer to this as the active interaction model.    contains smaller number of arguments or its arguments are pair-
                   It is interesting to compare the above idea with the idea of            wise simpler. Similarly for TokenSeq constructor. StartTok and
                distinguishing inputs that was introduced recently in the context          EndTokaresimplerthanallothertokens(suggestingthatextraction
                of synthesis of bit-vector algorithms [8]. An application of that idea     logics based on the start/end of strings are more common). A
                in our context would mean picking any two (semantically different)         token corresponding to a character class is simpler than the one
                                 Àú
                programs from P and then synthesizing an input on which the two            corresponding to a smaller character class. (We favor generality
                programs yield different outputs. Such an approach would not be            here.) Pos expressions are simpler than CPos expressions (i.e., we
                effective in our setting since, as is illustrated by the case-study in     give less preference to extraction logics based on constant offsets).
                Example 1, convergence does not require to narrow the choice of            ASubStr constructor is simpler than both ConstStr constructor
                consistent programs down to a semantically unique program in the           (it is less likely for constant parts of an output string to also occur
                language. It is sufÔ¨Åcient to narrow the choice down to that set of         in the input) and Concatenate constructor (if there is a long
                consistent programs that are equivalent with respect to the Ô¨Ånite          substring match between input and output, it is more likely that the
                numberofinputs in the spreadsheet.                                         correspondingpartoftheoutputwasproducedbyasinglesubstring
                5.2   Noise Handling                                                       extraction logic).
                                                                                               Procedures generateRegex, GenerateLoop, GenerateStr,
                Thealgorithm declares failure when it fails to learn a boolean clas-       GeneratePosition, and GenerateSubstring, which generate
                siÔ¨Åcation scheme. In that case, it can attempt to identify any noise       a set of solutions, can take this ordering into account to produce an
                (inadvertent error in one input-output example) as follows. The al-        ordered set of solutions.
                 6.    Prototype Tool                                                            NumberofInteractiveRounds:           Thisisameasureofthegeneral-
                 We have built the program synthesis system described in this pa-                ization power of the conditional learning part of the algorithm and
                 per as an add-in, called QuickCode, for Microsoft Excel 2010. Mi-               the ranking scheme. We observed that the tool typically requires
                 crosoft Excel is the most popularly used spreadsheet system in the              just one round of interaction, when the user is smart enough to give
                 worldandiswidelyregardedtobetheswissarmyknifeofallbusi-                         an example for each input format (which typically range from 1 to
                 nesses.                                                                         3) to start with. It is heartening to note that this was indeed the case
                     The program synthesis system has two components: (a) the                    for most scenarios in our benchmarks, even though our algorithm
                 algorithm described in Section 4, which has been implemented                    canfunctionrobustlywithoutthisassumption.Themaximumnum-
                 in C# (it is less than 5000 lines of code), and (b) the usability               ber of interactive rounds required in any scenario was 4 (with 2 to 3
                 extensions described in Section 5, which are supported using a                  being a more typical number). The maximum number of examples
                 simple, but cool, graphical user interface described below.                     required in any scenario over all possible interactions was 10.
                 6.1   UserInterface                                                             Success Ratio:     We have not come across any problem instance
                 TheuserÔ¨Årstselectsarectangularregionofspreadsheetcontaining                     that can be expressed in our language, but our algorithm fails to
                 both input and output columns. We treat the mostly populated                    convergetothecorrectsolution. This is a measure of the validity of
                 columns as input columns, and less populated columns as output                  the completeness hypothesis discussed in Section 4.6.
                 columns. However, we also provide the Ô¨Çexibility for the user                      However, we have found several problem instances that cannot
                 to select multiple column ranges and identify explicitly which                  beexpressedinourlanguage.Mostoftheseinstancesarerelatedto
                 columnsareinputsandwhichcolumnsareoutputs(sinceitmaybe                          semantic entity reasoning (such as transforming dates into day of
                 the case that most cells in an input column have null entries, while            the week). For syntactic string manipulation tasks, we have been
                 our default treatment would be to regard it as an output column).               more than pleasantly surprised at the expressiveness of our lan-
                 Wetreattherowsthatcontainentriesforanoutputcolumnasinput-                       guage. Few testing moments came in the middle of some internal
                 output examples for the program to be learned for that column.                  demostolargeaudiences,wherewewereaskedtotryoutmodiÔ¨Åed
                     The user then presses the QuickCode button. The system then                 scenarios on the spot (on real spreadsheet data). The tool success-
                 populates the spreadsheet as follows. It invokes the synthesis algo-            fully learned the desired transformations in all those cases.
                 rithm (procedure GenerateStringProgram) for each of the out-                       Following are a few examples of scenarios where QuickCode
                 put column. For each output cell        (in row r and output column
                                                       r,c                                       was used by fellow colleagues to perform tasks beyond the imagi-
                 c), the system runs the generated set of programs for output column             nation of the author.
                 contheinputstatespeciÔ¨ÅedinrowrtogenerateanorderedsetsÀúof
                 possible outputs. The system populates the cell r,c as follows:
                  ‚àô If sÀú contains one string (the most common case), the system                 EXAMPLE12 (Synthesisofpartofafutureextension of itself).
                    populates the cell with that string.                                         The synthesis system is currently being extended with semantic
                  ‚àô If sÀúcontains multiple strings, the system populates the cell with           knowledge of common entities that would allow the system to per-
                    the Ô¨Årst string (top ranked solution), but highlights it to point out        form transformations that are beyond the realm of syntactic com-
                    to the user that there are multiple computational interpretations            putations. One of the dictionaries that was recently added to the
                    of the few examples provided by the user, and that the user may              system was mapping from a country‚Äôs international dialing code to
                    want to investigate the output of the highlighted cell.                      the name of that country. Rishabh Singh performed this task, which
                  ‚àô If sÀú is empty, the system populates the cell with ?? to draw the            he originally thought would take around an hour (in absence of
                    attention that the user should provide the output for that cell.             any scripting), in less than a minute using the QuickCode add-in
                                                                                                 (after copying and pasting the data from Wikipedia into an Excel
                     The user may then (repeatedly) Ô¨Åx contents of any cell by                   spreadsheet).
                 right-clicking on it, wherein a dialog box opens up that allows the
                 user to choose from other strings in the corresponding sequence                         Input v     Input v      Output
                 sÀú, or to provide a new output altogether. After any such Ô¨Åx, the                              1            2
                 above learning process is automatically repeated with the extended                      Albania     355           case 355: return ‚ÄúAlbania‚Äù;
                 set of input-output examples, and the contents of spreadsheet are                       Algeria     213           case 213: return ‚ÄúAlgeria‚Äù;
                 automatically updated to reÔ¨Çect the new learned results.
                                                                                                 String Program:
                 6.2   Evaluation Metrics                                                        Concatenate(ConstStr(‚Äúcase ‚Äù),v2,ConstStr(‚Äú: return ‚Äú‚Äù),
                 Our synthesis system can be evaluated against several metrics                                    v1,ConstStr(‚Äú‚Äù;‚Äù))
                 stated below.                                                                   The above examples were sufÔ¨Åcient for QuickCode to populate
                                                                                                 the spreadsheet with the desired output for more than 200 rows,
                 Algorithmic Performance:        This is a measure of the effectiveness          each containing data for a different country. The resultant code-
                 of the data-structures used by the algorithm. The algorithm was                 fragment in the output column was copied and pasted in Visual
                 timed to take less than 0.1 seconds on average for a varied bench-              Studio Development Environment as part of a switch statement,
                 mark suite of more than 100 problem instances drawn from online                 and it compiled!
                 help forums or obtained from Excel product team as representative
                 examples.(Theexamplesdescribedinthispaperformarepresenta-
                 tive part of this benchmark suite.) Each problem instance contained             EXAMPLE13 (Filtering Task). Ben Zorn wanted to estimate the
                 upto10input-output pairs (more than what the user would want to                 total number of page-hits to links in the pictures directory from
                 provide in any scenario) and each string in any pair contained up               weekly statistics consisting of pairs of links and page-hits. He tried
                 to 100 characters (more than what is typical of spreadsheet cells).             to use the QuickCode add-in by giving examples where the output
                 Experiments were performed on a machine with Intel Core-2-Duo                   column was a copy of the input page-hit column only if the input
                 2.8 GHz CPU, and 4 GB RAM.                                                      link column contained ‚Äúpictures‚Äù in the path.
                   Input v                                             Input v    Output         in spreadsheets. Hence, it cannot be applied for the processing re-
                          1                                                   2                  quired in Examples 7, 8, 9, 10, 13. Also, its cursor movement logic
                   /um/people/sumitg/pictures/lake-tahoe/index.html    192         192           is restricted to positions either before or after the kt‚Ñé occurrence
                   /um/people/sumitg/index.html                        104         0             of a single token, while scanning from left side. In contrast, our
                   /um/people/sumitg/pubs/speed.html                   16          0             position extraction logic is much more powerful - it allows to iden-
                   /um/people/sumitg/pubs/popl10 synthesis.pdf         13          0             tify positions based on kt‚Ñé occurrence of sequences of tokens both
                   /um/people/sumitg/pictures/verona/index.html        7           7             before and after the desired position, while scanning from left or
                   /um/people/sumitg/pictures/kerela/target21.html     3           3             right side. As a result, the SMARTedit system cannot be applied
                 Quite surprisingly for the author, the QuickCode add-in worked                  for processing required in Examples 1, 3, 5, and 14. (b) More sig-
                 successfully (without use of its hidden capability of being able to             niÔ¨Åcantly, as for any PBD system, the user is required to provide a
                 addnewtokens-additionof‚Äúpictures‚Äùtokenwouldhavedonethe                          complete demonstration or trace, where the demonstration consists
                 trick). Closer investigation of the generated program revealed an-              of a sequence of the editor state after each primitive action, really
                 other trick for solving the same problem: all (and only) ‚Äúpictures‚Äù             spelling out how to do the transformation, but on a given exam-
                 links had6occurrencesofthebackslashtoken-apatternthatcould                      ple. The user is also required to segment each iteration of an inner
                 not have been easy for the user to discover.                                    loop. Further, PBD based systems also have the drawback of being
                 String Program:                                                                 sensitive to the order in which the user chooses to perform actions.
                 Switch((b ,v ),(b ,ConstStr(0))), where                                         Our system is based on Programming by Example (as opposed to
                             1   2     2                                                         Demonstration) - it requires the user to only provide the Ô¨Ånal state
                 b1 ‚â° Match(v1,SlashTok,6), and b2 ‚â° ¬¨Match(v1,SlashTok,6).                      (as opposed to also providing the intermediate states). This ren-
                 EXAMPLE14 (ArithmeticTask). The synthesis engine currently                      ders our system much more usable [10], however, at the expense of
                 does not support any arithmetic reasoning. Hence, we thought that               makingthelearning problem much more difÔ¨Åcult, for which we do
                 a few examples found on Excel help forums, asking for computing                 present an effective algorithm.
                 thesumofallnumbersinastring,hadtowait.However,BillHarris                            TELS [22] is another PBD system that records high-level ac-
                 showedusacutetrick that almost did it.                                          tions similar to the actions used in SMARTedit, and implements a
                          Input v                                   Output                       set of heuristics/expert rules for generalizing the arguments of each
                                  1                                                              of the actions. However, TELS‚Äôs dependence on heuristic rules to
                          Alpha 10 Beta 20 Charlie 30 Delta          10+20+30                    describe the possible generalizations makes it difÔ¨Åcult to under-
                          POPL9CAV7PLDI6ESOP4                        9+7+6+4                     stand the hypothesis space clearly, as well as to imagine applying
                 String Program:                                                                 it to the different domain of spreadsheet applications.
                 Concatenate(Loop(w : Concatenate(SubStr(v ,p ,p ),                                 Simultaneous editing [15] is another PBD-like system that al-
                                                                           1   1   2             lows the user to deÔ¨Åne a set of regions to edit, and then allows the
                                                                ConstStr(‚Äú+‚Äù))),                 user to make edits in one, while the system makes equivalent edit-
                                  SubStr2(v1,NumTok,‚àí1))                                         ing in all other records. The inference used in simultaneous editing
                 where p1 ‚â° Pos(,NumTok,w) and                                                  is muchlesspowerfulsinceitdoesnotsupportconditionalorloopy
                 p2 ‚â° Pos(NumTok,TokenSeq(NonDigitTok,NumTok),w).                                edits (every editing action is applied uniformly to every record).
                     It is interesting to note above how the loop constructor gets used          Text-editing using Examples        Nixdescribedatext-editingsystem
                 to print all, but last, numbers, each followed by a plus sign (The              that synthesizes gap programs based on examples [17]. A gap
                 position expression p ensures that there better be another number
                                        2                                                        program is a collection of (pattern, replacement) pairs, where each
                 following the number to be extracted). The last integer is then                 pattern is composed of constants and variables that bind to the
                 concatenated separately. (The desired sum can now be obtained                   text in between the constants, and a replacement can be a constant
                 by formatting the output column as a number inside Excel.)                      string or a variable from the input pattern. Gap programs are not
                 7.    Related Work                                                              expressive enough to represent the solution of most of the string
                                                                                                 processing benchmark examples described in this paper.
                 Work on learning concepts such as deterministic Ô¨Ånite state au-                 Data Processing for Programmers            The PADS project has en-
                 tomata [1], or regular transducers [20] from examples is not appli-             abled simpliÔ¨Åcation of ad hoc data processing tasks for program-
                 cable in our setting because it requires making many more queries               mersbycontributingalongseveraldimensions:developmentofdo-
                 to the user, and most string processing tasks described in this paper           main speciÔ¨Åc languages for describing text structure or data for-
                 are more expressive than what can be expressed by these concepts.               mat[2,3],learning algorithms for automatically inferring such for-
                     Themostcloselyrelated work is that of automating text-editing               mats[4],andamarkuplanguagetoallowuserstoaddsimpleanno-
                 using demonstrations or examples. These text-editor techniques                  tations to enable more effective learning of text structure [23]. The
                 may be lifted to the spreadsheet setting, but they would not work               learned format can then be used by programmers for documenta-
                 well because (a) the real spreadsheet scenarios are more challeng-              tion or implementation of custom data analysis tools. In contrast,
                 ing than what these techniques can handle, (b) the PBD interface,               the focus of this paper is to enable end-users (non-programmers)
                 inherenttomostofthesetechniques,requiresuserstoprovidemuch                      to perform small, often one-off, repetitive tasks on their spread-
                 more information that is way beyond the usability bar in spread-                sheet data. Asking end-users to provide annotations for learning
                 sheets. We explain these issues below.                                          (relatively simple) text structure, and then develop custom tools to
                 Text-editing using Demonstrations          SMARTedit [11] is a Pro-             format/processtheinferredstructureiswayabovetheexpertiseand
                 gramming by Demonstration (PBD) system for learning text-                       usability bar for these users. Hence, we are interested in automating
                 editing commands, where the primitive program statements in-                    the entire end-to-end process, which includes not only learning the
                 clude moving the cursor to a new position and inserting/deleting                text structure from the inputs, but also learning the desired trans-
                 text. However, there are two signiÔ¨Åcant differences: (a) The lan-               formation from the outputs.
                 guage of programs considered is not as expressive as required in                Algorithmic Techniques         [6] provides a good survey of various
                 the spreadsheet setting. In particular, it does not provide support             program synthesis techniques: exhaustive search, logical reason-
                 for conditionals, which are very important for data cleansing tasks             ing, probabilistic inference, and version-space algebras. Exhaus-
                tive search based techniques would not scale for our problem set-          such a ‚Äúmagical‚Äù technology can ever be possible. Thanks to Piali
                ting since the underlying state space (even for programs of small          Choudhury for building a cool UI for the tool. Thanks to Bill
                boundedsize)is huge. Logical reasoning techniques (such as those           Harris and Rishabh Singh for adding new features and taking the
                usedinlearningstraight-linebit-vectorprogramsfrominput-output              technology to another level, details of which are beyond the scope
                examples [8], or loopy programs from logical speciÔ¨Åcations [19])           of this paper. Thanks to Ras Bodik, Venkie, and David Walker for
                are not suited for various reasons: they are not as scalable (several      useful discussions. Finally to my Excel-literate parents and spouse
                minutes are acceptable for discovering a new bit-vector algorithm,         for the best (tear-rendering) compliment after playing with the tool:
                but not for an interactive spreadsheet session); they cannot deal          ‚ÄúFor the Ô¨Årst time, we understand what your research is about‚Äù.
                with noise in the user input; they cannot easily compute all solu-
                tions (required for providing various computational interpretations        References
                to the user for an ambiguous input).                                        [1] D. Angluin. Learning regular sets from queries and counterexamples.
                   The GenerateStr part of the synthesis algorithm presented in                 Inf. Comput., 75(2):87‚Äì106, 1987.
                this paper is closest to the version-space algebra approach that in-        [2] K. Fisher and R. Gruber.   PADS: a domain-speciÔ¨Åc language for
                volvesmaintainingasetofallhypotheses(drawnfromahypothesis                       processing ad hoc data. In PLDI, pages 295‚Äì304, 2005.
                space) that are consistent with a sequence of observed examples.            [3] K. Fisher, Y. Mandelbaum, and D. Walker. The next 700 data descrip-
                Mitchell originally used this idea for reÔ¨Ånement-based learning of              tion languages. In POPL, pages 2‚Äì15, 2006.
                boolean functions [16], while Lau et.al. extended the concept to            [4] K. Fisher, D. Walker, K. Q. Zhu, and P. White. From dirt to shovels:
                learning more complex functions in a PBD setting [13]. Our syn-                 fully automatic tool generation from ad hoc data. In POPL, 2008.
                thesis algorithm shows how the concepts of version-space algebra
                can be lifted to the PBE (Programming by Example) setting, for a            [5] M. Gualtieri. Deputize end-user developers to deliver business agility
                fairly expressive string expression language involving conditionals             and reduce costs. In Forrester Report for Application Development
                andloops.TheideaofusingDAGsastheversionspaceforconcate-                         and Program Management Professionals, April 2009.
                nate constructor is inspired by the use of a similar data-structure in      [6] S. Gulwani. Dimensions in program synthesis. In PPDP. ACM, 2010.
                a very different context of solving an important open problem re-           [7] S. Gulwani and G. C. Necula. A polynomial-time algorithm for global
                lated to global value numbering [7]. The novel concepts introduced              value numbering. In SAS, pages 212‚Äì227, 2004.
                in this paper are quite general - we feel that they might be used to        [8] S. Jha, S. Gulwani, S. Seshia, and A. Tiwari.     Oracle-guided
                create PBEversionsofotherversion-spacealgebrabasedPBDsys-                       component-based program synthesis. In ICSE, 2010.
                tems (e.g., those that learn shell scripts [12] or imperative Python        [9] A. J. Ko, B. A. Myers, and H. H. Aung. Six learning barriers in end-
                programs [14]).                                                                 user programming systems. In VL/HCC, pages 199‚Äì206, 2004.
                                                                                           [10] T. Lau. Why PBDsystemsfail: Lessons learned for usable AI. In CHI
                8.   Conclusion and Future Work                                                 2008 Workshop on Usable AI, Florence, Italy, 2008.
                General purpose computational devices, such as cell-phones, com-           [11] T. Lau, S. Wolfman, P. Domingos, and D. Weld. Programming by
                puters, are becoming accessible to people at large at an impres-                demonstration using version space algebra. Machine Learning, 53(1-
                sive rate. In the future, robots will become house-hold entities. But,          2), 2003.
                unfortunately, programming general purpose platforms has never             [12] T. Lau, L. Bergman, V. Castelli, and D. Oblinger. Programming shell
                been easy, because we are still mostly stuck with the model of pro-             scripts by demonstration. In Workshop on SCLAS, AAAI, 2004.
                viding step-by-step, detailed, and syntactically correct instructions      [13] T. A. Lau, P. Domingos, and D. S. Weld. Version space algebra and its
                on how to accomplish a certain task, instead of simply describing               application to programming by demonstration. In ICML, 2000.
                what the task is. Program synthesis has the revolutionary potential        [14] T. A. Lau, P. Domingos, and D. S. Weld. Learning programs from
                to change this landscape, when targeted for the right set of people,            traces using version space algebra. In K-CAP, pages 36‚Äì43, 2003.
                for the right set of problems, and using the right interaction model.      [15] R. C. Miller and B. A. Myers. Interactive simultaneous editing of
                   In this paper, we have identiÔ¨Åed a killer application, that of               multiple text regions. In USENIX Annual Technical Conference, 2001.
                automating string processing in spreadsheets, which hundreds of            [16] T. M. Mitchell. Generalization as search. Artif. Intell., 18(2), 1982.
                millions of end-users struggle with on a regular basis (as is evident      [17] R. P. Nix. Editing by example. TOPLAS, 7(4):600‚Äì621, 1985.
                from online help forums and talking to product groups). We have            [18] S. Russell and P. Norvig. ArtiÔ¨Åcial Intelligence: A Modern Approach
                developedanefÔ¨Åcientalgorithmtohelpautomateavarietyofstring                      (2nd Edition). Prentice Hall, 2 edition, December 2002.
                processingtasksfrominput-outputexamples(whichwefoundtobe                   [19] S. Srivastava, S. Gulwani, and J. Foster. From program veriÔ¨Åcation to
                the most natural intent expression mechanism on help forums). We                program synthesis. In POPL, 2010.
                have paid special attention to usability issues and crossed the line       [20] J. M. Vilar. Query learning of subsequential transducers. In Proceed-
                from developing an academic-only technology to one that is ready                ings of the 3rd International Colloquium on Grammatical Inference,
                to be deployed.                                                                 1996.
                Acknowledgments                                                            [21] J. Walkenbach. Excel 2010 Formulas. John Wiley and Sons, 2010.
                Thanks to Ben Zorn who had such a belief in the promise of this            [22] I. H. Witten and D. Mo.   TELS: learning text editing tasks from
                                                                                                examples. In Watch what I do: programming by demonstration, pages
                technology that he helped Ô¨Ånd connections in product teams even                 293‚Äì307. MIT Press, Cambridge, MA, USA, 1993.
                before a prototype could be built. Thanks to the Excel product team        [23] Q. Xi and D. Walker.   A context-free markup language for semi-
                whokept engaging with us despite their initial skepticism whether               structured text. In PLDI, pages 221‚Äì232, 2010.
