                                 PSB2:TheSecondProgramSynthesisBenchmarkSuite
                                                  ThomasHelmuth                                                                                Peter Kelly
                                                     HamiltonCollege                                                                        Hamilton College
                                                Clinton, New York, USA                                                                 Clinton, New York, USA
                                                thelmuth@hamilton.edu                                                                   pxkelly@hamilton.edu
                    ABSTRACT                                                                                     Yet, for many years there were no common benchmark problems
                                                                                                                                                                       1
                    For the past six years, researchers in genetic programming and                               for evaluating general program synthesis systems; existing prob-
                    other program synthesis disciplines have used the General Pro-                               lems were either easy toy problems or were situated in speciﬁc
                    gram Synthesis Benchmark Suite to benchmark many aspects of                                  domains where solution programs were composed of a small set
                    automatic program synthesis systems. These problems have been                                of domain-speciﬁcinstructions. In 2015, the General Program Syn-
                    usedtomakenotableprogresstowardthegoalofgeneralprogram                                       thesis Benchmark Suite (PSB1) introduced 29 problems that could
                    synthesis: automaticallycreatingthetypesofsoftwarethathuman                                  beusedtobenchmarkprogramsynthesis systems[17].Sincethen,
                    programmers code. Many of the systems that have attempted the                                morethan80researchpapershavebenchmarked10+programsyn-
                    problems in the original benchmark suite have used it to demon-                              thesis systems using PSB1, producing numerous insights into pro-
                    strateperformanceimprovementsgrantedthroughnewtechniques.                                    gramsynthesis.
                    Overtime,thesuitehasgraduallybecomeoutdated,hindering the                                        OfthesystemsthathaveadoptedPSB1,mostfallwithintheﬁeld
                    accurate measurement of further improvements. The ﬁeld needs                                 of genetic programming (GP), including PushGP [17], grammar-
                    a new set of more diﬃcult benchmark problems to move beyond                                  guidedGP[6],grammaticalevolution[22],andlinearGP[29].How-
                   what was previously possible.                                                                 ever, non-evolutionary programsynthesis methodshavealsobeen
                       Inthispaper,wedescribethe25newgeneralprogramsynthesis                                     applied to PSB1, including those based on delayed-acceptance hill-
                    benchmark problems that make up PSB2, a new benchmark suite.                                 climbing [44] and Monte Carlo tree search [31]. We expand on the
                   These problems are curated from a variety of sources, including                               details of these methods and the results they have achieved using
                    programming katas and college courses. We selected these prob-                               PSB1 in Section 2, but to summarize, many of these systems have
                    lems to be more diﬃcult than those in the original suite, and give                           improved performance and demonstrated new techniques.
                    resultsusingPushGPshowingthisincreaseindiﬃculty.Thesenew                                         WhenPSB1wasﬁrstintroduced, the initial PushGP runs were
                    problems give plenty of room for improvement, pointing the way                               able to solve 22 of the 29 problems, with an average success rate
                    for the next six or more years of general program synthesis re-                              of 23 successful runs out of 100 [17]. The best-performing PushGP
                    search.                                                                                      results have now solved 25 problems, with an average success rate
                                                                                                                 of 42/100 [18]. Some of the most drastic improvements have come
                    CCSCONCEPTS                                                                                  on some of the most informative problems in PSB1, such as Dou-
                    • Software and its engineering → Automatic programming.                                      bleLetters(6→50successesbetween[17]and[18]),ReplaceSpace
                                                                                                                 withNewline(51→100),Syllables(18→64),VectorAverage(16→97),
                    KEYWORDS                                                                                     and X-Word Lines (8 → 91).
                                                                                                                     Thus, for PushGP and other synthesis systems, the problems of
                    automaticprogramsynthesis,benchmarking,geneticprogramming                                    PSB1havebecomelessusefulovertime.Inparticular,theveryhigh
                   ACMReferenceFormat:                                                                           performance achieved on some PSB1 problems leaves little room
                   ThomasHelmuthandPeterKelly.2021.PSB2:TheSecondProgramSynthe-                                  forexhibitingimprovement;afewotherproblemshaveneverbeen
                    sis BenchmarkSuite.In2021 GeneticandEvolutionaryComputationConfer-                           solvedandarelikelytoodiﬃculttobesolvedanytimesoon.Addi-
                    ence (GECCO’21),July10–14, 2021, Lille, France. ACM,NewYork, NY,USA,                         tionally, peculiarities in some of the problems in PSB1 make them
            arXiv:2106.06086v1  [cs.SE]  10 Jun 2021
                   10 pages. https://doi.org/10.1145/3449639.3459285                                             less ideal as benchmarks, either because of how synthesis systems
                                                                                                                 move through their search space or how slow they are to run. Fi-
                    1 INTRODUCTION                                                                               nally, some decisions about the speciﬁcation of problems in PSB1
                   Automatic general program synthesis, with the aim of automati-                                makethemdiﬃculttoimplementinhindsight,potentiallyprevent-
                    cally generating programs of the type humans write from scratch,                             ing wider adoption.
                    haslongbeenagoalofartiﬁcialintelligence andmachinelearning.                                      With these drawbacks in mind, we have created a second Pro-
                                                                                                                 gramSynthesis Benchmarksuite,whichwerefer toasPSB2.PSB2
                    Permission to make digital or hard copies of all or part of this work for personal or        consistsof25problemscuratedfromprogrammingchallenges,pro-
                    classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed                     gramming katas, and college courses. In order to facilitate the up-
                    for proﬁt or commercial advantage and that copies bear this notice and the full cita-
                    tion on the ﬁrst page. Copyrights for components of this work owned by others than           takeofPSB2,weprovideareference implementationofeachprob-
                   ACMmustbehonored.Abstractingwithcreditispermitted. Tocopyotherwise,orre-                      lem, as well as datasets that can be sampled to more easily im-
                    publish, to post on serversor to redistributeto lists, requires prior speciﬁc permission     plement each problem in new synthesis systems. 2 Just like PSB1,
                    and/or a fee. Request permissions from permissions@acm.org.
                    GECCO’21,July10–14,2021,Lille, France
                   ©2021Association for Computing Machinery.                                                     1Also known as automatic programmingor software synthesis.
                   ACMISBN978-1-4503-8350-9/21/07...$15.00                                                       2Referenceimplementation,datasets,andotherresourcescanbefoundonthispaper’s
                    https://doi.org/10.1145/3449639.3459285                                                      companionwebsite: https://cs.hamilton.edu/~thelmuth/PSB2/PSB2.html.
                GECCO’21,July10–14,2021, Lille, France                                                                              ThomasHelmuthandPeterKelly
                the problems in PSB2 require a wide range of programming tech-                General program synthesis requires the manipulation of multi-
                niques, data types, and control ﬂow structures to solve. However,          ple data types; stack-based GP systems have handled this require-
                theyaremarkedlyhardertosolvethanproblemsinPSB1,withour                     ment well, but so have other GP systems that handle strong typ-
                initial results solving 13 of the 25 problems for an average success       ing of programs. In particular, grammar-based approaches such as
                rate of 10/100. These more diﬃcult problems will drive program             grammar guided GP (G3P) [6–9] and grammatical evolution (GE)
                synthesis research toward solving more realistic program synthe-           [22, 27, 39, 50] have made goodprogress at solving theproblemsin
                sis tasks.                                                                 PSB1. Many of these use the type-based grammar design patterns
                   The purpose of benchmark problems is to allow us to empiri-             introducedtoﬂexiblyhandleproblemswithdiﬀerent typerequire-
                cally show what changes to a system produce improvements that              ments [6]. Another use of these grammars trains a sequence-to-
                may transfer to real-world problems. To achieve this goal, they            sequence variational autoencoder to embed programs in a contin-
                must be suﬃciently diﬃcult, unlike toy problems that have been             uous space and then uses an evolutionary algorithm to optimize
                used as benchmarks in the past. They must also be representative           programs in this space [32]. Finally, a linear GP system with tag-
                of the types of tasks we want our system to perform. However, we           based memoryhas also been explored using PSB1 [5, 23, 29].
                also want benchmarks to be easier and faster to run than an ac-               Asfor non-GP systems, an approach using delayed-acceptance
                tual real-world problem in order to aid reasonable testing of a sys-       hillclimbing for inductive synthesis proved competitive with GP
                tem.Giventhatautomaticprogramsynthesisisstillinitsﬂedgling                 on PSB1, including producing the only known solutions to the
                stages, we see the problems in PSB2 as a stepping stone toward             Collatz Numbers problem [44]. A comparison was made between
                solving more realistic problems.                                           FlashFill [11], MagicHaskeller [26], PushGP, and G3P, ﬁnding that
                   PSB2 also addresses calls from the GP community to produce              the non-GP methods fared much worse but ran much faster than
                andadoptrealisticbenchmarks.GPcommunitydiscussionscalling                  the GP methods[41].Finally, Monte Carlo tree search was used to
                for better benchmarks [34, 59, 60] inspired the creation of PSB1;          generate Java bytecode programs using a few of the problems in
                these calls also highlighted the need to periodically update and           PSB1[31].
                replace benchmark problems in order to keep advancing the ﬁeld
                withoutover-optimizingtoasinglesetofproblems.Morerecently,
                acalltorefocustheeﬀortsofGPonautomaticprogrammingstated,                   3 LESSONSLEARNED
                “We are in no doubt of the need for the further principled devel-          While PSB1 has been successfully used in a variety of research, it
                opment of additional benchmarks that can be used in a targeted             wasaﬁrstattemptatageneral-purpose programsynthesis bench-
                manner to push the boundaries along diﬀerent dimensions such               marksuite.Theresearchcommunityhasgrownfromusingit,both
                as scalability, generalisation, and adaptation, and to facilitate com-     intermsofimprovingprogramsynthesismethodsaswellaslessons
                parison across a range of very diﬀerent approaches to automatic            learned about how to best deﬁne program synthesis benchmarks.
                programming” [40]. The creation of PSB2 aims to push the bound-            Here, we discuss some issues of the latter type and how they have
                aries of program synthesis research and give synthesis systems a           inﬂuenced our creation of PSB2.
                fresh set of problems to explore. Of course, there is no need to en-          One major issue with PSB1 is that every system that uses it
                tirely throw out the problems of PSB1; we could imagine some of            needs to implement all of the problems from scratch. This hurdle
                the harder problems continuing to provide useful data, and newer           likely decreased wider adoption. Additionally, there may be incon-
                systems mayneedtostartontheeasier problems as a jumping oﬀ                 sistencies between implementations in diﬀerent systems, leading
                point.                                                                     to less comparable results; one known such inconsistency is that
                   Theremainderofthispaperisstructuredasfollows:inthenext                  some systems use new randomized data for each run, while oth-
                section, we discuss research that has used PSB1. In Section 3, we          ers use the same dataset for every run. Four years after its initial
                highlight lessons learned about program synthesis benchmarking             release, the authors of PSB1 created large datasets of the inputs
                from PSB1. Sections 4 and 5 describe the sources of PSB2’s prob-           and correct outputs for each problem [12]. These datasets can be
                lems and describe the problems in detail. We then give general             sampledforeachprogramsynthesisrun,meaningthereisnoneed
                guidance on benchmarking with PSB2, and give details of the pa-            for each system to implement each problem. We have copied this
                rameters we used in our experiments in Sections 6 and 7. Finally,          model, and provide datasets for each problem in PSB2 (see Sec-
                Section 8 presents initial results using PushGP.                           tion 6).
                                                                                              AhandfuloftheproblemsinPSB1requireprogramstoproduce
                                                                                           Boolean outputs, as such functions are common in programming
                2 PASTRESEARCHUSINGPSB1                                                    exercises. A trend noted across completely diﬀerent program rep-
                PSB1hasbeenusedinavarietyofresearch projectson automatic                   resentations is that solutions to these Boolean-outputproblems of-
                programsynthesis,manyofthemusingGPasthesynthesissystem.                    tendonotgeneralize tounseen data.Asimpleexplanationforthis
                The paper that introduced PSB1 [17] used PushGP, a GP system               phenomenon is that it is relatively easy for a solution program to
                basedonthestack-basedPushprogramminglanguage;avarietyof                    producethecorrectanswersforthewrongreasonswhenthereare
                papers using PushGP have made use of PSB1 since [14–16, 18, 21,            only two possible answers, thus overﬁtting to the training data. It
                46, 47]. Code-building GP is a stack-based GP system borrowing             is muchhardertoperfectlyanswertrainingdataforthewrongrea-
                some inspirations from Push that constructs programs in a host             sonswhentheoutputisanintegerorstring,forexample.Because
                language; it solved some ofthe PSB1problems,producingsolution              of this issue, we have selected fewer Boolean-output problems for
                programs in Python [42].                                                   PSB2, including only one representative problem.
               PSB2: The Second ProgramSynthesis Benchmark Suite                                                     GECCO’21,July10–14,2021, Lille, France
                 PSB1wasdesignedtoemulatethetextbookproblemsitwascu-                    These sources contain a large number and variety of problems;
               ratedfromascloselyaspossible.Forexample,manyproblemsfrom              we considered over 75 problems from these sources and imple-
               the original textbook required the program to print its answers.      mented and tested over 50 of them, ﬁltering out problems that
               PSB1 suggested that synthesis systems develop methods for emu-        seemed too easy, too diﬃcult, or inaccessible. While curating the
               lating an output buﬀer and commonprinting instructions in order       suite, wedidnotincludeanyproblemsonwhichPushGPproduced
               to mimic these problems. However, this approach was infeasible        asuccessrateover60%,toensurethatproblemsaresuﬃcientlydif-
               for some synthesis systems, which instead simply returned string      ﬁcult to allow for improvement. In order to be transparent about
               outputs. As PSB2 is less loosely coupled with its problem sources,    ourcuration process, we have created a table containing all of the
               we decided to have all programs return their outputs instead of       problems we considered, including the reason for rejection for re-
               “printing” them. Another wrinkle related to outputs is that some      jectedproblems,initialresultsifweimplementedtheproblem,and
                                                                                                                       3
               problemsrequireasolutiontoreturnmultipleoutputs.Whilemul-             a link to the source of the problem.
               tiple outputs may prove diﬃcult in some systems, it is generally         We aimed to include problems that require a large variety of
               feasible in all; we have included 4 multi-output problems in PSB2.    data types and control ﬂow structures to solve, with a balance
                 PSB1recommendeddiﬀerent training and test set sizes, as well        between data types across problems. Most, if not all, of the prob-
               as program evaluation budgets, for each problem. This led to diﬃ-     lems require some type of iteration and/or conditional execution.
               cultiesandconfusioninbothimplementationandreportingresults.           Required data types include integers, ﬂoats, Booleans, characters,
               For PSB2, we recommend using a ﬁxed setting for each parameter        strings, vectors of integers, and vectors of ﬂoats. In order to pro-
               across problems, as well as for system-speciﬁc parameters such as     ducelarge datasets, we aimed to select problems that have at least
               maximumsizesforprogramsizecontrol.                                    1millionpossibleuniqueinputs;theonlyexceptionbeingtheCoin
                 Forstenlechner et al. [9] discussed understanding and reﬁning       Sumsproblem,whichhas10,000possibleinteger inputs.
               theproblemsinPSB1,makingsomegeneralrecommendationsabout
               both synthesis systems and benchmark problems. One suggestion         5 PROBLEMDESCRIPTIONS
               put forth is using larger and more targeted training sets, to better  BelowisalistoftheEnglishlanguagedescriptionsofthe25bench-
               guide synthesis and increase generalization. We take this recom-      mark problems in PSB2. Each problem (besides those from our
               mendation and use large training sets (200 examples) that have a      courses) has a citation of its source with a link to the original prob-
               variety of speciﬁc edge cases purposefully included. Most of their    lem. The types of the input(s) and output(s) for each problem are
               other suggestions relate to speciﬁc system settings, such as the      given in Table 1. For more precise details of each problem, see the
               length of evolution; these parameters are not prescribed by PSB2,                               4
               and can be chosen by the researcher.                                  reference implementation.
                                                                                         1. Basement(AoC)Givenavectorofintegers,returntheﬁrst
                                                                                            index such that the sum of all integers from the start of the
                                                                                            vector to that index (inclusive) is negative. [55]
               4 PROBLEMSELECTIONANDSOURCES                                              2. BouncingBalls(CW)Givenastartingheightandaheight
               Below we describe the four sources we used as inspiration for the            after the ﬁrst bounce of a dropped ball, calculate the bounci-
               problems included in this suite. Each of these sources presents              ness index (height of ﬁrst bounce / starting height). Then,
               problems for humans to use to improve their programming skills,              given a numberofbounces,usethebouncinessindex tocal-
               whetherforexperiencedprogrammersorstudentsinclass.Assuch,                    culate the total distance that the ball travels across those
               these sources contain problems representative of the types of pro-           bounces. [10]
               grammingthat weexpecthumanstoperform.                                     3. Bowling (CW) Given a string representing the individual
                 CodeWars(CW)-Awebsitefullofuser-createdprogramming                         bowls in a 10-frame round of 10 pin bowling, return the
               challenges, called coding kata. The aim of the site is for users to          score of that round. [1]
               spendsmallamountsoftimeprogrammingeverydaytohonetheir
               coding skills.                                                            4. Camel Case (CW) Take a string in kebab-case and con-
                 Advent of Code (AoC) - An Advent calendar of coding prob-                  vert all of the words to camelCase. Each group of words to
               lems created every year in December. These problems can be used              convert is delimited by "-", and each grouping is separated
               for any number of things, like training, interview prep, or course-          byaspace.Forexample:"camel-case example-test-string"
               work. Problems tend to become harder throughout the month.                   →"camelCase exampleTestString". [25]
                 HomeworkProblems(HW)-Theseproblemscomefrompro-
               gramming homework given in our undergraduate programming                  5. Coin Sums (PE) Given a number of cents, ﬁnd the fewest
               courses. The problems come from two courses: an introductory                 numberofUScoins(pennies,nickles,dimes,quarters)needed
               programmingcourse,andaprogramlanguagescourse.Theseprob-                      to make that amount, and return the number of each type
               lems do not have citations, since we created them for our courses.           of coin as a separate output. [3]
                 Project Euler (PE) - A website containing hundreds of prob-
               lems in an archive. Users are free to submit answers to validate
               their solutions. Most problems tend to be mathematically focused      3https://docs.google.com/spreadsheets/d/e/2PACX-1vQKO1D2sZA9KosXpOJNuiDW6yDQEZnMrwzNeMJJU25MbZhU6odQ0jGkJN5lgbRgspsmmum65WLbEI2B/pubhtml?gid=0&single=true
               and often require eﬃcient and elegant solutions.                      4https://github.com/thelmuth/Clojush/releases/tag/psb2-v1.0
                GECCO’21,July10–14,2021, Lille, France                                                                             ThomasHelmuthandPeterKelly
                             Table 1: For each problem, the types of the inputs and outputs, and the limits imposed on the inputs.
                   Name                    Inputs                                                                                     Outputs
                   Basement                vector of integers of length [1,20] with each integer in [−100,100]                        integer
                   Bouncing Balls          ﬂoat in [1.0, 100.0], ﬂoat in [1.0,100.0], integer in [1,20]                               ﬂoat
                   Bowling                 string in form of completed bowling card, with one character per roll                      integer
                   Camel Case              string of length [1,20]                                                                    string
                   Coin Sums               integer in [1,10000]                                                                       4 integers
                   Cut Vector              vector of integers of length [1,20] with each integer in [1,10000]                         2 vectors of integers
                   Dice Game               2 integers in [1,1000]                                                                     ﬂoat
                   Find Pair               vector of integers of length [2,20] with each integer in [−10000,10000], integer in        2 integers
                                           [−20000,20000]
                   Fizz Buzz               integer in [1,1000000]                                                                     string
                   Fuel Cost               vector of integers of length [1,20] with each integer in [6,100000]                        integer
                   GCD                     2 integers in [1,1000000]                                                                  integer
                   Indices of Substring    2 strings of length [1,20]                                                                 vector of integers
                   Leaders                 vector of integers of length [0,20] with each integer in [0,1000]                          vector of integers
                   Luhn                    vector of integers of length 16 with each integer in [1,9]                                 integer
                   Mastermind              2 strings of length 4 made of B, R, W, Y, O, G                                             2 integers
                   Middle Character        string of length [1,100]                                                                   string
                   Paired Digits           string of digits of length [2,20]                                                          integer
                   Shopping List           vector of ﬂoats of length [1,20] with each ﬂoat in [0.0,50.0], vector of ﬂoats of length   ﬂoat
                                           [1, 20] with each ﬂoat in [0.0, 100.0]. Both vectors must be the same length
                   SnowDay                 integer in [0,20], ﬂoat in [0.0, 20.0], ﬂoat in [0.0, 10.0], ﬂoat in [0.0, 1.0]            ﬂoat
                   Solve Boolean           string of length [1,20] made of characters from {t, f, |, &}                               Boolean
                   Spin Words              string of length [0,20]                                                                    string
                   Square Digits           integer in [0,1000000]                                                                     string
                   Substitution Cipher     3 strings of length [0,26]                                                                 string
                   Twitter                 string of length [0,200]                                                                   string
                   Vector Distance         2 vectors of ﬂoats of length [1,20] with each ﬂoat in [−100.0,100.0]                       ﬂoat
                    6. Cut Vector (CW) Given a vector of positive integers, ﬁnd              12. IndicesofSubstring(CW)Givenatextstringandatarget
                       the spot where, if you cut the vector, the numbers on both                string, return a vector of integers of the indices at which the
                       sidesareeitherequal,orthediﬀerenceisassmallaspossible.                    target appears in the text. If the target string overlaps itself
                       Return the two resulting subvectors as two outputs. [36]                  in the text, all indices (including those overlapping) should
                                                                                                 be returned. [49]
                    7. DiceGame(PE)Peterhasan=sideddieandColinhasan<
                       sideddie. If they both roll their dice at the same time, return       13. Leaders(CW)Given a vector of positive integers, return a
                       theprobabilitythatPeterrollsstrictlyhigher thanColin.[4]                  vector of the leaders in that vector. A leader is deﬁned as a
                                                                                                 number that is greater than or equal to all the numbers to
                    8. Find Pair (AoC) Given a vector of integers, return the two                therightofit.Therightmostelementisalwaysaleader.[35]
                       elements that sum to a target integer. [58]
                                                                                             14. Luhn (CW) Given a vector of 16 digits, implement Luhn’s
                    9. Fizz Buzz (CW) Given an integer G, return "Fizz" if G is                  algorithmtoverifyacreditcardnumber,suchthatitfollows
                       divisible by 3, "Buzz" if G is divisible by 5, "FizzBuzz" if G            the following rules: double every other digit starting with
                       is divisible by 3 and 5, and a string version of G if none of             the second digit. If any of the results are over 9, subtract 9
                       the above hold. [54]                                                      from them. Return the sum of all of the new digits. [33]
                   10. FuelCost(AoC)Givenavectorofpositiveintegers, divide                   15. Mastermind(HW)BasedontheboardgameMastermind.
                       each by3,roundtheresultdowntothenearest integer, and                      Given a Mastermind code and a guess, each of which are
                       subtract 2. Return the sum of all of the new integers in the              4-character strings consisting of 6 possible characters, re-
                       vector. [57]                                                              turn the number of white pegs (correct color, wrong place)
                   11. GCD [Greatest Common Divisor] (CW) Given two in-                          and black pegs (correct color, correct place) the codemaster
                       tegers, return the largest integer that divides each of the               should give as a clue.
                       integers evenly. [45]
              PSB2: The Second ProgramSynthesis Benchmark Suite                                                  GECCO’21,July10–14,2021, Lille, France
                                                                                                5
                 16. MiddleCharacter(CW)Givenastring,returnthemiddle               problem [13]. The dataset for each problem consists of a small
                     characterasastringifitisoddlength;returnthetwomiddle          numberofhand-choseninputs,oftenaddressingedgecasesforthe
                     characters as a string if it is even length. [48]             problem, and 1 million randomly-generated inputs falling within
                                                                                   the constraints of the problem. We recommend each diﬀerent pro-
                 17. PairedDigits(AoC)Givenastringofdigits,returnthesum            gram synthesis run use a diﬀerent set of data, composed of ev-
                     of the digits whose following digit is the same. [56]         ery one of the hand-chosen inputs and a random sample of the
                 18. Shopping List (CW) Given a vector of ﬂoats representing       randomly-generated inputs. The alternative method of using the
                     the prices of various shopping goods and another vector of    same ﬁxed set of inputs for every run could happen to use a par-
                     ﬂoats representing the percent discount of each of those      ticularly lucky (or unlucky) set of inputs; using randomized inputs
                     goods, return the total price of the shopping trip after ap-  avoidsthisissue.OurdatasetswillallowthoseimplementingPSB2
                     plying the discount to each item. [43]                        to simply sample the provided data, greatly decreasing the bar-
                                                                                   rier to using PSB2. The PSB2 datasets can be found permanently
                                                                                              6
                 19. Snow Day (HW) Given an integer representing a number          on Zenodo. For more information about distributions of inputs
                     ofhoursand3ﬂoatsrepresentinghowmuchsnowisonthe                in randomly-generated inputs, see the reference implementation,
                                                                                                                         7
                     ground, the rate of snow fall, and the proportion of snow     whichwasusedtogenerate the datasets.
                     meltingperhour,returntheamountofsnowontheground                 Whenusing our provided datasets, one could sample diﬀerent
                     after the amount of hours given. Each hour is considered a    sizes of training and unseen test sets to ﬁt a given experiment. Our
                     discrete event of adding snow and then melting, not a con-    recommendation, which we use in the our experiments, is to use
                     tinuous process.                                              200 example cases for the training set (including all hand-chosen
                                                                                   inputs) and 2000 for the unseen test set. However, some synthe-
                 20. SolveBoolean(CW)GivenastringrepresentingaBoolean              sis methods may need smaller or larger training sets, and PSB2
                     expressionconsisting of T, F,|, and&, evaluate it and return  canﬂexibly adapt to such systems. In order to produce fairer com-
                     the resulting Boolean. [28]                                   parisons between systems, we recommend using a ﬁxed program
                                                                                   executionbudgettolimitthenumberofgeneratedprogramexecu-
                 21. Spin Words (CW) Given a string of one or more words           tions in a single program synthesis run. We recommend a budget
                     (separated by spaces), reverse all of the words that are ﬁve  of 60 million program executions; we allocate these to 200 train-
                     or more letters long and return the resulting string. [61]    ing cases used to evaluate a population of 1000 individuals for 300
                 22. Square Digits (CW) Given a positive integer, square each      generations in our experimental GP runs, but other allocations of
                     digitandconcatenatethesquaresintoareturnedstring.[37]         the same executions would be reasonable.
                                                                                     ProgramsynthesismethodsthathavebeenappliedtoPSB1have
                 23. Substitution Cipher (CW) This problem gives 3 strings.        usedvaryingmethodsforconstrainingtheinstructionsetandother
                     Theﬁrsttworepresent a cipher, mapping each character in       program syntax. For example, some have used grammars [6, 7, 22,
                     one string to the one at the same index in the other string.  27, 32, 39, 50] while othershaveuseddata-typecategorizedsubsets
                     Theprogrammustapplythis cipher to the third string and        of an instruction set [16, 17]. We do not want to constrain what a
                     return the deciphered message. [24]                           reasonableapproachtoselectinginstructionsmaylooklikeforany
                                                                                   given program synthesis system. However, we also warn against
                 24. Twitter (HW) Given a string representing a tweet, vali-       cherry-picking a small subset of instructions suspected of being
                     date whether the tweet meets Twitter’s original character     useful for a particular problem. Part of the diﬃculty of general
                     requirements. If the tweet has more than 140 characters, re-  programsynthesis is that a system must manage a large set of po-
                     turn the string "Too many characters". If the tweet is        tentially useful instructions, ﬁnding those relevant to a particular
                     empty, return the string "You didn’t type anything".          problem.Werecommendemployingalargesetofgeneral-purpose
                     Otherwise,return"Your tweet has X characters",where           instructions when using PSB2 to benchmark program synthesis to
                     the - is the number of characters in the tweet.               best replicate the conditions of a real-world scenario.
                 25. VectorDistance(CW)Giventwo=-dimensionalvectorsof                WhenevaluatingtheperformanceofasynthesissystemonPSB2,
                     ﬂoats, return the Euclidean distance between the two vec-     we recommend using success rate (the number of synthesis runs
                     tors in =-dimensional space. [53]                             that produce a solution) as the primary measure of performance,
                                                                                   as was recommended in PSB1 [17]. For the synthesis of software,
                                                                                   generating programsthatpassmosttrainingcasesisnotsuﬃcient;
                                                                                   forthisreasonsuccessrateisabettermeasureofperformancethan
                                                                                   other metrics such as mean best ﬁtness or mean number of train-
              6 USINGPSB2                                                          ing cases passed. In particular, a solution must not only pass all
              While Section 5 provides English-language descriptions of the 25     cases in the training set, but also all of the cases in the test set, to
              benchmark problems, these are not suﬃcient to implement each         ensure that it generalizes to unseen data. This avoids considering
              problem in a new system. Here we discuss the system-agnostic
              details for using these problems.                                    5Our datasets follow the model of other machine learning datasets such as Penn ML
                                                                                   Benchmarks[30, 38] and the UCI ML Repository [2].
                 ForreasonsdiscussedinSection3,wehavecreateddatasetscon-           6https://zenodo.org/record/4678739
              sisting of large numbers of inputs and correct outputs for every     7https://github.com/thelmuth/Clojush/releases/tag/psb2-v1.0
               GECCO’21,July10–14,2021, Lille, France                                                                         ThomasHelmuthandPeterKelly
               programsthatoverﬁtthetrainingdata,suchasbymemorizingthe                 better results on multi-outputproblems when using one outputin-
               correct output to each input, as solutions.                             structionperoutput.Theseoutputinstructionsareincludedinthe
                                                                                       instruction set for such problems and will always appear in solu-
               7 EXPERIMENTALMETHODSANDSYSTEM                                          tion programs. An example of this is for Coin Sums, which has 4
                    PARAMETERS                                                         outputs. We provide four corresponding output instructions, each
               In this section we will discuss the system-speciﬁc parameters and       of which takes the top integer from the integer stack and stores it
               choices that mustbedecidedinordertousePSB2.Incontrastwith               in a write-only register for that output; further calls to an output
               the previous section on general considerations, the choices here        instruction will overwrite this output register.
               may diﬀer considerably for diﬀerent program synthesis systems.            In order to deﬁne each problem for GP, we not only need the
               For our experiments, we used PushGP; we will describe in general        inputsandcorrectoutputsforeachproblem,butalsohowtocalcu-
               the decisions that must be made and give our speciﬁc choices.           latetheerrorfunctionbasedonthecorrectoutputandaprogram’s
                  PushGP evolves programs in the language Push, a stack-based          output. Here we describe the error functions we employed in our
               programming language built speciﬁcally for use in genetic pro-          experiments, whichwerecommendforanyGPsystemimplement-
               gramming [51, 52]. Every data type has its own stack, and each          ing PSB2; other non-GP program synthesis systems may require
               Push instruction acts by pushing and popping various elements           entirely diﬀerent metrics. For each output data type, we use the
               on and oﬀ the stacks. The output of each problem is typically the       following standard error functions for problems outputting that
               top element on a particular stack. The interpreter executes pro-        data type:
               gramsthatarethemselves placedonanexec stack,allowing exec                   • Integer or ﬂoat: absolute value of the diﬀerence between
               instructions to manipulate control ﬂow as well as the program it-             program outputand correct output.
               self as it runs. We provide a reference implementation in Clojure           • Boolean: 0 for correct and 1 for incorrect output.
               of the PushGP system used to produce our results, which includes            • String: Levenshtein string edit distance between the pro-
                                     8                                                       gramoutputandcorrectoutput.
               eachprobleminPSB2. Thisreferenceimplementationisthesame
               implementation of PushGP used in recent research using PSB1,                • Vectorof integers: add the diﬀerence in length between the
               e.g. [14, 15, 18].                                                            program’s output vector and the correct vector times 1000
                  Wediscussthegeneral design of programsynthesis instruction                 to the absolute diﬀerence between each integer and the cor-
               sets in Section 6. For our PushGP experiments, we use the general             responding integer in the correct vector.
               process recommended in PSB1, where, for each problem, we iden-          Theonlyexception is for the Indices of Substring problem, where
               tify which data types (corresponding to stacks) are relevant and        weusedLevenshteindistancetocomparevectorsofintegers,since
               include all implemented instructions that use those stacks [17]. In     it makes more sense for that problem. In PushGP, some evolving
               Table 2, we present the data types we chose to include for each         programs will not return values of a program’s output data type;
               problem, and the total number of instructions in the instruction        we give a penalty error value speciﬁc to the problem when this
               set. These large instruction sets contain a wide range of general-      occurs.
               purposePushinstructions,includingsomenewinstructionsimple-                Ashasbeen shown to be eﬀective at improving generalization,
               mented since PSB1, avoiding the cherry-picking of clearly useful        we use an automatic simpliﬁcation procedure on every evolved
               instructions. See the reference implementation for a complete list-     Push program that passes all of the training cases before testing
               ing of instructions.                                                    it on the test set [14].
                  Research utilizing PSB1 in using transfer-learned instruction          Unlike for PSB1, we aimed to keep all system-speciﬁc param-
               sets showed that the composition of the instruction set matters a       eters constant between problems, increasing ease of use for both
               great deal to problem-solving performance [16]. While we do not         implementation and reporting of results. These parameters were
               use fully transfer-learned instruction sets here, we do make use of     chosenbasedonpriorexperienceandreasonableperformance;we
               one simple take-away: that including larger proportions of input        leave optimizing parameter settings as an open research question.
               instructions and constants/ERCsimproves performance. An expla-          Other systems may chooseto use diﬀerent system-speciﬁc param-
               nation of this result is that most Push instructions decrease stack     eters.
               sizes by consuming arguments and producingfewer returnvalues,             Our PushGP system uses linear Plush genomes that are initial-
               so increasing inputs and constants creates more data on which in-       ized by generating lists of random instructions from the instruc-
               structionscan act.Weboostthepresenceofinputinstructionsand              tion set [21]. We list the important parameters used in our experi-
               constants in the instruction set, making input instructions ﬁll 15%     ments below:
               of the instruction set and constants/ERCs ﬁll 5% of the instruc-
               tion set. The additional input instructions are evenly distributed          • Maximuminitial genome size: 250 genes
               between each input for problems with multiple inputs, and con-              • Maximumgenomesize:500genes
               stants/ERCs are similarly evenly distributed for each listed in the         • Population size: 1000
               last column of Table 2.                                                     • Maximumgenerations perrun: 300
                  Forproblemswithmultipleoutputs,diﬀerentsynthesissystems                  • MaximumstepsofthePushinterpreterwhenexecutingone
               will need to make choices speciﬁc to the language of the synthe-              program: 2000
               sizedprograms.InitialexperimentsinPushGPshowthatitachieves                  • Parent selection: lexicase selection [20]
                                                                                           • Geneticoperator:UniformMutationwithAdditionsandDele-
               8https://github.com/thelmuth/Clojush/releases/tag/psb2-v1.0                   tions (UMAD), used to make 100% of children [15].
               PSB2: The Second ProgramSynthesis Benchmark Suite                                                         GECCO’21,July10–14,2021, Lille, France
               Table2:InstructionsanddatatypesusedinourPushGPimplementationofeachproblem.Thecolumn“#Instructions”reports
               the number of instructions, terminals, and ephemeral random constants (ERC) used for each problem. The middle columns
               show which data types were used for each problem. For example, the Basement problem used all instructions relevant to
               exec, integers, Booleans, and vectors of integers. The last column lists the constants and ERCs used for the problem. Here,
               charconstantsarerepresentedintheClojurestyle,startingwithabackslash,andstringsaresurroundedbydoublequotation
               marks.The“Problems”rowsimplycountshowmanyproblemsuseeachdatatype.The“Instructions”rowshowsthenumber
               of Push instructions that primarily use each data type; some use multiple types but are only counted once.
                                                                                s
                                                                                r
                                                                                e    s
                                             s                                  g    t
                                             n                                  e    a
                                             o                                  t    o
                                             i                                  n
                                             t                                  i    ﬂ
                                             c                   n              f    f
                                             u         r         a              o    o
                                             r         e                        r    r
                                             t         g         e         g    o    o
                                             s    c    e    t    l    r    n    t    t
                                             n    e    t    a    o    a    i    c    c
                                             I    x         o    o    h    r    e    e
                                                       n                   t
                   Problem                   #    e    i    ﬂ    B    c    s    v    v  ConstantsandERCs(besidesinputs)
                   Basement               117   x     x         x              x        [], -1, 0, 1, integer ERC
                   Bouncing Balls         127   x     x    x    x                       0.0, 1.0, 2.0
                   Bowling                161   x     x         x    x    x             \-, \X, \/, \1, \2, \3, \4, \5, \6, \7, \8, \9, \10,
                                                                                        integer ERC
                   CamelCase              151   x     x         x    x    x             \-, \space, visible character ERC, string ERC
                   Coin Sums               86   x     x         x                       0, 1, 5, 10, 25
                   CutVector              116   x     x         x              x        [], 0
                   Dice Game              125   x     x    x    x                       0.0, 1.0
                   Find Pair              120   x     x         x              x        -1, 0, 1, 2, integer ERC
                   Fizz Buzz              118   x     x         x         x             "Fizz", "Buzz", "FizzBuzz", 0, 3, 5
                   Fuel Cost              117   x     x         x              x        0, 1, 2, 3, integer ERC
                   GCD                     79   x     x         x                       integer ERC
                   Indices of Substring   184   x     x         x    x    x    x        [], "", 0, 1
                   Leaders                114   x     x         x              x        [], vector ERC
                   Luhn                   117   x     x         x              x        0, 2, 9, 10, integer ERC
                   Mastermind             123   x     x         x    x    x             0, 1, \B, \R, \W, \Y, \O, \G
                   MiddleCharacter        151   x     x         x    x    x             "", 0, 1, 2, integer ERC
                   Paired Digits          149   x     x         x    x    x             0, char digit ERC, integer ERC
                   Shopping List          161   x     x    x    x                   x   0.0, 100.0, float ERC
                   SnowDay                131   x     x    x    x                       0, 1, -1, 0.0, 1.0, -1.0
                   Solve Boolean          153   x     x         x    x    x             true, false, \t, \f, \&, \|
                   Spin Words             152   x     x         x    x    x             4, 5, \space, visible character ERC, string ERC
                   Square Digits          151   x     x         x    x    x             "", 0, 1, 2, integer ERC
                   Substitution Cipher    151   x     x         x    x    x             "", 0
                   Twitter                153   x     x         x    x    x             0, 140, "Too many characters", "You didn’t type
                                                                                        anything", "your tweet has " , " characters"
                   Vector Distance        160   x     x    x    x                   x   [], 0
                   Problems                     25   25    5   25   11   12    7    2
                   Instructions                 29   33   45   21   21   47   34   34
                    • UMADadditionrate:0.09                                             ourrunsinTable3.Outofthe25problemsinPSB2,13weresolved
               AsdescribedinSection6,usingtheexactsamepopulationsizeand                 by PushGP. Of these 13, 3 of them had 50 or more successes (Fuel
               generations is not necessary for comparisons betweensystems; in-         Cost, Middle Character, and Substitution Cipher) and 2 others had
               stead, we recommend using a maximum budget of 60 million pro-            25ormoresuccesses(FizzBuzzandTwitter).Theremaining 8had
               gramexecutions regardless of other settings.                             fewer than 10 solutions, showing that they are solvable by GP but
                                                                                        leave a lot of room for improvement.
               8 EXPERIMENTALRESULTS                                                       PushGPdidnotsolve theremaining 12 problems. However, we
               Inordertogiveabaselineperformanceofthe25problemsinPSB2,                  note that in our initial exploratory runs of the Bouncing Balls and
               weconducted100PushGPrunsoneachproblemusingtheexperi-                     Leaders problems, PushGP produced 2 generalizing solutions to
               mentalmethodsdescribedinSection7.Wepresentsuccessratesof
               GECCO’21,July10–14,2021, Lille, France                                                                          ThomasHelmuthandPeterKelly
               Table 3: Results from 100 PushGP runs on each problem.                   Balls found 2 solutions on the training data, but neither of them
               “Succ.”givesthenumberofrunsthatsuccessfullyﬁndapro-                      generalized to the test, which resulted in 0 successful runs and a
               gram that pass every training case and perfectly pass a set              0.00 generalization rate.
               of 2000 unseen test cases. “Gen.” gives the proportion of so-               Another way of approximating the diﬃculty of these problems
               lutions on the training data that generalize to unseen data.             is by looking at the size of the smallest solution program found for
               “Size” gives the size of the smallest automatically simpliﬁed            eachproblem.Smallersolutionsareeasier foraprogramsynthesis
               solutionthatgeneralizedtounseendata.Timeistheaverage                     system to generate, simply because they require assembling fewer
               numberofsecondstakenpergeneration.                                       instructions in the right order. Our results are particular to Push
                                                                                        programsolutions,butshouldcorrelatewiththesizesofprograms
                      Problem                Succ.   Gen.    Size   Time                needed to solve these problems in other systems. In order to ﬁnd
                      Basement                   1    1.00     18      250              each size, we took each solution program and automatically sim-
                      Bouncing Balls             0    0.00       -     311              pliﬁed it to produce a smaller equivalent program [14]. Of these
                      Bowling                    0        -      -     206              simpliﬁed programs, in Table 3 we report the smallest simpliﬁed
                      Camel Case                 1    1.00     20       95              solutionsizeoutofallsimpliﬁedsolutionstoeachproblem.Wesee
                      Coin Sums                  2    1.00     33      213              that the smallest solution size is 9 instructions for two problems,
                      Cut Vector                 0        -      -     194              and two others have sizes of 10 and 11; three of these problems
                      Dice Game                  0        -      -     287              alsohadthehighestsuccessratesinPSB2.Manyothershavelarger
                      Find Pair                  4    1.00     16      763              smallest solution sizes, though we note that with the small sample
                      Fizz Buzz                 25    0.96     19      281              sizes of solutions for some problems, smaller solutions may exist.
                      Fuel Cost                 50    1.00      9      305              In comparison, [17] reported that 8 of the problems in PSB1 had
                      GCD                        8    0.67     19      198              a smallest solution size less than 9, the minimum for PSB2. Along
                      Indices of Substring       0        -      -     241              with success rates, these sizes of smallest solutions give evidence
                      Leaders                    0        -      -     302              that the problems in PSB2 are more diﬃcult than those in PSB1.
                      Luhn                       0        -      -     239                 ThelastcolumnofTable3givestheaveragenumberofseconds
                      Mastermind                 0        -      -     126              per generation over all of the PushGP runs for the problem. Note
                      Middle Character          57    0.86     10      547              that these runs were conducted on two diﬀerent computing clus-
                      Paired Digits              8    1.00     15      250              ters, each of which is composed of heterogeneous machines, so
                      Shopping List              0        -      -     714              these measurements should only be considered as rough approx-
                      SnowDay                    4    1.00     11      263              imations of running time. To that end, we note that all problems
                      Solve Boolean              5    1.00     18      373              havegenerational running timeswithinoneorderofmagnitudeof
                      Spin Words                 0        -      -     443              each other, meaning there are not any exceptionally slow or fast
                      Square Digits              0        -      -     435              problems.
                      Substitution Cipher       60    0.98      9      395
                      Twitter                   31    0.74     22      527
                      Vector Distance            0        -      -     667              9 CONCLUSIONS
                                                                                        We have presented PSB2, the second generation of general pro-
                                                                                        gram synthesis benchmark problems. We discussed the past re-
               each, but did not replicate these successes in our runs with ﬁnal-       search that has used PSB1, the lessons learned from years of its
               ized parameter settings. Additionally, in continued work using the       use, and why we need a new benchmark suite. We then provided
               same PushGP settings as this paper except using down-sampled             thesourcesandproblemsthatmakeupPSB2,givingdetailsofhow
               lexicase selection [18], small numbers of generalizing solutions         to implement and use it in new systems. Finally, we presented ex-
               were found to the problems Bouncing Balls, Dice Game, Indices            perimentalresultsshowingtheincreaseddiﬃcultyoftheproblems
               of Substring, and Square Digits problems [19]. Thus at least 18          of PSB2 compared to PSB1.
               of the 25 problems are solvable with the our PushGP implemen-               AftertheresultswehavepresentedusingPushGP,weanticipate
               tation. While we have noguarantees thattheother7problemscan              usingotherGPsystems(suchasthosewementioninSection2that
               be solved by any program synthesis system, they provide useful           have used PSB1) to produce initial results on PSB2 will provide a
               targets for future research.                                             useful comparison. Additionally, we encourage the application of
                  ThesecondcolumninTable3givesthegeneralizationrateofall                non-evolutionary automatic program synthesis methods to these
               evolvedsolutionsforproblemsonwhichPushGPproducedatleast                  problems, to better gauge the strengths and weaknesses of these
               one program that solved every training case. The generalization          diﬀerent methods.
               rate is calculated as the number of solution programs that pass the         ThelessonslearnedfromPSB1willmakeiteasiertoimplement
               unseen test set divided by the number of solution programs that          PSB2 in new program synthesis systems, increasing adoption in
               passthetrainingset.Formostproblemswithtrainingsetsolutions,              the community and furthering the ﬁeld. PSB2 will provide a new
               those solutions tended to generalize well with rates of 0.95 to 1.0.     target for program synthesis systems, stretching their capabilities
               Thethree problems with lower generalization rates, GCD, Middle           and moving the ﬁeld toward the types of problems that may be
               Character, and Twitter all had rates over 0.5. However, Bouncing         encountered in real-world program synthesis applications.
                    PSB2: The Second ProgramSynthesis Benchmark Suite                                                                                          GECCO’21,July10–14,2021, Lille, France
                    ACKNOWLEDGMENTS                                                                                [20] Thomas Helmuth, Lee Spector, and James Matheson. 2015.                       Solv-
                    Theauthorswouldlike to thank Lee Spector,Grace Woolson, and                                          ing Uncompromising Problems with Lexicase Selection.                IEEE Trans-
                                                                                                                         actions   on   Evolutionary    Computation    19,   5   (Oct.   2015),  630–643.
                    AmrAbdelhadyfordiscussions that helped shape this work.                                              https://doi.org/10.1109/TEVC.2014.2362729
                                                                                                                   [21] Thomas Helmuth, Lee Spector, Nicholas Freitag McPhee, and Saul Shanabrook.
                                                                                                                         2016. Linear Genomes forStructuredPrograms.InGenetic ProgrammingTheory
                                                                                                                         and Practice XIV (Genetic and Evolutionary Computation). Springer, Ann Arbor,
                                                                                                                         USA.
                    REFERENCES                                                                                     [22] Erik Hemberg, Jonathan Kelly, and Una-May O’Reilly. 2019.             On domain
                                                                                                                         knowledge and novelty to improve program synthesis performance with
                     [1] dnolan.       2015.                   Code       Wars:      Ten-Pin      Bowling.               grammatical evolution. In GECCO ’19: Proceedings of the Genetic and Evo-
                          https://www.codewars.com/kata/5531abe4855bcc8d1f00004c/javascript            Ac-               lutionary Computation Conference. ACM, Prague, Czech Republic, 1039–1046.
                          cessed: 2020-01-20.                                                                            https://doi.org/doi:10.1145/3321707.3321865
                     [2] Dheeru Dua and Casey Graﬀ. 2017.            UCI Machine Learning Repository.              [23] Jose Guadalupe Hernandez, Alexander Lalejini, Emily Dolson, and Charles
                          http://archive.ics.uci.edu/ml                                                                  Ofria. 2019.    Random subsampling improves performance in lexicase se-
                     [3] Project      Euler.    2002.                 Project    Euler:     Coin     Sums.               lection. In GECCO ’19: Proceedings of the Genetic and Evolutionary Com-
                          https://projecteuler.net/problem=31 Accessed: 2020-01-20.                                      putation Conference Companion. ACM, Prague, Czech Republic, 2028–2031.
                     [4] Project      Euler.    2008.                Project     Euler:     Dice     Game.               https://doi.org/doi:10.1145/3319619.3326900
                          https://projecteuler.net/problem=205 Accessed: 2020-01-20.                               [24] jacobb.    2014.         Code    Wars:   Simple    Substitution   Cipher   Helper.
                     [5] Austin J. Ferguson, Jose Guadalupe Hernandez, Daniel Junghans, Alexander                        https://www.codewars.com/kata/52eb114b2d55f0e69800078d                 Accessed:
                          Lalejini, Emily Dolson, and Charles Ofria. 2019. Characterizing the eﬀects of                  2020-01-20.
                          randomsubsamplinganddilutiononLexicaseselection.InGeneticProgramming                     [25] jhoﬀner.     2013.         Code     Wars:   Convert    string   to   camel    case.
                          Theory and Practice XVII, Wolfgang Banzhaf, Erik Goodman, Leigh Sheneman,                      https://www.codewars.com/kata/517abf86da9663f1d2000003                 Accessed:
                          Leonardo Trujillo, and Bill Worzel (Eds.). East Lansing, MI, USA.                              2020-01-20.
                     [6] Stefan Forstenlechner, David Fagan, Miguel Nicolau, and Michael O’Neill. 2017.            [26] Susumu Katayama. 2010.              Recent Improvements of MagicHaskeller.
                         AGrammar Design Pattern for Arbitrary Program Synthesis Problems in Ge-                         In  Approaches    and Applications     of   Inductive  Programming. Springer.
                          netic Programming.InEuroGP2017:Proceedings ofthe20thEuropeanConference                         https://doi.org/10.1007/978-3-642-11931-6_9
                          on Genetic Programming (LNCS, Vol. 10196). Springer Verlag, Amsterdam, 262–              [27] Jonathan Kelly, Erik Hemberg, and Una-May O’Reilly. 2019. Improving Genetic
                          277. https://doi.org/10.1007/978-3-319-55696-3_17                                              Programming with Novel Exploration - Exploitation Control. In EuroGP 2019:
                     [7] Stefan Forstenlechner, David Fagan, Miguel Nicolau, and Michael O’Neill. 2018.                  Proceedings of the 22nd European Conference on Genetic Programming, Lukas
                          Extending Program Synthesis Grammars for Grammar-Guided Genetic Pro-                           Sekanina, Ting Hu, NunoLourenço,Hendrik Richter,andPabloGarcía-Sánchez
                          gramming.In15thInternational Conferenceon Parallel Problem Solving from Na-                    (Eds.). Springer International Publishing, 64–80.
                          ture (LNCS, Vol. 11101), Anne Auger, Carlos M. Fonseca, Nuno Lourenco, Pe-               [28] KenKamau.        2017.               Code     Wars:      The     boolean     order.
                          nousal Machado, Luis Paquete, and Darrell Whitley (Eds.). Springer, Coimbra,                   https://www.codewars.com/kata/59eb1e4a0863c7ﬀ7e000008            Accessed: 2020-
                          Portugal, 197–208. https://doi.org/10.1007/978-3-319-99253-2_16                                01-20.
                     [8] Stefan Forstenlechner, David Fagan, Miguel Nicolau, and Michael O’Neill.                  [29] Alexander Lalejini and Charles Ofria. 2019.        Tag-accessed memory for ge-
                          2018.    Towards eﬀective semantic operators for program synthesis in                          netic programming. In GECCO ’19: Proceedings of the Genetic and Evolutionary
                          genetic programming. In GECCO ’18: Proceedings of the Genetic and                              Computation Conference Companion. ACM, Prague, Czech Republic, 346–347.
                          Evolutionary   Computation Conference. ACM, Kyoto, Japan, 1119–1126.                           https://doi.org/doi:10.1145/3319619.3321892
                          https://doi.org/10.1145/3205455.3205592                                                  [30] Trang T Le, William La Cava, Joseph D Romano, John T Gregg, Daniel J Gold-
                     [9] Stefan Forstenlechner, David Fagan, Miguel Nicolau, and Michael O’Neill. 2018.                  berg,PraneelChakraborty,NatashaLRay,DanielHimmelstein,WeixuanFu,and
                         Towards Understanding and Reﬁning the General Program Synthesis Bench-                          Jason H Moore. 2020. PMLB v1.0: an open source dataset collection for bench-
                          mark Suite with Genetic Programming. In 2018 IEEE Congress on Evolution-                       markingmachinelearning methods. arXiv preprint arXiv:2012.00058 (2020).
                          ary Computation (CEC), Marley Vellasco (Ed.). IEEE, Rio de Janeiro, Brazil.              [31] Jinsuk Lim and Shin Yoo. 2016. Field report: Applying monte carlo tree search
                          https://doi.org/doi:10.1109/CEC.2018.8477953                                                   for programsynthesis. In International Symposium on Search Based Software En-
                    [10] g964.       2015.                     Code       Wars:       Bouncing        Balls.             gineering. Springer, 304–310.
                          https://www.codewars.com/kata/5544c7a5cb454edb3c000047                 Accessed:         [32] David Lynch, James McDermott, and MichaelO’Neill. 2020. Program Synthesis
                          2020-01-20.                                                                                    in a Continuous Space using Grammars and Variational Autoencoders. In 16th
                    [11] Sumit Gulwani. 2011.       Automating String Processing in Spreadsheets Us-                     International Conference on Parallel Problem Solving from Nature, Part II (LNCS,
                          ing Input-output Examples.        SIGPLAN Not. 46, 1 (Jan. 2011), 317–330.                     Vol. 12270),ThomasBaeck,MikePreuss,AndreDeutz,HaoWang2,CarolaDoerr,
                          https://doi.org/10.1145/1925844.1926423                                                        MichaelEmmerich,andHeikeTrautmann(Eds.).Springer,Leiden, Holland, 33–
                    [12] Thomas       Helmuth       and      Peter     Kelly.    2019.                Gen-               47. https://doi.org/doi:10.1007/978-3-030-58115-2_3
                          eral      Program         Synthesis       Benchmark         Suite       Datasets.        [33] mcclaskc.     2014.          Code    Wars:   Validate    Credit   Card    Number.
                          https://github.com/thelmuth/program-synthesis-benchmark-datasets                               https://www.codewars.com/kata/5418a1dd6d8216e18a0012b2                 Accessed:
                    [13] Thomas Helmuth and Peter Kelly. 2021. PSB2: The Second Program Synthesis                        2020-01-20.
                          BenchmarkSuite. https://doi.org/10.5281/zenodo.4678739                                   [34] James McDermott, David R. White, Sean Luke, Luca Manzoni, Mauro Castelli,
                    [14] Thomas Helmuth, Nicholas Freitag McPhee, Edward Pantridge, and Lee                              Leonardo Vanneschi, Wojciech Jaskowski, Krzysztof Krawiec, Robin Harper,
                          Spector. 2017.    Improving Generalization of Evolved Programs Through                         Kenneth De Jong, and Una-May O’Reilly. 2012. Genetic programming needs
                         Automatic Simpliﬁcation. In Proceedings of the Genetic and Evolutionary                         better benchmarks. In GECCO ’12: Proceedings of the Genetic and evolution-
                          Computation Conference (GECCO ’17). ACM, Berlin, Germany, 937–944.                             ary computation conference. ACM, Philadelphia, Pennsylvania, USA, 791–798.
                          https://doi.org/10.1145/3071178.3071330                                                        https://doi.org/doi:10.1145/2330163.2330273
                    [15] Thomas Helmuth, Nicholas Freitag McPhee, and Lee Spector. 2018. Program                   [35] MrZizoScream.        2018.                 Code      Wars:      Array     Leaders.
                          Synthesis using Uniform Mutation by Addition and Deletion. In Proceedings of                   https://www.codewars.com/kata/5a651865fd56cb55760000e0                 Accessed:
                          theGeneticandEvolutionaryComputationConference (GECCO’18).ACM,Kyoto,                           2020-01-20.
                         Japan, 1127–1134. https://doi.org/10.1145/3205455.3205603                                 [36] myjinxin2015.     2016.          Code    Wars:    Fastest  Code:    Half   it   IV.
                    [16] Thomas Helmuth, Edward Pantridge, Grace Woolson, and Lee Spector.                               https://www.codewars.com/kata/5719b28964a584476500057d                 Accessed:
                          2020.   Genetic Source Sensitivity and Transfer Learning in Genetic Pro-                       2020-01-20.
                          gramming. In Artiﬁcial Life Conference Proceedings. MIT Press, 303–311.                  [37] MysteriousMagenta.       2014.           Code    Wars:    Square    Every    Digit.
                          https://doi.org/10.1162/isal_a_00326                                                           https://www.codewars.com/kata/546e2562b03326a88e000020                 Accessed:
                    [17] Thomas Helmuth and Lee Spector. 2015. General Program Synthesis Bench-                          2020-01-20.
                          mark Suite. In GECCO ’15: Proceedings of the 2015 conference on Genetic                  [38] Randal S. Olson, William La Cava, Patryk Orzechowski, Ryan J. Urbanow-
                          and Evolutionary Computation Conference. ACM, Madrid, Spain, 1039–1046.                        icz, and Jason H. Moore. 2017. PMLB: a large benchmark suite for machine
                          https://doi.org/doi:10.1145/2739480.2754769                                                    learning evaluation and comparison. BioData Mining 10, 1 (11 Dec 2017), 36.
                    [18] Thomas Helmuth and Lee Spector. 2020. Explaining and Exploiting the Advan-                      https://doi.org/10.1186/s13040-017-0154-4
                          tages of Down-sampled Lexicase Selection. In Artiﬁcial Life Conference Proceed-          [39] MichaelO’NeillandAnthonyBrabazon.2019. MutationalRobustnessandStruc-
                          ings. MIT Press, 341–349. https://doi.org/10.1162/isal_a_00334                                 tural Complexity in Grammatical Evolution. In 2019 IEEE Congress on Evolu-
                    [19] Thomas Helmuth and Lee Spector. 2021. Problem-solving beneﬁts of down-                          tionary Computation, CEC 2019, Carlos A. Coello Coello (Ed.). IEEE Computa-
                          sampled lexicase selection. Artiﬁcial Life (2021). In press.                                   tional Intelligence Society, IEEE Press, Wellington, New Zealand, 1338–1344.
                   GECCO’21,July10–14,2021, Lille, France                                                                                                    ThomasHelmuthandPeterKelly
                        https://doi.org/doi:10.1109/CEC.2019.8790010                                             Lourenco, and Eric Medvet (Eds.). Springer Verlag, Seville, Spain, 211–227.
                   [40] Michael O’Neill and Lee Spector. 2020. Automatic programming: The open is-               https://doi.org/doi:10.1007/978-3-030-44094-7_14
                        sue? Genetic Programming and Evolvable Machines 21, 1-2 (June 2020), 251–262.       [51] Lee Spector, Jon Klein, and Maarten Keijzer. 2005. The Push3 execution stack
                        https://doi.org/doi:10.1007/s10710-019-09364-2 Twentieth Anniversary Issue.              and the evolution of control. In GECCO 2005: Proceedings of the 2005 conference
                   [41] Edward Pantridge, Thomas Helmuth, Nicholas Freitag McPhee, and Lee Spec-                 on Genetic and evolutionary computation, Vol. 2. ACM Press, Washington DC,
                        tor. 2017.   On the Diﬃculty of Benchmarking Inductive Program Syn-                      USA, 1689–1696. https://doi.org/doi:10.1145/1068009.1068292
                        thesis Methods. In Proceedings of the Genetic and Evolutionary Computa-             [52] Lee Spector and Alan Robinson. 2002.         Genetic Programming and Au-
                        tion Conference Companion (GECCO ’17). ACM, Berlin, Germany, 1589–1596.                  toconstructive Evolution with the Push Programming Language.             Ge-
                        https://doi.org/doi:10.1145/3067695.3082533                                              netic  Programming and Evolvable Machines 3, 1 (March 2002), 7–40.
                   [42] Edward Pantridge and Lee Spector. 2020.     Code Building Genetic Program-               https://doi.org/doi:10.1023/A:1014538503543
                        ming. In Proceedings of the 2020 Genetic and Evolutionary Computation Confer-       [53] StephenLastname2. 2017.         Code Wars: Distance between two points.
                        ence (GECCO ’20). Association for Computing Machinery, internet, 994–1002.               https://www.codewars.com/kata/5a0b72484bebaefe60001867             Accessed:
                        https://doi.org/doi:10.1145/3377930.3390239                                              2020-01-20.
                   [43] rb50.2017.CodeWars:ShoppingList. https://www.codewars.com/kata/596266482f9add20[f5740]00s1tefcphenyu.    2014.                    Code      Wars:      Fizz      Buzz.
                        Accessed: 2020-01-20.                                                                    https://www.codewars.com/kata/5300901726d12b80e8000498             Accessed:
                   [44] ChristopherD.Rosin.2019. SteppingStonestoInductiveSynthesisofLow-Level                   2020-01-20.
                        Looping Programs.InProceedings ofthe Thirty-Third AAAIConference on Artiﬁ-          [55] Eric    Wastl.   2015.           Advent    of   Code:    Not    Quite   Lisp.
                        cial Intelligence (AAAI ’19, Vol. 33). AAAI Press, Palo Alto, California USA.            https://adventofcode.com/2015/day/1 Accessed: 2020-01-20.
                   [45] RVdeKoning.     2015.          Code    Wars:   Greatest   common     divisor.       [56] Eric    Wastl.   2017.            Advent    of    Code:   Inverse   Captcha.
                        https://www.codewars.com/kata/5500d54c2ebe0a8e8a0003fd/python            Ac-             https://adventofcode.com/2017/day/1 Accessed: 2020-01-20.
                        cessed: 2020-01-20.                                                                 [57] Eric Wastl. 2019.     Advent of Code: The Tyranny of the Rocket Empire.
                   [46] Anil Kumar Saini and Lee Spector. 2019. Using Modularity Metrics as Design               https://adventofcode.com/2019/day/1 Accessed: 2020-01-20.
                        Features to Guide Evolution in Genetic Programming. In Genetic Programming          [58] Eric    Wastl.    2020.            Advent     of   Code:    Report    Repair.
                        Theory and Practice XVII, Wolfgang Banzhaf, Erik Goodman, Leigh Sheneman,                https://adventofcode.com/2020/day/1 Accessed: 2020-01-20.
                        Leonardo Trujillo, and Bill Worzel (Eds.). Springer, East Lansing, MI, USA, 165–    [59] David R. White, James Mcdermott, Mauro Castelli, Luca Manzoni, Brian W.
                        180. https://doi.org/doi:10.1007/978-3-030-39958-0_9                                     Goldman,GabrielKronberger,WojciechJaśkowski,Una-MayO’Reilly,andSean
                   [47] Anil Kumar Saini and Lee Spector. 2020. Why and When Are Loops Useful                    Luke. 2013.   Better GP benchmarks: community survey results and propos-
                        in Genetic Programming?. In Proceedings of the 2020 Genetic and Evolutionary             als.  Genetic Programming and Evolvable Machines 14, 1 (March 2013), 3–29.
                        Computation Conference Companion (GECCO ’20). Association for Computing                  https://doi.org/10.1007/s10710-012-9177-2
                        Machinery,internet, 247–248. https://doi.org/doi:10.1145/3377929.3389919            [60] John Woodward, Simon Martin, and Jerry Swan. 2014. Benchmarks that matter
                   [48] Shivo.   2015.            Code    Wars:    Get    the    Middle    Character.            for genetic programming. In GECCO 2014 4th workshop on evolutionary com-
                        https://www.codewars.com/kata/56747fd5cb988479af000028             Accessed:             putation for the automated design of algorithms. ACM, Vancouver, BC, Canada,
                        2020-01-20.                                                                              1397–1404. https://doi.org/doi:10.1145/2598394.2609875
                   [49] smile67.      2016.                   Code       Wars:      Text      Search.       [61] xDranik.    2013.           Code    Wars:   Stop    gninnipS   My     sdroW!
                        https://www.codewars.com/kata/56b78faebd06e61870001191             Accessed:             https://www.codewars.com/kata/5264d2b162488dc400000001             Accessed:
                        2020-01-20.                                                                              2020-01-20.
                   [50] Dominik Sobania and Franz Rothlauf. 2020. Challenges of Program Synthe-
                        sis with Grammatical Evolution. In EuroGP 2020: Proceedings of the 23rd Euro-
                        pean Conference on Genetic Programming (LNCS, Vol. 12101), Ting Hu, Nuno
