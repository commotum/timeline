Synthesis From Examples: Interaction Models and Algorithms
(Invited Talk Paper)

Sumit Gulwani
Microsoft Research
Redmond, WA, USA
sumitg @microsoft.com

Abstract—Examples are often a natural way to specify
various computational artifacts such as programs, queries,
and sequences. Synthesizing such artifacts from example based
specifications has various applications in the domains of end-
user programming and intelligent tutoring systems. Synthesis
from examples involves addressing two key technical chal-
lenges: (i) design of a user interaction model to deal with
the inherent ambiguity in the example based specification. (ii)
design of an efficient search algorithm - these algorithms have
been based on paradigms from various communities including
use of SAT/SMT solvers (formal methods community), version
space algebras (machine learning community), and A*-style
goal-directed heuristics (AI community).

This paper describes some effective user interaction models
and algorithmic methodologies for synthesis from examples
while discussing synthesizers for a variety of artifacts rang-
ing from tricky bitvector algorithms, spreadsheet macros for
automating repetitive data manipulation tasks, ruler/compass
based geometry constructions, algebraic identities, and pre-
dictive intellisense for repetitive drawings and mathematical
terms.

Keywords-Program Synthesis, Inductive Synthesis, End User
Programming, Intelligent Tutoring Systems, Domain Specific
Languages, Programming By Example

I. INTRODUCTION

Program synthesis is the task of automatically synthe-
sizing a program in some underlying domain-specific lan-
guage (DSL) from a given specification using some search
technique [1]. A traditional view of program synthesis is
that of synthesizing programs from complete specifications.
One approach is to give a specification as a formula in a
suitable logic [2]—[7]. Another is to write the specification
as a simpler, but possibly far less efficient program [8]-[10].
While these approaches have the advantage of completeness
of specification, such specifications are often unavailable,
difficult to write, or expensive to check against using au-
tomated verification techniques. In this paper, we focus on
another style of specification, namely examples [11]-[13].
Programming by example (PBE) can be seen as a dual
to program testing, which has seen decades of successful
research. Instead of finding test cases that explore various
paths in a given program (and potentially expose any bugs),
the goal here is to synthesize programs in the first place
starting from test cases, i.e., input-output examples.

There are two key challenges in designing inductive
synthesizers that take examples as specifications. The first
challenge is that of designing a good user interaction model
that can deal with the inherent ambiguities in examples,
which are often an under-specification of the user’s intent.
§II discusses a variety of effective user interaction models.

The second challenge is that of designing an efficient
algorithm that can search for desired artifacts (in the under-
lying DSL) that are consistent with the given examples. §III
discusses some general algorithmic methodologies. These
involve use of techniques that have been developed in
various communities including use of SAT/SMT constraint
solvers (formal methods community), version space algebras
(machine learning community), and A*-style goal-directed
heuristics (AI community).

We briefly discuss applications of inductive synthesizers
to not only synthesis of a variety of traditional programs
such as bitvector algorithms (§IV-A) and spreadsheet macros
(8IV-B) but also to synthesis of more general structured con-
cepts or artifacts such as geometric constructions (§IV-C),
algebraic identities (IV-D), sequences (§IV-E), and even
drawings (8IV-F).

II. INTERACTION MODELS

While examples constitute the most natural form of speci-
fication in several cases, they are often an under-specification
of the intent. We discuss below some general methodologies
for resolving ambiguities in the example based specification.

A. User Driven Interaction

This is the most intuitive and widely applicable interaction
model. The user may verify the artifact returned by the
synthesizer either by examining the artifact itself, or by
examining its behavior on several other inputs. If the user
finds any discrepancy in the behavior of the artifact and
the expected behavior on some new input, the user may
repeat the synthesis process after adding the new input-
output example to the previous set of input-output examples.

B. Synthesizer Driven Interaction

This interaction model obviates the need for the user to
verify the synthesized artifact and provide any counterexam-
