      A                             B
      Figure 6: Quantitative comparisons of DreamCoder performance with ablations and baseline program
      induction methods; further baselines shown in Fig. S13. (A) Held-out test set accuracy, across 20
      iterations of wake/sleep learning for six domains. Generative text modeling plots show posterior
      predictive likelihood of held-out strings on held out tasks, normalized per-character. Error bars:
      ±1std. dev. over ﬁve runs. (B) Evolution of library structure over wake/sleep cycles (darker: earlier
      cycles; brighter: later cycles). Each dot is a single wake/sleep cycle for a single run on a single domain.
      Larger, deeper libraries are correlated with solving more tasks. The dreaming phase bootstraps these
      deeper, broader libraries, and also, for a ﬁxed library structure, dreaming leads to higher performance.
      concepts allowing it to solve all the problems in a domain?
        Motivated by classic work on inferring physical laws from experimental data (39–41), we ﬁrst task
      DreamCoderwithlearning equations describing 60 different physical laws and mathematical identities
      taken from AP and MCAT physics “cheat sheets”, based on numerical examples of data obeying
      each equation. The full dataset includes data generated from many well-known laws in mechanics
      and electromagnetism, which are naturally expressed using concepts like vectors, forces, and ratios.
      Rather than give DreamCoder these mathematical abstractions, we initialize the system with a much
      more generic basis — just a small number of recursive sequence manipulation primitives like map
      and fold, and arithmetic — and test whether it can learn an appropriate mathematical language of
      physics. Indeed, after 8 wake/sleep cycles DreamCoder learns 93% of the laws and identities in the
      dataset, by ﬁrst learning the building blocks of vector algebra, such as inner products, vector sums, and
      norms (Fig. 7A). It then uses this mathematical vocabulary to construct concepts underlying multiple
      physical laws, such as the inverse square law schema that enables it to learn Newton’s law of gravitation
      and Coulomb’s law of electrostatic force, effectively undergoing a ‘change of basis’ from the initial
      recursive sequence processing language to a physics-style basis.
        Could DreamCoder also learn this recursive sequence manipulation language? We initialized the
      system with a minimal subset of 1959 Lisp primitives (car, cdr, cons, ...) and asked it to solve 20
                          14
