                         Preprint.
                         Figure 2: Method Diagram. Implementing a memory system requires defining (1) what is stored,
                         (2) how memory is updated, and (3) how memory is used for new queries. The key novelty in
                         this work is emphasizing abstraction and modularity, and the corresponding design changes. In
                         particular, we highlight that parameterization (with higher-order functions allowed and encouraged)
                         promotes abstraction, and typed interface definitions support modularity by showing which concepts
                         can be combined. Since these memory entries are more abstract, they also require more inference
                         to map against new, concrete situations–whether by aligning input against the memory format in a
                         preprocessing query, or leveraging reasoning models to explore in a directed manner.
                         enabling memoryselection, since greater abstraction makes standard retrieval approaches (embedding
                         similarity thresholding) less effective. We present two such implementations: (1) an open-ended (OE)
                         format that imposes minimal constraints on entry format and uses a simple problem preprocessing
                         step for memory selection, and (2) a program-synthesis (PS) inspired format that categorizes and
                         parameterizes concepts and uses reasoning model exploration to select relevant items.
                         ProblemAssumptions. Themainrequirementforourmemorysystemisthatsomefeedbackis
                         available at test-time (e.g. via test cases or self-reflection). This condition is necessary as retaining
                         patterns from an incorrect or otherwise flawed trace would serve to carry mistakes forward. In other
                         words, some signal is needed to discriminate correct from incorrect traces to ensure only productive
                         ideas and patterns are added to memory. Incorrect traces still likely contain vital signal, but error
                         identification/credit assignment remains an open challenge that we leave to future efforts. Various
                         real-world tasks may satisfy this requirement, as tasks are often specified with either examples
                         showing desired behavior or evaluation criteria defining what outcomes are positive and negative.
                         Togivesomeexamples,codecompletiontoolshavecriteria like compilation success and test pass
                         rate, and medical diagnosis tools have evaluation criteria defined as patient outcomes (e.g., survival
                         rates). In the case of our evaluation benchmark ARC-AGI, puzzles are explicitly presented as a set of
                         input-output examples, which, for our purposes, can serve as automatically verifiable test cases.
                         3.2  MEMORYFORMATANDORGANIZATION
                         Specifying an individual memory entry’s format involves selecting fields useful for retrieval and
                         downstream problem-solving. The organization of memory entries on a collective level is another
                         design surface we leave for future exploration; we use a flat collection of entries for simplicity.
                         Open-Ended(OE)Formulation. Wefirstconsideranopen-endedapproachthat imposes minimal
                         structure and defers formatting individual memories to the model. Following the basic lesson
                                                                    4
