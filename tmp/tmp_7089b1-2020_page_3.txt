              Figure 1: (A): Learning tasks in many different domains can be formulated as inducing a program that
              explains a small number of input-output examples, or that generates an observed sequence, image or
              scene. DreamCoder successfully learns to synthesize programs for new tasks in each of these domains.
              (B): An illustration of how DreamCoder learns to solve problems in one domain, processing lists of
              integers. Problems are speciﬁed by input-output pairs exemplifying a target function (e.g., ‘Sort List’).
              Giveninitial primitives (left), the model iteratively builds a library of more advanced functions (middle)
              and uses this library to solve problems too complex to be solved initially. Each learned function can
              call functions learned earlier (arrows), forming hierarchically organized layers of concepts. The learned
              library enables simpler, faster, and more interpretable problem solving: A typical solution to ‘Sort List’
              (right), discovered after six iterations of learning, can be expressed with just ﬁve function calls using
              the learned library and is found in less than 10 minutes of search. The code reads naturally as “get
              the nth largest number, for n = 1,2,3,....” At bottom the model’s solution is re-expressed in terms of
              only the initial primitives, yielding a long and cryptic program with 32 function calls, which would
                                  72
              take in excess of 10   years of brute-force search to discover.
              progressively over time, building each concept on those acquired before, inspired by how humans
              build conceptual systems: we learn algebra before calculus, and only after arithmetic; we learn to draw
              simple shapes before more complex designs. For example, in the list processing example (Fig. 1B), our
              modelcomestosortsequencesofnumbersbyinvokingalibrarycomponentfourlayers deep – take
              the nth largest element – and this component in turn calls lower-level learned concepts: maximum, and
              ﬁlter. Equivalent programs could in principle be written in the starting language, but those produced
              bythe ﬁnal learned language are more interpretable and much shorter. Expressed only in the initial
              primitives, these programs would be so complex as to be effectively out of the learners reach: they
              would never be found during a reasonably bounded search. Only with acquired domain-speciﬁc
              expertise do most problems become practically solvable.
                  DreamCoder gets its name from how it grows domain knowledge iteratively, in “wake-sleep”
              cycles loosely inspired by the memory consolidation processes that occur during different stages of
                                                                 3
