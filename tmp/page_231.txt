218 = Unified Theories of Cognition

mycin (Clancey & Letsinger, 1981), in order to use the knowledge
in Mycin in an intelligent tutoring context. Neomycin-Soar attempts
to do exactly the task of Neomycin with exactly the same knowl-
edge, so that, as with Rl-Soar, we can learn as much as possible
from the comparison of the two systems.

With respect to learning, summarizing by specific task does not
make sense, since Soar learns in all the tasks it performs. But it
does learn the different components of its own internal structure—
operator selection, search control, operator implementations, new
operators, problem spaces. Soar provides a form of explanation-
based generalization (Mitchell, Keller, & Kedar-Cabelli, 1986),
which means it learns from examining single cases, analyzing the
behavior in detail, and using an underlying theory of the domain to
derive some heuristics from the case that can be helpful in later
problem solving (Rosenbloom & Laird, 1986). Soar does other
forms of learning, but these will be discussed more in Chapter 6 on
learning, memory, and skill. Soar does a simple form of abstraction
planning, also using chunking (Unruh, Rosenbloom, & Laird, 1987;
Unruh & Rosenbloom, 1989). In evaluating an operator, pursuant
to resolving a tie impasse, it abstracts away from various aspects of
the situation that keep the operator from being applicable, thus
letting its look-ahead evaluation proceed. As it does so, it builds
chunks (automatically, of course, because it is always chunking).
These chunks can transfer to the fully detailed situation to help
make selections. Compared with the usual form of abstraction plan-
ning (Sacerdoti, 1974), Soar is not making deliberate decisions to
plan—it plans automatically just by the decision to abstract. Fur-
thermore, it is not making any deliberate decisions to implement a
plan—the chunks simply get evoked in the appropriate context.

The effort to use Soar for constraint compilation provides an
interesting point. Recently, programming languages have been de-
veloped that make use of constraint propagation. Much of this work
was pioneered by Gerald Sussman at the MIT Al Laboratory, and a
particularly useful point of reference is Guy Steele's thesis from
that group (Steele, 1980). From the standpoint of a programming
language, the user simply writes down a set of constraints and the
system compiles code to produce the values of the variables that
satisfy the constraints. Soar can be given the knowledge about
constraint propagation so that it can solve a constraint-propagation

