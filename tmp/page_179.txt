166 = Unified Theories of Cognition

retrieving declarative information as it is a scheme for procedural
memory. In Soar, the production system plays both roles.

The Soar production system is realized within Ops5 (Forgy,
1981), a language that was developed in the late 1970s and has
become a standard production system in the expert-system field
(Brownston, Farrell, Kant, & Martin, 1985). Thus, the details of
productions are taken from Ops5. Conditions are not arbitrary tests
but patterns to be matched. The patterns can contain variables and
the same variable can occur in more than one condition, in which
case it must take the same value at all occurrences, providing in
effect a test for equality. Conditions can test for the absence of an
element in working memory as well as for the presence of an ele-
ment. All possible instantiations are found on each cycle (that is, all
possible sets of working-memory elements that satisfy each produc-
tion, along with the bindings of the variables).

Figure 4-4 shows an example of a Soar production that proposes
an operator to be used to take in information about a blocks-world
task. An English paraphrase is shown at the top, then below it the
actual production, then some working-memory elements that the
production matches, and, at the bottom, the new elements that are
added to working memory when the production fires.

Each working-memory element is a single attribute and value of
an object. For instance, in the top line describing the working mem-
ory before the production fires, goal object g3 has the problem
space p14 is one element; goal g3 has the state s5t is another ele-
ment. Objects have an arbitrary identifier (g3), assigned by Soar
when the object is created (the prefix, g, is simply a mnemonic to
help the user); all attributes are marked by and their values directly
follow them. Also, as an aid to the user, alf elements about the same
object (here g3) are grouped together; elements can be distributed
anywhere in working memory and in any order.

The production's name is propose-operator*comprehend; it has
five conditions and three actions. The first condition matches the
goal object (goal . . .), whose identifier 23 will be bound to the
variable <g> (all variables in productions are indicated by angle
brackets). The goal element must have anattribute problem-space,
whose value will be bound to the variable <p>; and an attribute

state, whose value will be bound to the variable <s>. This first
condition doesnâ€™t constrain the match beyond specifying that it be
linked to an active goal element, since all the values are simply
