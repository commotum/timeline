84 « Unified Theories of Cognition

even massive parallelism, is a device not to introduce new functions
but to exploit new underlying technology. The changes in the ar-
chitecture may be radical, of course, and the technology may dic-
tate the entire style of computation. Furthermore, although power,
speed, and memory are continuous parameters, they can result in
qualitatively different computations with every order-of-magnitude
change, Real-time constraints especially reveal the effect of amount
of computation available within specified time limits.

Interestingly, all the qualitative additions of functionality have
served to increase the autonomy of computers—their ability to
exist on their own. An important example is the interrupt, the abil-
ity for some agency external to the main cycle of operation of the
computer to gain control of the behavior of the computer im-
mediately, independently of what the computer is doing. Interrup-
tion is clearly an important function in interacting with a dynamic
external world; it is also useful for many internal functions as well.
Interrupt mechanisms have been with us for so long that many may
not realize that early computers had no such mechanisms; instead,
they polled the external world. They always had control and only
when the program asked about the outside world could they find out
anything about it. Not surprisingly, it did not take long before all
computers had interrupt mechanisms.

Mechanisms for protection came along somewhat later. They
provided reliable internal barriers (fixed in hardware) to keep activ-
ity in one part of the system from affecting other parts of the sys-
tem. The need for protection arose as soon as multiple tasks were
performed in a computer, either because of multiple users or be-
cause complex tasks were decomposed into subtasks that had per-
manent residence.

Dynamic resource allocation is another function that increases
the autonomy of a system, In early systems, all memory was al-
located in fixed arrays, as specified by the programmer. This im-
plied a certain specificity of prevision on the programmer's part.
Having the system keep a list of available resources from which the
system itself can dispense new resources on demand, along with a
collection operation to return unused resources to the list, not only
permits the programmer to avoid planning these steps but permits
the computer to accomplish tasks where the space required is un-
predictable, even approximately, at the time the program is de-
signed. Interestingly, dynamic resource allocation does not seem

