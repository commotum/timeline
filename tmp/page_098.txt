Foundations of Cognitive Science » 85

i to require much if anything in the way of hardware support. The
mechanisms (essentially list processing) are quite adequately real-
ized in software. They must, however, remain in place and operate
continually and permanently. Thus, they become an addition to the
fixed structure, which is to say, to the architecture.

Dynamic memory allocation is a good example to emphasize that
the distinction between architecture, as fixed structure, and con-
tent, as variable data, is not quite the same as the distinction be-
tween hardware and software. That is, many fixed mechanisms may
be cast as software—the programs for doing allocation in our ex-
ample, along with various data structures that are used to keep the
list of available resources. That a software mechanism can be
changed does not mean that it must be changed. It is thus that all
sorts of software systems and software architectures are built up
that transform one architecture into another.'© What remains con-
stant is that, at the bottom, there is a pure hardware architecture
(what is often referred to as the machine architecture or the ma-
chine language). A number of factors impinge on whether a given
fixed mechanism will end up in hardware or software—how fast it
must operate, how expensive is its hardware realization, and how
complex it is. There is a technological limit to how much complex-
ity can be realized in hardware directly, without organizing that
hardware as a computer so the complexity can be shifted into soft-
ware.

The evolution of computers toward greater autonomy makes emi-
nent sense, given their history. Computers are, in effect, kept sys-
tems. They have human keepers—trainers and operators—who do
everything for the computers that computers can’t do for them-
selves. When computers crash, their keepers pick them up and start
them going again. When computers can’t perform some task, such
as getting information from another place, their trainers get the
information and put it in a form that the computer can use. This is
reminiscent of the old joke among psychologists of one rat remark-
ing to another rat on how they have trained the experimenter to
bring them cheese. The reason for computers’ lack of autonomy is
not hard to discern. The important criteria have always been eco-

16, For instance, Soar, the architecture to be used throughout the book, is realized as
a software architecture programmed in Common Lisp, another software architecture,
which itself runs on a hardware architecture.

8

Ws
