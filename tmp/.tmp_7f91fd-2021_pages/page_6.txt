                                                     Large-scale few-shot program induction and synthesis 
               The upshot of the consecutive overapproximating and un-
                derapproximating phases is an excellent approximation to 
                the true equivalence relation, which is undecidable. Using 
                tests we can prove that two programs are not equivalent, 
                but not the opposite.  Using Yogo we can prove they are 
                equivalent, but not the opposite. This leaves only a small 
                set of ambiguous relations. 
               The rest of this section summarizes Yogo and how it proves 
                programs equivalent. 
                Equality Saturation and E-PEGs  An expression such 
                as x < y and  y < z can be rewritten into many equiva-
                lent forms using rules such as not(y <= x or  y <= z) 
                or even the redundant z > y and  y > x and  z > x. 
                E-graphs (equivalence graphs (Nelson & Oppen, 1980) 
                are a way to compactly represent the exponential number 
                of equivalent expressions that can be found by a set of 
                rewrite rules. From the initial expression Abstract Syntax 
               Tree(AST), equality saturation is performed, adding each 
                newly-discovered equivalent expression to the e-graph via 
                an extension of the union-fnd algorithm.                            Figure 3. Subset of some interesting signatures in our dataset, all 
                E-graphs are a powerful technique, but have traditionally           with at least 200 tasks. Color indicates the length distribution of 
                only been applicable to pure, loop-free programs. Program           programs for each signature. Most programs have few inputs and 
                Expression Graphs (PEGs) (Tate et al., 2009) are a new              output integers or booleans. There are programs doing array and 
                representation of programs that allows equational reason-           string manipulation, as well as some matrix operations. 
                ing and build e-graphs on arbitrary imperative programs. 
                Conceptually, PEGs can be thought of as being constructed           from few variables. There are other signatures that involve 
                by unrolling loops into an infnite tree, and then compactly         array, matrix and string manipulations, often conditioned on 
                representing this infnite-but-regular tree as a cycle in the        other variables like integers or individual characters. These 
                graph.  Equality saturation then yields an e-graph on the           are interesting as they often require to generalize to longer 
                PEG (or E-PEG), representing an exponentially-large space           computations as well as bigger data structures. 
                of equivalent programs. This was originally used for com-           Figure 4 shows the diffculty of our tasks along three differ-
                piler optimization, but Yogo (Premtoon et al., 2020) uses it        ent axis. First, many problems contain either if-statements 
                for code search â€” and now also for equivalence-checking.            or loops that require generalizing more than 10 times the 
                Yogo:  Equivalence Checking from E-PEGs  We cus-                    number of operations needed for training examples. Condi-
                tomized Yogo to work on our codebase.  Even though it               tional execution (characterized by nesting in C++) is often 
                originally only handled Java and Python, it is built on the         very hard for program induction techniques.  Our bench-
                Cubix (Koppel et al., 2018) multi-language infrastructure,          mark contains a wide variability of nesting quantities across 
                allowing us to add support for a subset of C that captures          different subprograms.Finally, our input and outputs follow 
                the subset of C++ in PROGRES, after some simple string              a very structured distribution, since they come from real 
                transformations, e.g.:  changing vector<int>  foo to                examples. For instance, most integers are small (note the 
                struct  vector  foo.  To check for equivalences be-                 logarithmic y axis), with positive numbers being more com-
                tween functions, we put them into a single E-PEG, assigning         mon. Moreover, special numbers like 100 and -100 are more 
                each the same start state. Then, we report two subprograms          common than numbers of similar magnitude. 
                as equivalent if equality saturation groups their return values     3.5. Accompanying environment 
                in the same equivalence class. 
                                                                                    In order to be able to test candidate programs, we include 
                3.4. Statistical analysis                                           a python interface to our C++ interpreter. The interface is 
                Figure 3 shows the variability of signatures on our bench-          easy to use and has two different modes: 
                mark. As expected, the most common signatures involve                 1.  We can run an entire C++ function on a set of inputs by 
                integer manipulations as well as classifcation problems                  passing the former as a string and the latter as a list of 
