            AppendixforProductofExpertswithLLMs: BoostingPerformanceonARCisaMatterofPerspective
       A. Appendix: DFS Algorithm
       Thealgorithm presented here assumes that the model supports internal caching for already seen sequences and only needs to
       process the newly added tokens. Note that we use negative log probabilities to avoid numerical issues, while the main
       paper uses percentage values for clarity.
       Ouractual implementation differs from this simple variant, as we are using unsloth, which does not support dynamic caching
       and requires us to prune the key-value-cache of the transformer ourselves.
       Furthermore, we use various performance optimizations, like a simultaneous initial forward pass of the best known sequence
       including prompt and prediction (which is much faster than token-by-token generation) as well as aggregating the sequences
       during backtracking to avoid the unnecessary processing of sequences that would be discarded later
       Algorithm 1 Depth-First Probability-Guided Sampling for LLMs.
        function DFS sample {model,prompt,threshold,max len,eos id}
         Input: model is the language model
         Input: prompt is the prompt that should be completed
         Input: threshold is the maximum negative log probability allowed
         Input: max len is the maximum length (including the prompt)
         Input: eos id is the index of the end of sentence token
         function Explore {tokens,score}
          if tokens[−1] = eos id or |tokens| ≥ max len then
           return (score,tokens)
          endif
          next token logits ← model.predict logits(tokens)[−1]
          next token log prob ← −log softmax(next token logits)
          valid sequences ← ∅
          for each possible next token t do
           next score ← score+next token log prob[t]
           if next score ≤ threshold then
            next tokens ← current tokens+[t]
            continuations ← Explore(next tokens,next score)
            valid sequences ← valid sequences∪continuations
           endif
          endfor
          return valid sequences
         endfunction
         return Explore(prompt,0.0)
        endfunction
                                  12
